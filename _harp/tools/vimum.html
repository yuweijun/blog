<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>VIM USER MANUAL - by Bram Moolenaar</title>
</head>
<body>
<pre>
		     VIM USER MANUAL - by Bram Moolenaar

<span class="highlight"><b><i>*usr_toc.txt*</i></b></font></span>   For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2002 Mar 09


                              Table Of Contents                 <span class="highlight"><b><i>*user-manual*</i></b><span>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b>Overview </b><span><font color="#e5e5e5">~</font>

Getting Started
<span class="highlight"><i>|usr_01.txt|</i><span>  About the manuals
<span class="highlight"><i>|usr_02.txt|</i><span>  The first steps in Vim
<span class="highlight"><i>|usr_03.txt|</i><span>  Moving around
<span class="highlight"><i>|usr_04.txt|</i><span>  Making small changes
<span class="highlight"><i>|usr_05.txt|</i><span>  Set your settings
<span class="highlight"><i>|usr_06.txt|</i><span>  Using syntax highlighting
<span class="highlight"><i>|usr_07.txt|</i><span>  Editing more than one file
<span class="highlight"><i>|usr_08.txt|</i><span>  Splitting windows
<span class="highlight"><i>|usr_09.txt|</i><span>  Using the GUI
<span class="highlight"><i>|usr_10.txt|</i><span>  Making big changes
<span class="highlight"><i>|usr_11.txt|</i><span>  Recovering from a crash
<span class="highlight"><i>|usr_12.txt|</i><span>  Clever tricks

Editing Effectively
<span class="highlight"><i>|usr_20.txt|</i><span>  Typing command-line commands quickly
<span class="highlight"><i>|usr_21.txt|</i><span>  Go away and come back
<span class="highlight"><i>|usr_22.txt|</i><span>  Finding the file to edit
<span class="highlight"><i>|usr_23.txt|</i><span>  Editing other files
<span class="highlight"><i>|usr_24.txt|</i><span>  Inserting quickly
<span class="highlight"><i>|usr_25.txt|</i><span>  Editing formatted text
<span class="highlight"><i>|usr_26.txt|</i><span>  Repeating
<span class="highlight"><i>|usr_27.txt|</i><span>  Search commands and patterns
<span class="highlight"><i>|usr_28.txt|</i><span>  Folding
<span class="highlight"><i>|usr_29.txt|</i><span>  Moving through programs
<span class="highlight"><i>|usr_30.txt|</i><span>  Editing programs
<span class="highlight"><i>|usr_31.txt|</i><span>  Exploiting the GUI

Tuning Vim
<span class="highlight"><i>|usr_40.txt|</i><span>  Make new commands
<span class="highlight"><i>|usr_41.txt|</i><span>  Write a Vim script
<span class="highlight"><i>|usr_42.txt|</i><span>  Add new menus
<span class="highlight"><i>|usr_43.txt|</i><span>  Using filetypes
<span class="highlight"><i>|usr_44.txt|</i><span>  Your own syntax highlighted
<span class="highlight"><i>|usr_45.txt|</i><span>  Select your language

Making Vim Run
<span class="highlight"><i>|usr_90.txt|</i><span>  Installing Vim


The user manual is available as a single, ready to print HTML and PDF file
here:
        http://vimdoc.sf.net

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b>Getting Started </b><span><font color="#e5e5e5">~</font>

Read this from start to end to learn the essential commands.

<span class="highlight"><i>|usr_01.txt|</i><span>  About the manuals
                <span class="highlight"><i>|01.1|</i><span>  Two manuals
                <span class="highlight"><i>|01.2|</i><span>  Vim installed
                <span class="highlight"><i>|01.3|</i><span>  Using the Vim tutor
                <span class="highlight"><i>|01.4|</i><span>  Copyright

<span class="highlight"><i>|usr_02.txt|</i><span>  The first steps in Vim
                <span class="highlight"><i>|02.1|</i><span>  Running Vim for the First Time
                <span class="highlight"><i>|02.2|</i><span>  Inserting text
                <span class="highlight"><i>|02.3|</i><span>  Moving around
                <span class="highlight"><i>|02.4|</i><span>  Deleting characters
                <span class="highlight"><i>|02.5|</i><span>  Undo and Redo
                <span class="highlight"><i>|02.6|</i><span>  Other editing commands
                <span class="highlight"><i>|02.7|</i><span>  Getting out
                <span class="highlight"><i>|02.8|</i><span>  Finding help

<span class="highlight"><i>|usr_03.txt|</i><span>  Moving around
                <span class="highlight"><i>|03.1|</i><span>  Word movement
                <span class="highlight"><i>|03.2|</i><span>  Moving to the start or end of a line
                <span class="highlight"><i>|03.3|</i><span>  Moving to a character
                <span class="highlight"><i>|03.4|</i><span>  Matching a paren
                <span class="highlight"><i>|03.5|</i><span>  Moving to a specific line
                <span class="highlight"><i>|03.6|</i><span>  Telling where you are
                <span class="highlight"><i>|03.7|</i><span>  Scrolling around
                <span class="highlight"><i>|03.8|</i><span>  Simple searches
                <span class="highlight"><i>|03.9|</i><span>  Simple search patterns
                <span class="highlight"><i>|03.10|</i><span> Using marks

<span class="highlight"><i>|usr_04.txt|</i><span>  Making small changes
                <span class="highlight"><i>|04.1|</i><span>  Operators and motions
                <span class="highlight"><i>|04.2|</i><span>  Changing text
                <span class="highlight"><i>|04.3|</i><span>  Repeating a change
                <span class="highlight"><i>|04.4|</i><span>  Visual mode
                <span class="highlight"><i>|04.5|</i><span>  Moving text
                <span class="highlight"><i>|04.6|</i><span>  Copying text
                <span class="highlight"><i>|04.7|</i><span>  Using the clipboard
                <span class="highlight"><i>|04.8|</i><span>  Text objects
                <span class="highlight"><i>|04.9|</i><span>  Replace mode
                <span class="highlight"><i>|04.10|</i><span> Conclusion

<span class="highlight"><i>|usr_05.txt|</i><span>  Set your settings
                <span class="highlight"><i>|05.1|</i><span>  The vimrc file
                <span class="highlight"><i>|05.2|</i><span>  The example vimrc file explained
                <span class="highlight"><i>|05.3|</i><span>  Simple mappings
                <span class="highlight"><i>|05.4|</i><span>  Adding a plugin
                <span class="highlight"><i>|05.5|</i><span>  Adding a help file
                <span class="highlight"><i>|05.6|</i><span>  The option window
                <span class="highlight"><i>|05.7|</i><span>  Often used options

<span class="highlight"><i>|usr_06.txt|</i><span>  Using syntax highlighting
                <span class="highlight"><i>|06.1|</i><span>  Switching it on
                <span class="highlight"><i>|06.2|</i><span>  No or wrong colors?
                <span class="highlight"><i>|06.3|</i><span>  Different colors
                <span class="highlight"><i>|06.4|</i><span>  With colors or without colors
                <span class="highlight"><i>|06.5|</i><span>  Printing with colors
                <span class="highlight"><i>|06.6|</i><span>  Further reading

<span class="highlight"><i>|usr_07.txt|</i><span>  Editing more than one file
                <span class="highlight"><i>|07.1|</i><span>  Edit another file
                <span class="highlight"><i>|07.2|</i><span>  A list of files
                <span class="highlight"><i>|07.3|</i><span>  Jumping from file to file
                <span class="highlight"><i>|07.4|</i><span>  Backup files
                <span class="highlight"><i>|07.5|</i><span>  Copy text between files
                <span class="highlight"><i>|07.6|</i><span>  Viewing a file
                <span class="highlight"><i>|07.7|</i><span>  Changing the file name

<span class="highlight"><i>|usr_08.txt|</i><span>  Splitting windows
                <span class="highlight"><i>|08.1|</i><span>  Split a window
                <span class="highlight"><i>|08.2|</i><span>  Split a window on another file
                <span class="highlight"><i>|08.3|</i><span>  Window size
                <span class="highlight"><i>|08.4|</i><span>  Vertical splits
                <span class="highlight"><i>|08.5|</i><span>  Moving windows
                <span class="highlight"><i>|08.6|</i><span>  Commands for all windows
                <span class="highlight"><i>|08.7|</i><span>  Viewing differences with vimdiff
                <span class="highlight"><i>|08.8|</i><span>  Various

<span class="highlight"><i>|usr_09.txt|</i><span>  Using the GUI
                <span class="highlight"><i>|09.1|</i><span>  Parts of the GUI
                <span class="highlight"><i>|09.2|</i><span>  Using the mouse
                <span class="highlight"><i>|09.3|</i><span>  The clipboard
                <span class="highlight"><i>|09.4|</i><span>  Select mode

<span class="highlight"><i>|usr_10.txt|</i><span>  Making big changes
                <span class="highlight"><i>|10.1|</i><span>  Record and playback commands
                <span class="highlight"><i>|10.2|</i><span>  Substitution
                <span class="highlight"><i>|10.3|</i><span>  Command ranges
                <span class="highlight"><i>|10.4|</i><span>  The global command
                <span class="highlight"><i>|10.5|</i><span>  Visual block mode
                <span class="highlight"><i>|10.6|</i><span>  Reading and writing part of a file
                <span class="highlight"><i>|10.7|</i><span>  Formatting text
                <span class="highlight"><i>|10.8|</i><span>  Changing case
                <span class="highlight"><i>|10.9|</i><span>  Using an external program

<span class="highlight"><i>|usr_11.txt|</i><span>  Recovering from a crash
                <span class="highlight"><i>|11.1|</i><span>  Basic recovery
                <span class="highlight"><i>|11.2|</i><span>  Where is the swap file?
                <span class="highlight"><i>|11.3|</i><span>  Crashed or not?
                <span class="highlight"><i>|11.4|</i><span>  Further reading

<span class="highlight"><i>|usr_12.txt|</i><span>  Clever tricks
                <span class="highlight"><i>|12.1|</i><span>  Replace a word
                <span class="highlight"><i>|12.2|</i><span>  Change &quot;Last, First&quot; to &quot;First Last&quot;
                <span class="highlight"><i>|12.3|</i><span>  Sort a list
                <span class="highlight"><i>|12.4|</i><span>  Reverse line order
                <span class="highlight"><i>|12.5|</i><span>  Count words
                <span class="highlight"><i>|12.6|</i><span>  Find a man page
                <span class="highlight"><i>|12.7|</i><span>  Trim blanks
                <span class="highlight"><i>|12.8|</i><span>  Find where a word is used

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b>Editing Effectively </b><span><font color="#e5e5e5">~</font>

Subjects that can be read independently.

<span class="highlight"><i>|usr_20.txt|</i><span>  Typing command-line commands quickly
                <span class="highlight"><i>|20.1|</i><span>  Command line editing
                <span class="highlight"><i>|20.2|</i><span>  Command line abbreviations
                <span class="highlight"><i>|20.3|</i><span>  Command line completion
                <span class="highlight"><i>|20.4|</i><span>  Command line history
                <span class="highlight"><i>|20.5|</i><span>  Command line window

<span class="highlight"><i>|usr_21.txt|</i><span>  Go away and come back
                <span class="highlight"><i>|21.1|</i><span>  Suspend and resume
                <span class="highlight"><i>|21.2|</i><span>  Executing shell commands
                <span class="highlight"><i>|21.3|</i><span>  Remembering information; viminfo
                <span class="highlight"><i>|21.4|</i><span>  Sessions
                <span class="highlight"><i>|21.5|</i><span>  Views
                <span class="highlight"><i>|21.6|</i><span>  Modelines

<span class="highlight"><i>|usr_22.txt|</i><span>  Finding the file to edit
                <span class="highlight"><i>|22.1|</i><span>  The file explorer
                <span class="highlight"><i>|22.2|</i><span>  The current directory
                <span class="highlight"><i>|22.3|</i><span>  Finding a file
                <span class="highlight"><i>|22.4|</i><span>  The buffer list

<span class="highlight"><i>|usr_23.txt|</i><span>  Editing other files
                <span class="highlight"><i>|23.1|</i><span>  DOS, Mac and Unix files
                <span class="highlight"><i>|23.2|</i><span>  Files on the internet
                <span class="highlight"><i>|23.3|</i><span>  Encryption
                <span class="highlight"><i>|23.4|</i><span>  Binary files
                <span class="highlight"><i>|23.5|</i><span>  Compressed files

<span class="highlight"><i>|usr_24.txt|</i><span>  Inserting quickly
                <span class="highlight"><i>|24.1|</i><span>  Making corrections
                <span class="highlight"><i>|24.2|</i><span>  Showing matches
                <span class="highlight"><i>|24.3|</i><span>  Completion
                <span class="highlight"><i>|24.4|</i><span>  Repeating an insert
                <span class="highlight"><i>|24.5|</i><span>  Copying from another line
                <span class="highlight"><i>|24.6|</i><span>  Inserting a register
                <span class="highlight"><i>|24.7|</i><span>  Abbreviations
                <span class="highlight"><i>|24.8|</i><span>  Entering special characters
                <span class="highlight"><i>|24.9|</i><span>  Digraphs
                <span class="highlight"><i>|24.10|</i><span> Normal mode commands

<span class="highlight"><i>|usr_25.txt|</i><span>  Editing formatted text
                <span class="highlight"><i>|25.1|</i><span>  Breaking lines
                <span class="highlight"><i>|25.2|</i><span>  Aligning text
                <span class="highlight"><i>|25.3|</i><span>  Indents and tabs
                <span class="highlight"><i>|25.4|</i><span>  Dealing with long lines
                <span class="highlight"><i>|25.5|</i><span>  Editing tables

<span class="highlight"><i>|usr_26.txt|</i><span>  Repeating
                <span class="highlight"><i>|26.1|</i><span>  Repeating with Visual mode
                <span class="highlight"><i>|26.2|</i><span>  Add and subtract
                <span class="highlight"><i>|26.3|</i><span>  Making a change in many files
                <span class="highlight"><i>|26.4|</i><span>  Using Vim from a shell script

<span class="highlight"><i>|usr_27.txt|</i><span>  Search commands and patterns
                <span class="highlight"><i>|27.1|</i><span>  Ignoring case
                <span class="highlight"><i>|27.2|</i><span>  Wrapping around the file end
                <span class="highlight"><i>|27.3|</i><span>  Offsets
                <span class="highlight"><i>|27.4|</i><span>  Matching multiple times
                <span class="highlight"><i>|27.5|</i><span>  Alternatives
                <span class="highlight"><i>|27.6|</i><span>  Character ranges
                <span class="highlight"><i>|27.7|</i><span>  Character classes
                <span class="highlight"><i>|27.8|</i><span>  Matching a line break
                <span class="highlight"><i>|27.9|</i><span>  Examples

<span class="highlight"><i>|usr_28.txt|</i><span>  Folding
                <span class="highlight"><i>|28.1|</i><span>  What is folding?
                <span class="highlight"><i>|28.2|</i><span>  Manual folding
                <span class="highlight"><i>|28.3|</i><span>  Working with folds
                <span class="highlight"><i>|28.4|</i><span>  Saving and restoring folds
                <span class="highlight"><i>|28.5|</i><span>  Folding by indent
                <span class="highlight"><i>|28.6|</i><span>  Folding with markers
                <span class="highlight"><i>|28.7|</i><span>  Folding by syntax
                <span class="highlight"><i>|28.8|</i><span>  Folding by expression
                <span class="highlight"><i>|28.9|</i><span>  Folding unchanged lines
                <span class="highlight"><i>|28.10|</i><span> Which fold method to use?

<span class="highlight"><i>|usr_29.txt|</i><span>  Moving through programs
                <span class="highlight"><i>|29.1|</i><span>  Using tags
                <span class="highlight"><i>|29.2|</i><span>  The preview window
                <span class="highlight"><i>|29.3|</i><span>  Moving through a program
                <span class="highlight"><i>|29.4|</i><span>  Finding global identifiers
                <span class="highlight"><i>|29.5|</i><span>  Finding local identifiers

<span class="highlight"><i>|usr_30.txt|</i><span>  Editing programs
                <span class="highlight"><i>|30.1|</i><span>  Compiling
                <span class="highlight"><i>|30.2|</i><span>  Indenting C files
                <span class="highlight"><i>|30.3|</i><span>  Automatic indenting
                <span class="highlight"><i>|30.4|</i><span>  Other indenting
                <span class="highlight"><i>|30.5|</i><span>  Tabs and spaces
                <span class="highlight"><i>|30.6|</i><span>  Formatting comments

<span class="highlight"><i>|usr_31.txt|</i><span>  Exploiting the GUI
                <span class="highlight"><i>|31.1|</i><span>  The file browser
                <span class="highlight"><i>|31.2|</i><span>  Confirmation
                <span class="highlight"><i>|31.3|</i><span>  Menu shortcuts
                <span class="highlight"><i>|31.4|</i><span>  Vim window position and size
                <span class="highlight"><i>|31.5|</i><span>  Various

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b>Tuning Vim </b><span><font color="#e5e5e5">~</font>

Make Vim work as you like it.

<span class="highlight"><i>|usr_40.txt|</i><span>  Make new commands
                <span class="highlight"><i>|40.1|</i><span>  Key mapping
                <span class="highlight"><i>|40.2|</i><span>  Defining command-line commands
                <span class="highlight"><i>|40.3|</i><span>  Autocommands

<span class="highlight"><i>|usr_41.txt|</i><span>  Write a Vim script
                <span class="highlight"><i>|41.1|</i><span>  Introduction
                <span class="highlight"><i>|41.2|</i><span>  Variables
                <span class="highlight"><i>|41.3|</i><span>  Expressions
                <span class="highlight"><i>|41.4|</i><span>  Conditionals
                <span class="highlight"><i>|41.5|</i><span>  Executing an expression
                <span class="highlight"><i>|41.6|</i><span>  Using functions
                <span class="highlight"><i>|41.7|</i><span>  Defining a function
                <span class="highlight"><i>|41.8|</i><span>  Various remarks
                <span class="highlight"><i>|41.9|</i><span>  Writing a plugin
                <span class="highlight"><i>|41.10|</i><span> Writing a filetype plugin
                <span class="highlight"><i>|41.11|</i><span> Writing a compiler plugin

<span class="highlight"><i>|usr_42.txt|</i><span>  Add new menus
                <span class="highlight"><i>|42.1|</i><span>  Introduction
                <span class="highlight"><i>|42.2|</i><span>  Menu commands
                <span class="highlight"><i>|42.3|</i><span>  Various
                <span class="highlight"><i>|42.4|</i><span>  Toolbar and popup menus

<span class="highlight"><i>|usr_43.txt|</i><span>  Using filetypes
                <span class="highlight"><i>|43.1|</i><span>  Plugins for a filetype
                <span class="highlight"><i>|43.2|</i><span>  Adding a filetype

<span class="highlight"><i>|usr_44.txt|</i><span>  Your own syntax highlighted
                <span class="highlight"><i>|44.1|</i><span>  Basic syntax commands
                <span class="highlight"><i>|44.2|</i><span>  Keywords
                <span class="highlight"><i>|44.3|</i><span>  Matches
                <span class="highlight"><i>|44.4|</i><span>  Regions
                <span class="highlight"><i>|44.5|</i><span>  Nested items
                <span class="highlight"><i>|44.6|</i><span>  Following groups
                <span class="highlight"><i>|44.7|</i><span>  Other arguments
                <span class="highlight"><i>|44.8|</i><span>  Clusters
                <span class="highlight"><i>|44.9|</i><span>  Including another syntax file
                <span class="highlight"><i>|44.10|</i><span> Synchronizing
                <span class="highlight"><i>|44.11|</i><span> Installing a syntax file
                <span class="highlight"><i>|44.12|</i><span> Portable syntax file layout

<span class="highlight"><i>|usr_45.txt|</i><span>  Select your language
                <span class="highlight"><i>|45.1|</i><span>  Language for Messages
                <span class="highlight"><i>|45.2|</i><span>  Language for Menus
                <span class="highlight"><i>|45.3|</i><span>  Using another encoding
                <span class="highlight"><i>|45.4|</i><span>  Editing files with a different encoding
                <span class="highlight"><i>|45.5|</i><span>  Entering language text

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b>Making Vim Run </b><span><font color="#e5e5e5">~</font>

Before you can use Vim.

<span class="highlight"><i>|usr_90.txt|</i><span>  Installing Vim
                <span class="highlight"><i>|90.1|</i><span>  Unix
                <span class="highlight"><i>|90.2|</i><span>  MS-Windows
                <span class="highlight"><i>|90.3|</i><span>  Upgrading
                <span class="highlight"><i>|90.4|</i><span>  Common installation issues
                <span class="highlight"><i>|90.5|</i><span>  Uninstalling Vim

<span class="highlight"><b>==============================================================================</b><span>

<span class="highlight"><b><i>*usr_01.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2002 Jan 15


                              About the manuals


This chapter introduces the manuals available with Vim.  Read this to know the
conditions under which the commands are explained.

<span class="highlight"><i>|01.1|</i><span>  Two manuals
<span class="highlight"><i>|01.2|</i><span>  Vim installed
<span class="highlight"><i>|01.3|</i><span>  Using the Vim tutor
<span class="highlight"><i>|01.4|</i><span>  Copyright


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*01.1*</i></b><span>  Two manuals

The Vim documentation consists of two parts:

1. The User manual
   Task oriented explanations, from simple to complex.  Reads from start to
   end like a book.

2. The Reference manual
   Precise description of how everything in Vim works.

The notation used in these manuals is explained here: <span class="highlight"><i>|notation|</i><span>


JUMPING AROUND

The text contains hyperlinks between the two parts, allowing you to quickly
jump between the description of an editing task and a precise explanation of
the commands and options used for it.  Use these two commands:

        Press  <span class="highlight"><i>CTRL-]</i><span>  to jump to a subject under the cursor.
        Press  <span class="highlight"><i>CTRL-O</i><span>  to jump back (repeat to go further back).

Many links are in vertical bars, like this: <span class="highlight"><i>|bars|</i><span>.  An option name, like
<span class="highlight"><i>'number'</i><span>, a command in double quotes like &quot;:write&quot; and any other word can also
be used as a link.  Try it out: Move the cursor to  <span class="highlight"><i>CTRL-]</i></font></span>  and press <span class="highlight"><i>CTRL-]</i><span>
on it.

Other subjects can be found with the &quot;:help&quot; command, see <span class="highlight"><i>|help.txt|</i><span>.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*01.2*</i></b><span>  Vim installed

Most of the manuals assume that Vim has been properly installed.  If you
didn't do that yet, or if Vim doesn't run properly (e.g., files can't be found
or in the GUI the menus do not show up) first read the chapter on
installation: <span class="highlight"><i>|usr_90.txt|</i><span>.
<span class="highlight"><b>                                                        </b></font></span><span class="highlight"><b><i>*not-compatible*</i></b><span>
The manuals often assume you are using Vim with Vi-compatibility switched
off.  For most commands this doesn't matter, but sometimes it is important,
e.g., for multi-level undo.  An easy way to make sure you are using the right
setup, copy the example vimrc file.  By doing this inside Vim you don't have
to check out where it is located.  How to do this depends on the system you
are using:

Unix:<font color="#e5e5e5"> &gt;</font>
<span class="highlight"><b>        :!cp -i $VIMRUNTIME/vimrc_example.vim ~/.vimrc</b><span>
MS-DOS, MS-Windows, OS/2:<font color="#e5e5e5"> &gt;</font>
<span class="highlight"><b>        :!copy $VIMRUNTIME/vimrc_example.vim $VIM/_vimrc</b><span>
Amiga:<font color="#e5e5e5"> &gt;</font>
<span class="highlight"><b>        :!copy $VIMRUNTIME/vimrc_example.vim $VIM/.vimrc</b><span>

If the file already exists you probably want to keep it.

If you start Vim now, the <span class="highlight"><i>'compatible'</i><span> option should be off.  You can check it
with this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set compatible?</b><span>

If it responds with &quot;nocompatible&quot; you are doing well.  If the response is
&quot;compatible&quot; you are in trouble.  You will have to find out why the option is
still set.  Perhaps the file you wrote above is not found.  Use this command
to find out:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :scriptnames</b><span>

If your file is not in the list, check its location and name.  If it is in the
list, there must be some other place where the <span class="highlight"><i>'compatible'</i><span> option is switched
back on.

For more info see <span class="highlight"><i>|vimrc|</i></font></span> and <span class="highlight"><i>|compatible-default|</i><span>.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        This manual is about using Vim in the normal way.  There is an
        alternative called &quot;evim&quot; (easy Vim).  This is still Vim, but used in
        a way that resembles a click-and-type editor like Notepad.  It always
        stays in Insert mode, thus it feels very different.  It is not
        explained in the user manual, since it should be mostly self
        explanatory.  See <span class="highlight"><i>|evim-keys|</i><span> for details.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*01.3*</i></b></font></span>  Using the Vim tutor                             <span class="highlight"><b><i>*tutor*</i></b><span> <span class="highlight"><b><i>*vimtutor*</i></b><span>

Instead of reading the text (boring!) you can use the vimtutor to learn your
first Vim commands.  This is a 30 minute tutorial that teaches the most basic
Vim functionality hands-on.

On Unix and MS-Windows, if Vim has been properly installed, you can start it
from the shell:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        vimtutor</b><span>

This will make a copy of the tutor file, so that you can edit it without
the risk of damaging the original.
   There are a few translated versions of the tutor.  To find out if yours is
available, use the two-letter language code.  For French:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        vimtutor fr</b><span>

On non-Unix systems, you have to do a little work:

1. Copy the tutor file.  You can do this with Vim (it knows where to find it):
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        vim -u NONE -c 'e $VIMRUNTIME/tutor/tutor' -c 'w! TUTORCOPY' -c 'q'</b><span>
<font color="#e5e5e5">&lt;</font>
   This will write the file &quot;TUTORCOPY&quot; in the current directory.  To use a
translated version of the tutor, append the two-letter language code to the
filename.  For French:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        vim -u NONE -c 'e $VIMRUNTIME/tutor/tutor.fr' -c 'w! TUTORCOPY' -c 'q'</b><span>
<font color="#e5e5e5">&lt;</font>
2. Edit the copied file with Vim:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        vim -u NONE -c &quot;set nocp&quot; TUTORCOPY</b><span>
<font color="#e5e5e5">&lt;</font>
   The extra arguments make sure Vim is started in a good mood.

3. Delete the copied file when you are finished with it:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        del TUTORCOPY</b><span>
<font color="#e5e5e5">&lt;</font>
<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*01.4*</i></b></font></span>  Copyright                                       <span class="highlight"><b><i>*manual-copyright*</i></b><span>

The Vim user manual and reference manual are Copyright (c) 1988-2002 by Bram
Moolenaar. This material may be distributed only subject to the terms and
conditions set forth in the Open Publication License, v1.0 or later.  The
latest version is presently available at:
             http://www.opencontent.org/openpub/

People who contribute to the manuals must agree with the above copyright
notice.
<span class="highlight"><b>                                                        </b></font></span><span class="highlight"><b><i>*frombook*</i></b><span>
Parts of the user manual come from the book &quot;Vi IMproved - Vim&quot; by Steve
Oualline (published by New Riders Publishing, ISBN: 0735710015).  The Open
Publication License applies to this book.  Only selected parts are included
and these have been modified (e.g., by removing the pictures, updating the
text for Vim 6.0 and fixing mistakes).  The omission of the <span class="highlight"><i>|frombook|</i><span> tag
does not mean that the text does not come from the book.

Many thanks to Steve Oualline and New Riders for creating this book and
publishing it under the OPL!  It has been a great help while writing the user
manual.  Not only by providing literal text, but also by setting the tone and
style.

If you make money through selling the manuals, you are strongly encouraged to
donate part of the profit to help AIDS victims in Uganda.  See <span class="highlight"><i>|iccf|</i><span>.

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_02.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2001 Sep 03


                            The first steps in Vim


This chapter provides just enough information to edit a file with Vim.  Not
well or fast, but you can edit.  Take some time to practice with these
commands, they form the base for what follows.

<span class="highlight"><i>|02.1|</i><span>  Running Vim for the First Time
<span class="highlight"><i>|02.2|</i><span>  Inserting text
<span class="highlight"><i>|02.3|</i><span>  Moving around
<span class="highlight"><i>|02.4|</i><span>  Deleting characters
<span class="highlight"><i>|02.5|</i><span>  Undo and Redo
<span class="highlight"><i>|02.6|</i><span>  Other editing commands
<span class="highlight"><i>|02.7|</i><span>  Getting out
<span class="highlight"><i>|02.8|</i><span>  Finding help


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*02.1*</i></b><span>  Running Vim for the First Time

To start Vim, enter this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        gvim file.txt</b><span>

In UNIX you can type this at any command prompt.  If you are running Microsoft
Windows, open an MS-DOS prompt window and enter the command.
   In either case, Vim starts editing a file called file.txt.  Because this
is a new file, you get a blank window. This is what your screen will look
like:

        +---------------------------------------+
        |#                                      |
        |~                                      |
        |~                                      |
        |~                                      |
        |~                                      |
        |&quot;file.txt&quot; [New file]                  |
        +---------------------------------------+
                ('#&quot; is the cursor position.)

The tilde (~) lines indicate lines not in the file.  In other words, when Vim
runs out of file to display, it displays tilde lines.  At the bottom of the
screen, a message line indicates the file is named file.txt and shows that you
are creating a new file.  The message information is temporary and other
information overwrites it.


THE VIM COMMAND

The gvim command causes the editor to create a new window for editing.  If you
use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        vim file.txt</b><span>

the editing occurs inside your command window.  In other words, if you are
running inside an xterm, the editor uses your xterm window.  If you are using
an MS-DOS command prompt window under Microsoft Windows, the editing occurs
inside this window.  The text in the window will look the same for both
versions, but with gvim you have extra features, like a menu bar.  More about
that later.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*02.2*</i></b><span>  Inserting text

The Vim editor is a modal editor.  That means that the editor behaves
differently, depending on which mode you are in.  The two basic modes are
called Normal mode and Insert mode.  In Normal mode the characters you type
are commands.  In Insert mode the characters are inserted as text.
   Since you have just started Vim it will be in Normal mode.  To start Insert
mode you type the &quot;i&quot; command (i for Insert).  Then you can enter
the text.  It will be inserted into the file.  Do not worry if you make
mistakes; you can correct them later.  To enter the following programmer's
limerick, this is what you type:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        iA very intelligent turtle</b><span>
<span class="highlight"><b>        Found programming UNIX a hurdle</b><span>

After typing &quot;turtle&quot; you press the <span class="highlight"><i>&lt;Enter&gt;</i><span> key to start a new line.  Finally
you press the <span class="highlight"><i>&lt;Esc&gt;</i><span> key to stop Insert mode and go back to Normal mode.  You
now have two lines of text in your Vim window:

        +---------------------------------------+
        |A very intelligent turtle              |
        |Found programming UNIX a hurdle        |
        |~                                      |
        |~                                      |
        |                                       |
        +---------------------------------------+


WHAT IS THE MODE?

To be able to see what mode you are in, type this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set showmode</b><span>

You will notice that when typing the colon Vim moves the cursor to the last
line of the window.  That's where you type colon commands (commands that start
with a colon).  Finish this command by pressing the <span class="highlight"><i>&lt;Enter&gt;</i><span> key (all commands
that start with a colon are finished this way).
   Now, if you type the &quot;i&quot; command Vim will display --INSERT-- at the bottom
of the window.  This indicates you are in Insert mode.

        +---------------------------------------+
        |A very intelligent turtle              |
        |Found programming UNIX a hurdle        |
        |~                                      |
        |~                                      |
        |-- INSERT --                           |
        +---------------------------------------+

If you press <span class="highlight"><i>&lt;Esc&gt;</i><span> to go back to Normal mode the last line will be made blank.


GETTING OUT OF TROUBLE

One of the problems for Vim novices is mode confusion, which is caused by
forgetting which mode you are in or by accidentally typing a command that
switches modes.  To get back to Normal mode, no matter what mode you are in,
press the <span class="highlight"><i>&lt;Esc&gt;</i><span> key.  Sometimes you have to press it twice.  If Vim beeps back
at you, you already are in Normal mode.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*02.3*</i></b><span>  Moving around

After you return to command mode, you can move around by using these keys:

        h   left
        j   down
        k   up
        l   right

At first, it may appear that these commands were chosen at random.  After all,
who ever heard of using l for right?  But actually, there is a very good
reason for these choices: Moving the cursor is the most common thing you do in
an editor, and these keys are on the home row of your right hand.  In other
words, these commands are placed where you can type them the fastest
(especially when you type with ten fingers).

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        You can also move the cursor by using the arrow keys.  If you do,
        however, you greatly slow down your editing because to press the arrow
        keys, you must move your hand from the text keys to the arrow keys.
        Considering that you might be doing it hundreds of times an hour, this
        can take a significant amount of time.
           Also, there are keyboards which do not have arrow keys, or which
        locate them in unusual places; therefore, knowing the use of the hjkl
        keys helps in those situations.

One way to remember these commands is that h is on the left, l is on the
right and j points down.  In a picture:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>                       k</b><span>
<span class="highlight"><b>                   h     l</b><span>
<span class="highlight"><b>                     j</b><span>

The best way to learn these commands is by using them.  Use the &quot;i&quot; command to
insert some more lines of text.  Then use the hjkl keys to move around and
insert a word somewhere.  Don't forget to press <span class="highlight"><i>&lt;Esc&gt;</i><span> to go back to Normal
mode.  The <span class="highlight"><i>|vimtutor|</i><span> is also a nice way to learn by doing.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*02.4*</i></b><span>  Deleting characters

To delete a character, move the cursor over it and type &quot;x&quot;.  (This is a
throwback to the old days of the typewriter, when you deleted things by typing
xxxx over them.)  Move the cursor to the beginning of the first line, for
example, and type xxxxxxx (seven x's) to delete &quot;A very &quot;.  The result should
look like this:

        +---------------------------------------+
        |intelligent turtle                     |
        |Found programming UNIX a hurdle        |
        |~                                      |
        |~                                      |
        |                                       |
        +---------------------------------------+

Now you can insert new text, for example by typing:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        iA young &lt;Esc&gt;</b><span>

This begins an insert (the i), inserts the words &quot;A young&quot;, and then exits
insert mode (the final <span class="highlight"><i>&lt;Esc&gt;</i><span>).  The result:

        +---------------------------------------+
        |A young intelligent turtle             |
        |Found programming UNIX a hurdle        |
        |~                                      |
        |~                                      |
        |                                       |
        +---------------------------------------+


DELETING A LINE

To delete a whole line use the &quot;dd&quot; command.  The following line will
then move up to fill the gap:

        +---------------------------------------+
        |Found programming UNIX a hurdle        |
        |~                                      |
        |~                                      |
        |~                                      |
        |                                       |
        +---------------------------------------+


DELETING A LINE BREAK

In Vim you can join two lines together, which means that the line break
between them is deleted.  The &quot;J&quot; command does this.
   Take these two lines:

<span class="highlight"><b>        A young intelligent </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        turtle </b><span><font color="#e5e5e5">~</font>

Move the cursor to the first line and press &quot;J&quot;:

<span class="highlight"><b>        A young intelligent turtle </b><span><font color="#e5e5e5">~</font>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*02.5*</i></b><span>  Undo and Redo

Suppose you delete too much.  Well, you can type it in again, but an easier
way exists.  The &quot;u&quot; command undoes the last edit.  Take a look at this in
action: After using &quot;dd&quot; to delete the first line, &quot;u&quot; brings it back.
   Another one: Move the cursor to the A in the first line:

<span class="highlight"><b>        A young intelligent turtle </b><span><font color="#e5e5e5">~</font>

Now type xxxxxxx to delete &quot;A young&quot;.  The result is as follows:

<span class="highlight"><b>         intelligent turtle </b><span><font color="#e5e5e5">~</font>

Type &quot;u&quot; to undo the last delete.  That delete removed the g, so the undo
restores the character.

<span class="highlight"><b>        g intelligent turtle </b><span><font color="#e5e5e5">~</font>

The next u command restores the next-to-last character deleted:

<span class="highlight"><b>        ng intelligent turtle </b><span><font color="#e5e5e5">~</font>

The next u command gives you the u, and so on:

<span class="highlight"><b>        ung intelligent turtle </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        oung intelligent turtle </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        young intelligent turtle </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>         young intelligent turtle </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        A young intelligent turtle </b><span><font color="#e5e5e5">~</font>

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        If you type &quot;u&quot; twice, and the result is that you get the same text
        back, you have Vim configured to work Vi compatible.  Look here to fix
        this: <span class="highlight"><i>|not-compatible|</i><span>.
           This text assumes you work &quot;The Vim Way&quot;.  You might prefer to use
        the good old Vi way, but you will have to watch out for small
        differences in the text then.


REDO

If you undo too many times, you can press <span class="highlight"><i>CTRL-R</i><span> (redo) to reverse the
preceding command.  In other words, it undoes the undo.  To see this in
action, press <span class="highlight"><i>CTRL-R</i><span> twice.  The character A and the space after it disappear:

<span class="highlight"><b>        young intelligent turtle </b><span><font color="#e5e5e5">~</font>

There's a special version of the undo command, the &quot;U&quot; (undo line) command.
The undo line command undoes all the changes made on the last line that was
edited.  Typing this command twice cancels the preceding &quot;U&quot;.

<span class="highlight"><b>        A very intelligent turtle </b><span><font color="#e5e5e5">~</font>
          xxxx                          Delete very

<span class="highlight"><b>        A intelligent turtle </b><span><font color="#e5e5e5">~</font>
                      xxxxxx            Delete turtle

<span class="highlight"><b>        A intelligent </b><span><font color="#e5e5e5">~</font>
                                        Restore line with &quot;U&quot;
<span class="highlight"><b>        A very intelligent turtle </b><span><font color="#e5e5e5">~</font>
                                        Undo &quot;U&quot; with &quot;u&quot;
<span class="highlight"><b>        A intelligent </b><span><font color="#e5e5e5">~</font>

The &quot;U&quot; command is a change by itself, which the &quot;u&quot; command undoes and <span class="highlight"><i>CTRL-R</i><span>
redoes.  This might be a bit confusing.  Don't worry, with &quot;u&quot; and <span class="highlight"><i>CTRL-R</i><span> you
can go to any of the situations you had.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*02.6*</i></b><span>  Other editing commands

Vim has a large number of commands to change the text.  See <span class="highlight"><i>|Q_in|</i><span> and below.
Here are a few often used ones.


APPENDING

The &quot;i&quot; command inserts a character before the character under the cursor.
That works fine; but what happens if you want to add stuff to the end of the
line?  For that you need to insert text after the cursor.  This is done with
the &quot;a&quot; (append) command.
   For example, to change the line

<span class="highlight"><b>        and that's not saying much for the turtle. </b><span><font color="#e5e5e5">~</font>
to
<span class="highlight"><b>        and that's not saying much for the turtle!!! </b><span><font color="#e5e5e5">~</font>

move the cursor over to the dot at the end of the line. Then type &quot;x&quot; to
delete the period.  The cursor is now positioned at the end of the line on the
e in turtle.  Now type<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        a!!!&lt;Esc&gt;</b><span>

to append three exclamation points after the e in turtle:

<span class="highlight"><b>        and that's not saying much for the turtle!!! </b><span><font color="#e5e5e5">~</font>


OPENING UP A NEW LINE

The &quot;o&quot; command creates a new, empty line below the cursor and puts Vim in
Insert mode.  Then you can type the text for the new line.
   Suppose the cursor is somewhere in the first of these two lines:

<span class="highlight"><b>        A very intelligent turtle </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        Found programming UNIX a hurdle </b><span><font color="#e5e5e5">~</font>

If you now use the &quot;o&quot; command and type new text:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        oThat liked using Vim&lt;Esc&gt;</b><span>

The result is:

<span class="highlight"><b>        A very intelligent turtle </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        That liked using Vim </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        Found programming UNIX a hurdle </b><span><font color="#e5e5e5">~</font>

The &quot;O&quot; command (uppercase) opens a line above the cursor.


USING A COUNT

Suppose you want to move up nine lines.  You can type &quot;kkkkkkkkk&quot; or you can
enter the command &quot;9k&quot;.  In fact, you can precede many commands with a number.
Earlier in this chapter, for instance, you added three exclamation points to
the end of a line by typing &quot;a!!!<span class="highlight"><i>&lt;Esc&gt;</i><span>&quot;.  Another way to do this is to use the
command &quot;3a!<span class="highlight"><i>&lt;Esc&gt;</i><span>&quot;.  The count of 3 tells the command that follows to triple
its effect.  Similarly, to delete three characters, use the command &quot;3x&quot;.  The
count always comes before the command it applies to.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*02.7*</i></b><span>  Getting out

To exit, use the &quot;ZZ&quot; command.  This command writes the file and exits.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        Unlike many other editors, Vim does not automatically make a backup
        file.  If you type &quot;ZZ&quot;, your changes are committed and there's no
        turning back.  You can configure the Vim editor to produce backup
        files, see <span class="highlight"><i>|07.4|</i><span>.


DISCARDING CHANGES

Sometimes you will make a sequence of changes and suddenly realize you were
better off before you started.  Not to worry; Vim has a
quit-and-throw-things-away command.  It is:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :q!</b><span>

Don't forget to press <span class="highlight"><i>&lt;Enter&gt;</i><span> to finish the command.

For those of you interested in the details, the three parts of this command
are the colon (:), which enters command mode; the q command, which tells the
editor to quit; and the override command modifier (!).
   The override command modifier is needed because Vim is reluctant to throw
away changes.  If you were to just type &quot;:q&quot;, Vim would display an error
message and refuse to exit:

<span class="highlight"><b>        E37: No write since last change (use ! to override) </b><span><font color="#e5e5e5">~</font>

By specifying the override, you are in effect telling Vim, &quot;I know that what
I'm doing looks stupid, but I'm a big boy and really want to do this.&quot;

If you want to continue editing with Vim: The &quot;:e!&quot; command reloads the
original version of the file.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*02.8*</i></b><span>  Finding help

Everything you always wanted to know can be found in the Vim help files.
Don't be afraid to ask!
   To get generic help use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :help</b><span>

You could also use the first function key <span class="highlight"><i>&lt;F1&gt;</i></font></span>.  If your keyboard has a <span class="highlight"><i>&lt;Help&gt;</i><span>
key it might work as well.
   If you don't supply a subject, &quot;:help&quot; displays the general help window.
The creators of Vim did something very clever (or very lazy) with the help
system: They made the help window a normal editing window.  You can use all
the normal Vim commands to move through the help information.  Therefore h, j,
k, and l move left, down, up and right.
   To get out of the help window, use the same command you use to get out of
the editor: &quot;ZZ&quot;.  This will only close the help window, not exit Vim.

As you read the help text, you will notice some text enclosed in vertical bars
(for example, <span class="highlight"><i>|help|</i><span>).  This indicates a hyperlink.  If you position the
cursor anywhere between the bars and press <span class="highlight"><i>CTRL-]</i><span> (jump to tag), the help
system takes you to the indicated subject. (For reasons not discussed here,
the Vim terminology for a hyperlink is tag.  So <span class="highlight"><i>CTRL-]</i><span> jumps to the location
of the tag given by the word under the cursor.)
   After a few jumps, you might want to go back.  <span class="highlight"><i>CTRL-T</i><span> (pop tag) takes you
back to the preceding position.  <span class="highlight"><i>CTRL-O</i><span> (jump to older position) also works
nicely here.
   At the top of the help screen, there is the notation *help.txt*.  This name
between &quot;*&quot; characters is used by the help system to define a tag (hyperlink
destination).
   See <span class="highlight"><i>|29.1|</i><span> for details about using tags.

To get help on a given subject, use the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :help {subject}</b><span>

To get help on the &quot;x&quot; command, for example, enter the following:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :help x</b><span>

To find out how to delete text, use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :help deleting</b><span>

To get a complete index of all Vim commands, use the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :help index</b><span>

When you need to get help for a control character command (for example,
<span class="highlight"><i>CTRL-A</i></font></span>), you need to spell it with the prefix &quot;<span class="highlight"><i>CTRL-&quot;</i><span>.<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :help CTRL-A</b><span>

The Vim editor has many different modes.  By default, the help system displays
the normal-mode commands.  For example, the following command displays help
for the normal-mode <span class="highlight"><i>CTRL-H</i><span> command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :help CTRL-H</b><span>

To identify other modes, use a mode prefix.  If you want the help for the
insert-mode version of a command, use &quot;i_&quot;.  For <span class="highlight"><i>CTRL-H</i><span> this gives you the
following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :help i_CTRL-H</b><span>

When you start the Vim editor, you can use several command-line arguments.
These all begin with a dash (-).  To find what the -t argument does, for
example, use the command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :help -t</b><span>

The Vim editor has a number of options that enable you to configure and
customize the editor.  If you want help for an option, you need to enclose it
in single quotation marks.  To find out what the <span class="highlight"><i>'number'</i><span> option does, for
example, use the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :help 'number'</b><span>

The table with all mode prefixes can be found here: <span class="highlight"><i>|help-context|</i><span>.

Special keys are enclosed in angle brackets. To find help on the up-arrow key
in Insert mode, for instance, use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :help i_&lt;Up&gt;</b><span>

If you see an error message that you don't understand, for example:

<span class="highlight"><b>        E37: No write since last change (use ! to override) </b><span><font color="#e5e5e5">~</font>

You can use the error ID at the start to find help about it:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :help E37</b><span>

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_03.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2002 Jan 31


                             Moving around


Before you can insert or delete text the cursor has to be moved to the right
place.  Vim has a large number of commands to position the cursor.  This
chapter shows you how to use the most important ones.  You can find a list of
these commands below <span class="highlight"><i>|Q_lr|</i><span>.

<span class="highlight"><i>|03.1|</i><span>  Word movement
<span class="highlight"><i>|03.2|</i><span>  Moving to the start or end of a line
<span class="highlight"><i>|03.3|</i><span>  Moving to a character
<span class="highlight"><i>|03.4|</i><span>  Matching a paren
<span class="highlight"><i>|03.5|</i><span>  Moving to a specific line
<span class="highlight"><i>|03.6|</i><span>  Telling where you are
<span class="highlight"><i>|03.7|</i><span>  Scrolling around
<span class="highlight"><i>|03.8|</i><span>  Simple searches
<span class="highlight"><i>|03.9|</i><span>  Simple search patterns
<span class="highlight"><i>|03.10|</i><span> Using marks


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*03.1*</i></b><span>  Word movement

To move the cursor forward one word, use the &quot;w&quot; command.  Like most Vim
commands, you can use a numeric prefix to move past multiple words.  For
example, &quot;3w&quot; moves three words.  This figure shows how it works:

<span class="highlight"><b>        This is a line with example text </b><span><font color="#e5e5e5">~</font>
          ---&gt;--&gt;-&gt;-----------------&gt;
           w  w  w    3w

Notice that &quot;w&quot; moves to the start of the next word if it already is at the
start of a word.
   The &quot;b&quot; command moves backward to the start of the previous word:

<span class="highlight"><b>        This is a line with example text </b><span><font color="#e5e5e5">~</font>
        &lt;----&lt;--&lt;-&lt;---------&lt;---
           b   b b    2b      b

There is also the &quot;e&quot; command that moves to the next end of a word and &quot;ge&quot;,
which moves to the previous end of a word:

<span class="highlight"><b>        This is a line with example text </b><span><font color="#e5e5e5">~</font>
           &lt;-   &lt;--- -----&gt;   ----&gt;
           ge    ge     e       e

If you are at the last word of a line, the &quot;w&quot; command will take you to the
first word in the next line.  Thus you can use this to move through a
paragraph, much faster than using &quot;l&quot;.  &quot;b&quot; does the same in the other
direction.

A word ends at a non-word character, such as a &quot;.&quot;, &quot;-&quot; or &quot;)&quot;.  To change
what Vim considers to be a word, see the <span class="highlight"><i>'iskeyword'</i><span> option.
   It is also possible to move by white-space separated WORDs.  This is not a
word in the normal sense, that's why the uppercase is used.  The commands for
moving by WORDs are also uppercase, as this figure shows:

               ge      b          w                             e
               &lt;-     &lt;-         ---&gt;                          ---&gt;
<span class="highlight"><b>        This is-a line, with special/separated/words (and some more). </b><span><font color="#e5e5e5">~</font>
           &lt;----- &lt;-----         --------------------&gt;         -----&gt;
             gE      B                   W                       E

With this mix of lowercase and uppercase commands, you can quickly move
forward and backward through a paragraph.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*03.2*</i></b><span>  Moving to the start or end of a line

The &quot;$&quot; command moves the cursor to the end of a line.  If your keyboard has
an <span class="highlight"><i>&lt;End&gt;</i><span> key it will do the same thing.

The &quot;^&quot; command moves to the first nonblank character of the line.  The &quot;0&quot;
command (zero) moves to the very first character of the line.  The <span class="highlight"><i>&lt;Home&gt;</i><span> key
does the same thing.  In a picture:

                  ^
             &lt;------------
<span class="highlight"><b>        .....This is a line with example text </b><span><font color="#e5e5e5">~</font>
        &lt;-----------------   ---------------&gt;
                0                  $

(the &quot;.....&quot; indicates blanks here)

   The &quot;$&quot; command takes a count, like most movement commands.  But moving to
the end of the line several times doesn't make sense.  Therefore it causes the
editor to move to the end of another line.  For example, &quot;1$&quot; moves you to
the end of the first line (the one you're on), &quot;2$&quot; to the end of the next
line, and so on.
   The &quot;0&quot; command doesn't take a count argument, because the &quot;0&quot; would be
part of the count.  Unexpectedly, using a count with &quot;^&quot; doesn't have any
effect.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*03.3*</i></b><span>  Moving to a character

One of the most useful movement commands is the single-character search
command.  The command &quot;fx&quot; searches forward in the line for the single
character x.  Hint: &quot;f&quot; stands for &quot;Find&quot;.
   For example, you are at the beginning of the following line.  Suppose you
want to go to the h of human.  Just execute the command &quot;fh&quot; and the cursor
will be positioned over the h:

<span class="highlight"><b>        To err is human.  To really foul up you need a computer. </b><span><font color="#e5e5e5">~</font>
        ----------&gt;---------------&gt;
            fh           fy

This also shows that the command &quot;fy&quot; moves to the end of the word really.
   You can specify a count; therefore, you can go to the &quot;l&quot; of &quot;foul&quot; with
&quot;3fl&quot;:

<span class="highlight"><b>        To err is human.  To really foul up you need a computer. </b><span><font color="#e5e5e5">~</font>
                  ---------------------&gt;
                           3fl

The &quot;F&quot; command searches to the left:

<span class="highlight"><b>        To err is human.  To really foul up you need a computer. </b><span><font color="#e5e5e5">~</font>
                  &lt;---------------------
                            Fh

The &quot;tx&quot; command works like the &quot;fx&quot; command, except it stops one character
before the searched character.  Hint: &quot;t&quot; stands for &quot;To&quot;.  The backward
version of this command is &quot;Tx&quot;.

<span class="highlight"><b>        To err is human.  To really foul up you need a computer. </b><span><font color="#e5e5e5">~</font>
                   &lt;------------  -------------&gt;
                        Th              tn

These four commands can be repeated with &quot;;&quot;.  &quot;,&quot; repeats in the other
direction.  The cursor is never moved to another line.  Not even when the
sentence continues.

Sometimes you will start a search, only to realize that you have typed the
wrong command.  You type &quot;f&quot; to search backward, for example, only to realize
that you really meant &quot;F&quot;.  To abort a search, press <span class="highlight"><i>&lt;Esc&gt;</i></font></span>.  So &quot;f<span class="highlight"><i>&lt;Esc&gt;</i><span>&quot; is an
aborted forward search and doesn't do anything.  <span class="highlight"><b><i><u>Note</u></i></b></font></span>: <span class="highlight"><i>&lt;Esc&gt;</i><span> cancels most
operations, not just searches.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*03.4*</i></b><span>  Matching a paren

When writing a program you often end up with nested () constructs.  Then the
&quot;%&quot; command is very handy: It moves to the matching paren.  If the cursor is
on a &quot;(&quot; it will move to the matching &quot;)&quot;.  If it's on a &quot;)&quot; it will move to
the matching &quot;(&quot;.

                            %
                         &lt;-----&gt;
<span class="highlight"><b>                if (a == (b * c) / d) </b><span><font color="#e5e5e5">~</font>
                   &lt;----------------&gt;
                            %

This also works for [] and {} pairs.  (This can be defined with the
<span class="highlight"><i>'matchpairs'</i><span> option.)

When the cursor is not on a useful character, &quot;%&quot; will search forward to find
one.  Thus if the cursor is at the start of the line of the previous example,
&quot;%&quot; will search forward and find the first &quot;(&quot;.  Then it moves to its match:

<span class="highlight"><b>                if (a == (b * c) / d) </b><span><font color="#e5e5e5">~</font>
                ---+----------------&gt;
                           %

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*03.5*</i></b><span>  Moving to a specific line

If you are a C or C++ programmer, you are familiar with error messages such as
the following:

<span class="highlight"><b>        prog.c:33: j   undeclared (first use in this function) </b><span><font color="#e5e5e5">~</font>

This tells you that you might want to fix something on line 33.  So how do you
find line 33?  One way is to do &quot;9999k&quot; to go to the top of the file and &quot;32j&quot;
to go down thirtytwo lines.  It is not a good way, but it works.  A much
better way of doing things is to use the &quot;G&quot; command.  With a count, this
command positions you at the given line number.  For example, &quot;33G&quot; puts you
on line 33.  (For a better way of going through a compiler's error list, see
<span class="highlight"><i>|usr_30.txt|</i><span>, for information on the :make command.)
   With no argument, &quot;G&quot; positions you at the end of the file.  A quick way to
go to the start of a file use &quot;gg&quot;.  &quot;1G&quot; will do the same, but is a tiny bit
more typing.

            |   first line of a file   ^
            |   text text text text    |
            |   text text text text    |  gg
        7G  |   text text text text    |
            |   text text text text
            |   text text text text
            V   text text text text    |
                text text text text    |  G
                text text text text    |
                last line of a file    V

Another way to move to a line is using the &quot;%&quot; command with a count.  For
example &quot;50%&quot; moves you to halfway the file.  &quot;90%&quot; goes to near the end.

The previous assumes that you want to move to a line in the file, no matter if
it's currently visible or not.  What if you want to move to one of the lines
you can see?  This figure shows the three commands you can use:

                        +---------------------------+
                H --&gt;   | text sample text          |
                        | sample text               |
                        | text sample text          |
                        | sample text               |
                M --&gt;   | text sample text          |
                        | sample text               |
                        | text sample text          |
                        | sample text               |
                L --&gt;   | text sample text          |
                        +---------------------------+

Hints: &quot;H&quot; stands for Home, &quot;M&quot; for Middle and &quot;L&quot; for Last.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*03.6*</i></b><span>  Telling where you are

To see where you are in a file, there are three ways:

1.  Use the <span class="highlight"><i>CTRL-G</i></font></span> command.  You get a message like this (assuming the <span class="highlight"><i>'ruler'</i><span>
    option is off):

<span class="highlight"><b>        &quot;usr_03.txt&quot; line 233 of 650 --35%-- col 45-52</b><span><font color="#e5e5e5">~</font>

    This shows the name of the file you are editing, the line number where the
    cursor is, the total number of lines, the percentage of the way through
    the file and the column of the cursor.
       Sometimes you will see a split column number.  For example, &quot;col 2-9&quot;.
    This indicates that the cursor is positioned on the second character, but
    because character one is a tab, occupying eight spaces worth of columns,
    the screen column is 9.

2.  Set the <span class="highlight"><i>'number'</i><span> option.  This will display a line number in front of
    every line:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set number</b><span>
<font color="#e5e5e5">&lt;</font>
    To switch this off again:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set nonumber</b><span>
<font color="#e5e5e5">&lt;</font>
    Since <span class="highlight"><i>'number'</i><span> is a boolean option, prepending &quot;no&quot; to its name has the
    effect of switching it off.  A boolean option has only these two values,
    it is either on or off.
       Vim has many options.  Besides the boolean ones there are options with
    a numerical value and string options.  You will see examples of this where
    they are used.

3.  Set the <span class="highlight"><i>'ruler'</i><span> option.  This will display the cursor position in the
    lower right corner of the Vim window:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set ruler</b><span>

Using the <span class="highlight"><i>'ruler'</i><span> option has the advantage that it doesn't take much room,
thus there is more space for your text.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*03.7*</i></b><span>  Scrolling around

The <span class="highlight"><i>CTRL-U</i><span> command scrolls down half a screen of text.  Think of looking
through a viewing window at the text and moving this window up by half the
height of the window.  Thus the window moves up over the text, which is
backward in the file.  Don't worry if you have a little trouble remembering
which end is up.  Most users have the same problem.
   The <span class="highlight"><i>CTRL-D</i><span> command moves the viewing window down half a screen in the file,
thus scrolls the text up half a screen.

                                       +----------------+
                                       | some text      |
                                       | some text      |
                                       | some text      |
        +---------------+              | some text      |
        | some text     |  <span class="highlight"><i>CTRL-U</i><span>  --&gt; |                |
        |               |              | 123456         |
        | 123456        |              +----------------+
        | 7890          |
        |               |              +----------------+
        | example       |  <span class="highlight"><i>CTRL-D</i><span> --&gt;  | 7890           |
        +---------------+              |                |
                                       | example        |
                                       | example        |
                                       | example        |
                                       | example        |
                                       +----------------+

To scroll one line at a time use <span class="highlight"><i>CTRL-E</i></font></span> (scroll up) and <span class="highlight"><i>CTRL-Y</i><span> (scroll down).
Think of <span class="highlight"><i>CTRL-E</i><span> to give you one line Extra.  (If you use MS-Windows compatible
key mappings <span class="highlight"><i>CTRL-Y</i><span> will redo a change instead of scroll.)

To scroll forward by a whole screen (except for two lines) use <span class="highlight"><i>CTRL-F</i><span>.  The
other way is backward, <span class="highlight"><i>CTRL-B</i></font></span> is the command to use.  Fortunately <span class="highlight"><i>CTRL-F</i><span> is
Forward and <span class="highlight"><i>CTRL-B</i><span> is Backward, that's easy to remember.

A common issue is that after moving down many lines with &quot;j&quot; your cursor is at
the bottom of the screen.  You would like to see the context of the line with
the cursor.  That's done with the &quot;zz&quot; command.

        +------------------+             +------------------+
        | some text        |             | some text        |
        | some text        |             | some text        |
        | some text        |             | some text        |
        | some text        |   zz  --&gt;   | line with cursor |
        | some text        |             | some text        |
        | some text        |             | some text        |
        | line with cursor |             | some text        |
        +------------------+             +------------------+

The &quot;zt&quot; command puts the cursor line at the top, &quot;zb&quot; at the bottom.  There
are a few more scrolling commands, see <span class="highlight"><i>|Q_sc|</i><span>.  To always keep a few lines of
context around the cursor, use the <span class="highlight"><i>'scrolloff'</i><span> option.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*03.8*</i></b><span>  Simple searches

To search for a string, use the &quot;/string&quot; command.  To find the word include,
for example, use the command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /include</b><span>

You will notice that when you type the &quot;/&quot; the cursor jumps to the last line
of the Vim window, like with colon commands.  That is where you type the word.
You can press the backspace key (backarrow or <span class="highlight"><i>&lt;BS&gt;</i><span>) to make corrections.  Use
the <span class="highlight"><i>&lt;Left&gt;</i></font></span> and <span class="highlight"><i>&lt;Right&gt;</i><span> cursor keys when necessary.
   Pressing <span class="highlight"><i>&lt;Enter&gt;</i><span> executes the command.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        The characters .*[]^%/\?~$ have special meaning. If you want to use
        them in a search you must put a \ in front of them.  See below.

To find the next occurrence of the same string use the &quot;n&quot; command.  Use this
to find the first #include after the cursor:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /#include</b><span>

And then type &quot;n&quot; several times.  You will move to each #include in the text.
You can also use a count if you know which match you want.  Thus &quot;3n&quot; finds
the third match.  Using a count with &quot;/&quot; doesn't work.

The &quot;?&quot; command works like &quot;/&quot; but searches backwards:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        ?word</b><span>

The &quot;<span class="highlight"><i>N</i><span>&quot; command repeats the last search the opposite direction.  Thus using
&quot;<span class="highlight"><i>N</i></font></span>&quot; after a &quot;/&quot; command search backwards, using &quot;<span class="highlight"><i>N</i><span>&quot; after &quot;?&quot; searches
forward.


IGNORING CASE

Normally you have to type exactly what you want to find.  If you don't care
about upper or lowercase in a word, set the <span class="highlight"><i>'ignorecase'</i><span> option:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set ignorecase</b><span>

If you now search for &quot;word&quot;, it will also match &quot;Word&quot; and &quot;WORD&quot;.  To match
case again:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set noignorecase</b><span>


HISTORY

Suppose you do three searches:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /one</b><span>
<span class="highlight"><b>        /two</b><span>
<span class="highlight"><b>        /three</b><span>

Now let's start searching by typing a simple &quot;/&quot; without pressing <span class="highlight"><i>&lt;Enter&gt;</i><span>.  If
you press <span class="highlight"><i>&lt;Up&gt;</i><span> (the cursor key), Vim puts &quot;/three&quot; on the command line.
Pressing <span class="highlight"><i>&lt;Enter&gt;</i><span> at this point searches for three.  If you do not press
<span class="highlight"><i>&lt;Enter&gt;</i></font></span>, but press <span class="highlight"><i>&lt;Up&gt;</i><span> instead, Vim changes the prompt to &quot;/two&quot;.  Another
press of <span class="highlight"><i>&lt;Up&gt;</i><span> moves you to &quot;/one&quot;.
   You can also use the <span class="highlight"><i>&lt;Down&gt;</i><span> cursor key to move through the history of
search commands in the other direction.

If you know what a previously used pattern starts with, and you want to use it
again, type that character before pressing <span class="highlight"><i>&lt;Up&gt;</i><span>.  With the previous example,
you can type &quot;/o<span class="highlight"><i>&lt;Up&gt;</i><span>&quot; and Vim will put &quot;/one&quot; on the command line.

The commands starting with &quot;:&quot; also have a history.  That allows you to recall
a previous command and execute it again.  These two histories are separate.


SEARCHING FOR A WORD IN THE TEXT

Suppose you see the word &quot;TheLongFunctionName&quot; in the text and you want to
find the next occurrence of it.  You could type &quot;/TheLongFunctionName&quot;, but
that's a lot of typing.  And when you make a mistake Vim won't find it.
   There is an easier way: Position the cursor on the word and use the &quot;*&quot;
command.  Vim will grab the word under the cursor and use it as the search
string.
   The &quot;#&quot; command does the same in the other direction.  You can prepend a
count: &quot;3*&quot; searches for the third occurrence of the word under the cursor.


SEARCHING FOR WHOLE WORDS

If you type &quot;/the&quot; it will also match &quot;there&quot;.  To only find words that end
in &quot;the&quot; use:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /the\&gt;</b><span>

The &quot;\&gt;&quot; item is a special marker that only matches at the end of a word.
Similarly &quot;\&lt;&quot; only matches at the begin of a word.  Thus to search for the
word &quot;the&quot; only:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /\&lt;the\&gt;</b><span>

This does not match &quot;there&quot; or &quot;soothe&quot;.  Notice that the &quot;*&quot; and &quot;#&quot; commands
use these start-of-word and end-of-word markers to only find whole words (you
can use &quot;g*&quot; and &quot;g#&quot; to match partial words).


HIGHLIGHTING MATCHES

While editing a program you see a variable called &quot;nr&quot;.  You want to check
where it's used.  You could move the cursor to &quot;nr&quot; and use the &quot;*&quot; command
and press &quot;n&quot; to go along all the matches.
   There is another way.  Type this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set hlsearch</b><span>

If you now search for &quot;nr&quot;, Vim will highlight all matches.  That is a very
good way to see where the variable is used, without the need to type commands.
   To switch this off:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set nohlsearch</b><span>

Then you need to switch it on again if you want to use it for the next search
command.  If you only want to remove the highlighting, use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :nohlsearch</b><span>

This doesn't reset the option.  Instead, it disables the highlighting.  As
soon as you execute a search command, the highlighting will be used again.
Also for the &quot;n&quot; and &quot;<span class="highlight"><i>N</i><span>&quot; commands.


TUNING SEARCHES

There are a few options that change how searching works.  These are the
essential ones:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        :set incsearch</b><span>

This makes Vim display the match for the string while you are still typing it.
Use this to check if the right match will be found.  Then press <span class="highlight"><i>&lt;Enter&gt;</i><span> to
really jump to that location.  Or type more to change the search string.
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        :set nowrapscan</b><span>

This stops the search at the end of the file.  Or, when you are searching
backwards, at the start of the file.  The <span class="highlight"><i>'wrapscan'</i><span> option is on by default,
thus searching wraps around the end of the file.


INTERMEZZO

If you like one of the options mentioned before, and set it each time you use
Vim, you can put the command in your Vim startup file.
   Edit the file, as mentioned at <span class="highlight"><i>|not-compatible|</i><span>.  Or use this command to
find out where it is:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :scriptnames</b><span>

Edit the file, for example with:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :edit ~/.vimrc</b><span>

Then add a line with the command to set the option, just like you typed it in
Vim.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        Go:set hlsearch&lt;Esc&gt;</b><span>

&quot;G&quot; moves to the end of the file.  &quot;o&quot; starts a new line, where you type the
&quot;:set&quot; command.  You end insert mode with <span class="highlight"><i>&lt;Esc&gt;</i><span>.  Then write the file:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        ZZ</b><span>

If you now start Vim again, the <span class="highlight"><i>'hlsearch'</i><span> option will already be set.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*03.9*</i></b><span>  Simple search patterns

The Vim editor uses regular expressions to specify what to search for.
Regular expressions are an extremely powerful and compact way to specify a
search pattern.  Unfortunately, this power comes at a price, because regular
expressions are a bit tricky to specify.
   In this section we mention only a few essential ones.  More about search
patterns and commands in chapter 27 <span class="highlight"><i>|usr_27.txt|</i><span>.  You can find the full
explanation here: <span class="highlight"><i>|pattern|</i><span>.


BEGINNING AND END OF A LINE

The ^ character matches the beginning of a line.  On an English-US keyboard
you find it above the 6.  The pattern &quot;include&quot; matches the word include
anywhere on the line.  But the pattern &quot;^include&quot; matches the word include
only if it is at the beginning of a line.
   The $ character matches the end of a line.  Therefore, &quot;was$&quot; matches the
word was only if it is at the end of a line.

Let's mark the places where &quot;the&quot; matches in this example line with &quot;x&quot;s:

<span class="highlight"><b>        the solder holding one of the chips melted and the </b><span><font color="#e5e5e5">~</font>
        xxx                       xxx                  xxx

Using &quot;/the$&quot; we find this match:

<span class="highlight"><b>        the solder holding one of the chips melted and the </b><span><font color="#e5e5e5">~</font>
                                                       xxx

And with &quot;/^the&quot; we find this one:
<span class="highlight"><b>        the solder holding one of the chips melted and the </b><span><font color="#e5e5e5">~</font>
        xxx

You can try searching with &quot;/^the$&quot;, it will only match a single line
consisting of &quot;the&quot;.  White space does matter here, thus if a line contains a
space after the word, like &quot;the &quot;, the pattern will not match.


MATCHING ANY SINGLE CHARACTER

The . (dot) character matches any existing character.  For example, the
pattern &quot;c.m&quot; matches a string whose first character is a c, whose second
character is anything, and whose the third character is m.  Example:

<span class="highlight"><b>        We use a computer that became the cummin winter. </b><span><font color="#e5e5e5">~</font>
                 xxx             xxx      xxx


MATCHING SPECIAL CHARACTERS

If you really want to match a dot, you must avoid its special meaning by
putting a backslash before it.
   If you search for &quot;ter.&quot;, you will find these matches:

<span class="highlight"><b>        We use a computer that became the cummin winter. </b><span><font color="#e5e5e5">~</font>
                      xxxx                          xxxx

Searching for &quot;ter\.&quot; only finds the second match.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*03.10*</i></b><span> Using marks

When you make a jump to a position with the &quot;G&quot; command, Vim remembers the
position from before this jump.  This position is called a mark.  To go back
where you came from, use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        ``</b><span>
This ` is a backtick or open single-quote character.
   If you use the same command a second time you will jump back again.  That's
because the ` command is a jump itself, and the position from before this jump
is remembered.

Generally, every time you do a command that can move the cursor further than
within the same line, this is called a jump.  This includes the search
commands &quot;/&quot; and &quot;n&quot; (it doesn't matter how far away the match is).  But not
the character searches with &quot;fx&quot; and &quot;tx&quot; or the word movements &quot;w&quot; and &quot;e&quot;.
   Also, &quot;j&quot; and &quot;k&quot; are not considered to be a jump.  Even when you use a
count to make them move the cursor quite a long way away.

The `` command jumps back and forth, between two points.  The <span class="highlight"><i>CTRL-O</i><span> command
jumps to older positions (Hint: O for older).  <span class="highlight"><i>CTRL-I</i><span> then jumps back to newer
positions (Hint: I is just next to O on the keyboard).  Consider this sequence
of commands:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        33G</b><span>
<span class="highlight"><b>        /^The</b><span>
<span class="highlight"><b>        CTRL-O</b><span>

You first jump to line 33, then search for a line that starts with &quot;The&quot;.
Then with <span class="highlight"><i>CTRL-O</i></font></span> you jump back to line 33.  Another <span class="highlight"><i>CTRL-O</i><span> takes you back to
where you started.  If you now use <span class="highlight"><i>CTRL-I</i><span> you jump to line 33 again.  And
to the match for &quot;The&quot; with another <span class="highlight"><i>CTRL-I</i><span>.


             |  example text   ^             |
        33G  |  example text   |  <span class="highlight"><i>CTRL-O</i></font></span>     | <span class="highlight"><i>CTRL-I</i><span>
             |  example text   |             |
             V  line 33 text   ^             V
             |  example text   |             |
       /^The |  example text   |  <span class="highlight"><i>CTRL-O</i></font></span>     | <span class="highlight"><i>CTRL-I</i><span>
             V  There you are  |             V
                example text

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        <span class="highlight"><i>CTRL-I</i></font></span> is the same as <span class="highlight"><i>&lt;Tab&gt;</i><span>.

The &quot;:jumps&quot; command gives a list of positions you jumped to.  The entry which
you used last is marked with a &quot;&gt;&quot;.


NAMED MARKS

Vim enables you to place your own marks in the text.  The command &quot;ma&quot; marks
the place under the cursor as mark a.  You can place 26 marks (a through z) in
your text.  You can't see them, it's just a position that Vim remembers.
   To go to a mark, use the command `<span class="highlight"><i>{mark}</i></font></span>, where &quot;<span class="highlight"><i>{mark}</i><span> is the mark letter.
Thus to move to the a mark:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        `a</b><span>

The command 'mark (single quotation mark, or apostrophe) moves you to the
beginning of the line containing the mark.  This differs from the `mark
command, which moves you to marked column.

The marks can be very useful when working on two related parts in a file.
Suppose you have some text near the start of the file you need to look at,
while working on some text near the end of the file.
   Move to the text at the start and place the s (start) mark there:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        ms</b><span>

The move to the text you want to work on and put the e (end) mark there:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        me</b><span>

Now you can move around, and when you want to look at the start of the file,
you use this to jump there:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        's</b><span>

Then you can use '' to jump back to where you were, or 'e to jump to the text
you were working on at the end.
   There is nothing special about using s for start and e for end, they are
just easy to remember.

You can use this command to get a list of marks:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :marks</b><span>

You will notice a few special marks.  These include:

        '       The cursor position before doing a jump
        &quot;       The cursor position when last editing the file
        [       Start of the last change
        ]       End of the last change

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_04.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2002 Jan 07


                             Making small changes


This chapter shows you several ways of making corrections and moving text
around.  It teaches you the three basic ways to change text: operator-motion,
Visual mode and text objects.

<span class="highlight"><i>|04.1|</i><span>  Operators and motions
<span class="highlight"><i>|04.2|</i><span>  Changing text
<span class="highlight"><i>|04.3|</i><span>  Repeating a change
<span class="highlight"><i>|04.4|</i><span>  Visual mode
<span class="highlight"><i>|04.5|</i><span>  Moving text
<span class="highlight"><i>|04.6|</i><span>  Copying text
<span class="highlight"><i>|04.7|</i><span>  Using the clipboard
<span class="highlight"><i>|04.8|</i><span>  Text objects
<span class="highlight"><i>|04.9|</i><span>  Replace mode
<span class="highlight"><i>|04.10|</i><span> Conclusion


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*04.1*</i></b><span>  Operators and motions

In chapter 2 you learned the &quot;x&quot; command to delete a single character.  And
using a count: &quot;4x&quot; deletes four characters.
   The &quot;dw&quot; command deletes a word.  You may recognize the &quot;w&quot; command as the
move word command.  In fact, the &quot;d&quot; command may be followed by any motion
command, and it deletes from the current location to the place where the
cursor winds up.
   The &quot;4w&quot; command, for example, moves the cursor over four words.  The d4w
command deletes four words.

<span class="highlight"><b>        To err is human. To really foul up you need a computer. </b><span><font color="#e5e5e5">~</font>
                         ------------------&gt;
                                 d4w

<span class="highlight"><b>        To err is human. you need a computer. </b><span><font color="#e5e5e5">~</font>

Vim only deletes up to the position where the motion takes the cursor.  That's
because Vim knows that you probably don't want to delete the first character
of a word.  If you use the &quot;e&quot; command to move to the end of a word, Vim
guesses that you do want to include that last character:

<span class="highlight"><b>        To err is human. you need a computer. </b><span><font color="#e5e5e5">~</font>
                        --------&gt;
                           d2e

<span class="highlight"><b>        To err is human. a computer. </b><span><font color="#e5e5e5">~</font>

Whether the character under the cursor is included depends on the command you
used to move to that character.  The reference manual calls this &quot;exclusive&quot;
when the character isn't included and &quot;inclusive&quot; when it is.

The &quot;$&quot; command moves to the end of a line.  The &quot;d$&quot; command deletes from the
cursor to the end of the line.  This is an inclusive motion, thus the last
character of the line is included in the delete operation:

<span class="highlight"><b>        To err is human. a computer. </b><span><font color="#e5e5e5">~</font>
                       ------------&gt;
                            d$

<span class="highlight"><b>        To err is human </b><span><font color="#e5e5e5">~</font>

There is a pattern here: operator-motion.  You first type an operator command.
For example, &quot;d&quot; is the delete operator.  Then you type a motion command like
&quot;4l&quot; or &quot;w&quot;.  This way you can operate on any text you can move over.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*04.2*</i></b><span>  Changing text

Another operator is &quot;c&quot;, change.  It acts just like the &quot;d&quot; operator, except
it leaves you in Insert mode.  For example, &quot;cw&quot; changes a word.  Or more
specifically, it deletes a word and then puts you in Insert mode.

<span class="highlight"><b>        To err is human </b><span><font color="#e5e5e5">~</font>
           -------&gt;
             c2wbe<span class="highlight"><i>&lt;Esc&gt;</i><span>

<span class="highlight"><b>        To be human </b><span><font color="#e5e5e5">~</font>

This &quot;c2wbe<span class="highlight"><i>&lt;Esc&gt;</i><span>&quot; contains these bits:

        c       the change operator
        2w      move two words (they are deleted and Insert mode started)
        be      insert this text
        <span class="highlight"><i>&lt;Esc&gt;</i><span>   back to Normal mode

If you have paid attention, you will have noticed something strange: The space
before &quot;human&quot; isn't deleted.  There is a saying that for every problem there
is an answer that is simple, clear, and wrong.  That is the case with the
example used here for the &quot;cw&quot; command.  The c operator works just like the
d operator, with one exception: &quot;cw&quot;.  It actually works like &quot;ce&quot;, change to
end of word.  Thus the space after the word isn't included.  This is an
exception that dates back to the old Vi.  Since many people are used to it
now, the inconsistency has remained in Vim.


MORE CHANGES

Like &quot;dd&quot; deletes a whole line, &quot;cc&quot; changes a whole line.  It keeps the
existing indent (leading white space) though.

Just like &quot;d$&quot; deletes until the end of the line, &quot;c$&quot; changes until the end
of the line.  It's like doing &quot;d$&quot; to delete the text and then &quot;a&quot; to start
Insert mode and append new text.


SHORTCUTS

Some operator-motion commands are used so often that they have been given a
single letter command:

        x  stands for  dl  (delete character under the cursor)
        X  stands for  dh  (delete character left of the cursor)
        D  stands for  d$  (delete to end of the line)
        C  stands for  c$  (change to end of the line)
        s  stands for  cl  (change one character)
        S  stands for  cc  (change a whole line)


WHERE TO PUT THE COUNT

The commands &quot;3dw&quot; and &quot;d3w&quot; delete three words.  If you want to get really
picky about things, the first command, &quot;3dw&quot;, deletes one word three times;
the command &quot;d3w&quot; deletes three words once.  This is a difference without a
distinction.  You can actually put in two counts, however.  For example,
&quot;3d2w&quot; deletes two words, repeated three times, for a total of six words.


REPLACING WITH ONE CHARACTER

The &quot;r&quot; command is not an operator.  It waits for you to type a character, and
will replace the character under the cursor with it.  You could do the same
with &quot;cl&quot; or with the &quot;s&quot; command, but with &quot;r&quot; you don't have to press <span class="highlight"><i>&lt;Esc&gt;</i><span>

<span class="highlight"><b>        there is somerhing grong here </b><span><font color="#e5e5e5">~</font>
        rT           rt    rw

<span class="highlight"><b>        There is something wrong here </b><span><font color="#e5e5e5">~</font>

Using a count with &quot;r&quot; causes that many characters to be replaced with the
same character.  Example:

<span class="highlight"><b>        There is something wrong here </b><span><font color="#e5e5e5">~</font>
                           5rx

<span class="highlight"><b>        There is something xxxxx here </b><span><font color="#e5e5e5">~</font>

To replace a character with a line break use &quot;r<span class="highlight"><i>&lt;Enter&gt;</i><span>&quot;.  This deletes one
character and inserts a line break.  Using a count here only applies to the
number of characters deleted: &quot;4r<span class="highlight"><i>&lt;Enter&gt;</i><span>&quot; replaces four characters with one
line break.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*04.3*</i></b><span>  Repeating a change

The &quot;.&quot; command is one of the most simple yet powerful commands in Vim.  It
repeats the last change.  For instance, suppose you are editing an HTML file
and want to delete all the <span class="highlight"><i>&lt;B&gt;</i><span> tags.  You position the cursor on the first &lt;
and delete the <span class="highlight"><i>&lt;B&gt;</i><span> with the command &quot;df&gt;&quot;.  You then go to the &lt; of the next
&lt;/B&gt; and kill it using the &quot;.&quot; command.  The &quot;.&quot; command executes the last
change command (in this case, &quot;df&gt;&quot;).  To delete another tag, position the
cursor on the &lt; and use the &quot;.&quot; command.

<span class="highlight"><b>                              To &lt;B&gt;generate&lt;/B&gt; a table of &lt;B&gt;contents </b><span><font color="#e5e5e5">~</font>
        f&lt;   find first &lt;     ---&gt;
        df&gt;  delete to &gt;         --&gt;
        f&lt;   find next &lt;           ---------&gt;
        .    repeat df&gt;                     ---&gt;
        f&lt;   find next &lt;                       -------------&gt;
        .    repeat df&gt;                                     --&gt;

The &quot;.&quot; command works for all changes you make, except for the &quot;u&quot; (undo),
<span class="highlight"><i>CTRL-R</i><span> (redo) and commands that start with a colon (:).

Another example: You want to change the word &quot;four&quot; to &quot;five&quot;.  It appears
several times in your text.  You can do this quickly with this sequence of
commands:

        /four<span class="highlight"><i>&lt;Enter&gt;</i><span>    find the first string &quot;four&quot;
        cwfive<span class="highlight"><i>&lt;Esc&gt;</i><span>     change the word to &quot;five&quot;
        n               find the next &quot;four&quot;
        .               repeat the change to &quot;five'
        n               find the next &quot;four&quot;
        .               repeat the change
                        etc.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*04.4*</i></b><span>  Visual mode

To delete simple items the operator-motion changes work quite well.  But often
it's not so easy to decide which command will move over the text you want to
change.  Then you can use Visual mode.

You start Visual mode by pressing &quot;v&quot;.  You move the cursor over the text you
want to work on.  While you do this, the text is highlighted.  Finally type
the operator command.
   For example, to delete from halfway one word to halfway another word:

<span class="highlight"><b>                This is an examination sample of visual mode </b><span><font color="#e5e5e5">~</font>
                               ----------&gt;
                                 velllld

<span class="highlight"><b>                This is an example of visual mode </b><span><font color="#e5e5e5">~</font>

When doing this you don't really have to count how many times you have to
press &quot;l&quot; to end up in the right position.  You can immediately see what text
will be deleted when you press &quot;d&quot;.

If at any time you decide you don't want to do anything with the highlighted
text, just press <span class="highlight"><i>&lt;Esc&gt;</i><span> and Visual mode will stop without doing anything.


SELECTING LINES

If you want to work on whole lines, use &quot;V&quot; to start Visual mode.  You will
see right away that the whole line is highlighted, without moving around.
When you move left or right nothing changes.  When you move up or down the
selection is extended whole lines at a time.
   For example, select three lines with &quot;Vjj&quot;:

                          +------------------------+
                          | text more text         |
                       &gt;&gt; | more text more text    | |
        selected lines &gt;&gt; | text text text         | | Vjj
                       &gt;&gt; | text more              | V
                          | more text more         |
                          +------------------------+


SELECTING BLOCKS

If you want to work on a rectangular block of characters, use <span class="highlight"><i>CTRL-V</i><span> to start
Visual mode.  This is very useful when working on tables.

                name            Q1      Q2      Q3
                pierre          123     455     234
                john            0       90      39
                steve           392     63      334

To delete the middle &quot;Q2&quot; column, move the cursor to the &quot;Q&quot; of &quot;Q2&quot;.  Press
<span class="highlight"><i>CTRL-V</i><span> to start blockwise Visual mode.  Now move the cursor three lines down
with &quot;3j&quot; and to the next word with &quot;w&quot;.  You can see the first character of
the last column is included.  To exclude it, use &quot;h&quot;.  Now press &quot;d&quot; and the
middle column is gone.


GOING TO THE OTHER SIDE

If you have selected some text in Visual mode, and discover that you need to
change the other end of the selection, use the &quot;o&quot; command (Hint: o for other
end).  The cursor will go to the other end, and you can move the cursor to
change where the selection starts.  Pressing &quot;o&quot; again brings you back to the
other end.

When using blockwise selection, you have four corners.  &quot;o&quot; only takes you to
one of the other corners, diagonally.  Use &quot;O&quot; to move to the other corner in
the same line.

<span class="highlight"><b><i><u>Note</u></i></b><span> that &quot;o&quot; and &quot;O&quot; in Visual mode work very different from Normal mode,
where they open a new line below or above the cursor.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*04.5*</i></b><span>  Moving text

When you delete something with the &quot;d&quot;, &quot;x&quot;, or another command, the text is
saved.  You can paste it back by using the p command. (The Vim name for
this is put).
   Take a look at how this works.  First you will delete an entire line, by
putting the cursor on the line you want to delete and typing &quot;dd&quot;.  Now you
move the cursor to where you want to put the line and use the &quot;p&quot; (put)
command.  The line is inserted on the line below the cursor.

        a line          a line        a line
        line 2    dd    line 3    p   line 3
        line 3                        line 2

Because you deleted an entire line, the &quot;p&quot; command placed the text line below
the cursor.  If you delete part of a line (a word, for instance), the &quot;p&quot;
command puts it just after the cursor.

<span class="highlight"><b>        Some more boring try text to out commands. </b><span><font color="#e5e5e5">~</font>
                         ----&gt;
                          dw

<span class="highlight"><b>        Some more boring text to out commands. </b><span><font color="#e5e5e5">~</font>
                         --------&gt;
                            welp

<span class="highlight"><b>        Some more boring text to try out commands. </b><span><font color="#e5e5e5">~</font>


MORE ON PUTTING

The &quot;P&quot; command puts text like &quot;p&quot;, but before the cursor.  When you deleted a
whole line with &quot;dd&quot;, &quot;P&quot; will put it back above the cursor.  When you deleted
a word with &quot;dw&quot;, &quot;P&quot; will put it back just before the cursor.

You can repeat putting as many times as you like.  The same text will be used.

You can use a count with &quot;p&quot; and &quot;P&quot;.  The text will be repeated as many times
as specified with the count.  Thus &quot;dd&quot; and then &quot;3p&quot; puts three copies of the
same deleted line.


SWAPPING TWO CHARACTERS

Frequently when you are typing, your fingers get ahead of your brain (or the
other way around?).  The result is a typo such as &quot;teh&quot; for &quot;the&quot;.  Vim
makes it easy to correct such problems.  Just put the cursor on the e of &quot;teh&quot;
and execute the command &quot;xp&quot;.  This works as follows: &quot;x&quot; deletes the
character e and places it in a register.  &quot;p&quot; puts the text after the cursor,
which is after the h.

<span class="highlight"><b>        teh     th     the</b><span><font color="#e5e5e5">~</font>
         x       p

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*04.6*</i></b><span>  Copying text

To copy text from one place to another, you could delete it, use &quot;u&quot; to undo
the deletion and then &quot;p&quot; to put it somewhere else.  There is an easier way:
yanking.  The &quot;y&quot; operator copies text into a register.  Then a &quot;p&quot; command
can be used to put it.
   Yanking is just a Vim name for copying.  The &quot;c&quot; letter was already used
for the change operator, and &quot;y&quot; was still available.  Calling this
operator &quot;yank&quot; made it easier to remember to use the &quot;y&quot; key.

Since &quot;y&quot; is an operator, you use &quot;yw&quot; to yank a word.  A count is possible as
usual.  To yank two workds use &quot;y2w&quot;.  Example:

<span class="highlight"><b>        let sqr = LongVariable * </b><span><font color="#e5e5e5">~</font>
                 --------------&gt;
                       y2w

<span class="highlight"><b>        let sqr = LongVariable * </b><span><font color="#e5e5e5">~</font>
                               p

<span class="highlight"><b>        let sqr = LongVariable * LongVariable </b><span><font color="#e5e5e5">~</font>

Notice that &quot;yw&quot; includes the white space after a word.  If you don't want
this, use &quot;ye&quot;.

The &quot;yy&quot; command yanks a whole line, just like &quot;dd&quot; deletes a whole line.
Unexpectedly, while &quot;D&quot; deletes from the cursor to the end of the line, &quot;Y&quot;
works like &quot;yy&quot;, it yanks the whole line.  Watch out for this inconsistency!
Use &quot;y$&quot; to yank to the end of the line.

        a text line   yy        a text line            a text line
        line 2                  line 2          p      line 2
        last line               last line              a text line
                                                       last line

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*04.7*</i></b><span>  Using the clipboard

If you are using the GUI version of Vim (gvim), you can find the &quot;Copy&quot; item
in the &quot;Edit&quot; menu.  First select some text with Visual mode, then use the
Edit/Copy menu.  The selected text is now copied to the clipboard.  You can
paste the text in other programs.  In Vim itself too.

If you have copied text to the clipboard in another application, you can paste
it in Vim with the Edit/Paste menu.  This works in Normal mode and Insert
mode.  In Visual mode the selected text is replaced with the pasted text.

The &quot;Cut&quot; menu item deletes the text before it's put on the clipboard.  The
&quot;Copy&quot;, &quot;Cut&quot; and &quot;Paste&quot; items are also available in the popup menu (only
when there is a popup menu, of course).  If your Vim has a toolbar, you can
also find these items there.

If you are not using the GUI, or if you don't like using a menu, you have to
use another way.  You use the normal &quot;y&quot; (yank) and &quot;p&quot; (put) commands, but
prepend &quot;* (double-quote star) before it.  To copy a line to the clipboard:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        &quot;*yy</b><span>

To put text from the clipboard back into the text:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        &quot;*p</b><span>

This only works on versions of Vim that include clipboard support.  More about
the clipboard in section <span class="highlight"><i>|09.3|</i></font></span> and here: <span class="highlight"><i>|clipboard|</i><span>.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*04.8*</i></b><span>  Text objects

If the cursor is in the middle of a word and want to delete that word, you
need to move back to its start before you can do &quot;dw&quot;.  There is a simpler way
to do this: &quot;daw&quot;.

<span class="highlight"><b>        this is some example text. </b><span><font color="#e5e5e5">~</font>
                       daw

<span class="highlight"><b>        this is some text. </b><span><font color="#e5e5e5">~</font>

The &quot;d&quot; of &quot;daw&quot; is the delete operator.  &quot;aw&quot; is a text object.  Hint: &quot;aw&quot;
stands for &quot;A Word&quot;.  Thus &quot;daw&quot; is &quot;Delete A Word&quot;.

Using text objects is the third way to make changes in Vim.  We already had
operator-motion and Visual mode.  Now we add operator-text object.
   It is very similar to operator-motion, but instead of operating on the text
between the cursor position before and after a movement command, the text
object is used as a whole.  It doesn't matter where in the object the cursor
was.

To change a whole sentence use &quot;cis&quot;.  Take this text:

<span class="highlight"><b>        Hello there.  This </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        is an example.  Just </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        some text. </b><span><font color="#e5e5e5">~</font>

Move to the start of the second line, on &quot;is an&quot;.  Now use &quot;cis&quot;:

<span class="highlight"><b>        Hello there.    Just </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        some text. </b><span><font color="#e5e5e5">~</font>

The cursor is in between the blanks in the first line.  Now you type the new
sentence &quot;Another line.&quot;:

<span class="highlight"><b>        Hello there.  Another line.  Just </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        some text. </b><span><font color="#e5e5e5">~</font>

&quot;cis&quot; consists of the &quot;c&quot; (change) operator and the &quot;is&quot; text object.  This
stands for &quot;Inner Sentence&quot;.  There is also the &quot;as&quot; (a sentence) object.  The
difference is that &quot;as&quot; includes the white space after the sentence and &quot;is&quot;
doesn't.  If you would delete a sentence, you want to delete the white space
at the same time, thus use &quot;das&quot;.  If you want to type new text the white
space can remain, thus you use &quot;cis&quot;.

You can also use text objects in Visual mode.  It will include the text object
in the Visual selection.  Visual mode continues, thus you can do this several
times.  For example, start Visual mode with &quot;v&quot; and select a sentence with
&quot;as&quot;.  Now you can repeat &quot;as&quot; to include more sentences.  Finally you use an
operator to do something with the selected sentences.

You can find a long list of text objects here: <span class="highlight"><i>|text-objects|</i><span>.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*04.9*</i></b><span>  Replace mode

The &quot;R&quot; command causes Vim to enter replace mode.  In this mode, each
character you type replaces the one under the cursor.  This continues until
you type <span class="highlight"><i>&lt;Esc&gt;</i><span>.
   In this example you start Replace mode on the first &quot;t&quot; of &quot;text&quot;:

<span class="highlight"><b>        This is text. </b><span><font color="#e5e5e5">~</font>
                Rinteresting.<span class="highlight"><i>&lt;Esc&gt;</i><span>

<span class="highlight"><b>        This is interesting. </b><span><font color="#e5e5e5">~</font>

You may have noticed that this command replaced 5 characters in the line with
twelve others. The &quot;R&quot; command automatically extends the line if it runs out
of characters to replace.  It will not continue on the next line.

You can switch between Insert mode and Replace mode with the <span class="highlight"><i>&lt;Insert&gt;</i><span> key.

When you use <span class="highlight"><i>&lt;BS&gt;</i><span> (backspace) to make correction, you will notice that the
old text is put back.  Thus it works like an undo command for the last typed
character.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*04.10*</i></b><span> Conclusion

The operators, movement commands and text objects give you the possibility to
make lots of combinations.  Now that you know how it works, you can use <span class="highlight"><i>N</i><span>
operators with M movement commands to make <span class="highlight"><i>N</i><span> * M commands!

You can find a list of operators here: <span class="highlight"><i>|operator|</i><span>

For example, there are many other ways to delete pieces of text.  Here are a
few often used ones:

x       delete character under the cursor (short for &quot;dl&quot;)
X       delete character before the cursor (short for &quot;dh&quot;)
D       delete from cursor to end of line (short for &quot;d$&quot;)
dw      delete from cursor to next start of word
db      delete from cursor to previous start of word
diw     delete word under the cursor (excluding white space)
daw     delete word under the cursor (including white space)
dG      delete until the end of the file
dgg     delete until the start of the file

If you use &quot;c&quot; instead of &quot;d&quot; they become change commands.  And with &quot;y&quot; you
yank the text.  And so forth.


There are a few often used commands to make changes that didn't fit somewhere
else:

        ~       change case of the character under the cursor, and move the
                cursor to the next character.  This is not an operator (unless
                <span class="highlight"><i>'tildeop'</i><span> is set), thus you can't use it with a motion
                command.  It does works in Visual mode and changes case for
                all the selected text then.

        I       Start Insert mode after moving the cursor to the first
                non-blank in the line.

        A       Start Insert mode after moving the cursor to the end of the
                line.

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_05.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2001 Nov 02


                              Set your settings


Vim can be tuned to work like you want it to.  This chapter shows you how to
make Vim start with options set to different values.  Add plugins to extend
Vims capabilities.  Or define your own macros.

<span class="highlight"><i>|05.1|</i><span>  The vimrc file
<span class="highlight"><i>|05.2|</i><span>  The example vimrc file explained
<span class="highlight"><i>|05.3|</i><span>  Simple mappings
<span class="highlight"><i>|05.4|</i><span>  Adding a plugin
<span class="highlight"><i>|05.5|</i><span>  Adding a help file
<span class="highlight"><i>|05.6|</i><span>  The option window
<span class="highlight"><i>|05.7|</i><span>  Often used options


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*05.1*</i></b><span>  The vimrc file

You probably got tired of typing commands that you use very often.  To start
with all your favorite option settings and mappings, you write them in what is
called the vimrc file.  Vim reads this file when it starts up.

If you have trouble finding your vimrc file, use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :scriptnames</b><span>

One of the first files in the list should be called &quot;.vimrc&quot; or &quot;_vimrc&quot; and
is located in your home directory.
   If you don't have a vimrc file yet, see <span class="highlight"><i>|vimrc|</i><span> to find out where you can
create a vimrc file.  Also, the &quot;:version&quot; command mentions the name of the
&quot;user vimrc file&quot; Vim looks for.

For Unix this file is always used:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        ~/.vimrc</b><span>

For MS-DOS and MS-Windows it is mostly one of these:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        $HOME/_vimrc</b><span>
<span class="highlight"><b>        $VIM/_vimrc</b><span>

The vimrc file can contain all the commands that you type after a colon.  The
most simple ones are for setting options.  For example, if you want Vim to
always start with the <span class="highlight"><i>'incsearch'</i><span> option on, add this line you your vimrc
file:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        set incsearch</b><span>

For this new line to take effect you need to exit Vim and start it again.
Later you will learn how to do this without exiting Vim.

This chapter only explains the most basic items.  For more information on how
to write a Vim script file: <span class="highlight"><i>|usr_41.txt|</i><span>.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*05.2*</i></b></font></span>  The example vimrc file explained                <span class="highlight"><b><i>*vimrc_example.vim*</i></b><span>

In the first chapter was explained how the example vimrc (included in the
Vim distribution) file can be used to make Vim startup in not-compatible mode
(see <span class="highlight"><i>|not-compatible|</i><span>).  The file can be found here:

<span class="highlight"><b>        $VIMRUNTIME/vimrc_example.vim </b><span><font color="#e5e5e5">~</font>

In this section we will explain the various commands used in this file.  This
will give you hints about how to set up your own preferences.  Not everything
will be explained though.  Use the &quot;:help&quot; command to find out more.

<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        set nocompatible</b><span>

As mentioned in the first chapter, these manuals explain Vim working in an
improved way, thus not completely Vi compatible.  Setting the <span class="highlight"><i>'compatible'</i><span>
option off, thus <span class="highlight"><i>'nocompatible'</i><span> takes care of this.

<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        set backspace=indent,eol,start</b><span>

This specifies where in Insert mode the <span class="highlight"><i>&lt;BS&gt;</i><span> is allowed to delete the
character in front of the cursor.  The three items, separated by commas, tell
Vim to delete the white space at the start of the line, a line break and the
character before where Insert mode started.
<font color="#e5e5e5">&gt;</font>

<span class="highlight"><b>        set autoindent</b><span>

This makes Vim use the indent of the previous line for a newly created line.
Thus there is the same amount of white space before the new line.  For example
when pressing <span class="highlight"><i>&lt;Enter&gt;</i><span> in Insert mode, and when using the &quot;o&quot; command to open a
new line.
<font color="#e5e5e5">&gt;</font>

<span class="highlight"><b>        if has(&quot;vms&quot;)</b><span>
<span class="highlight"><b>          set nobackup</b><span>
<span class="highlight"><b>        else</b><span>
<span class="highlight"><b>          set backup</b><span>
<span class="highlight"><b>        endif</b><span>

This tells Vim to keep a backup copy of a file when overwriting it.  But not
on the VMS system, since it keeps old versions of files already.  The backup
file will have the same name as the original file with &quot;~&quot; added.  See <span class="highlight"><i>|07.4|</i><span>
<font color="#e5e5e5">&gt;</font>

<span class="highlight"><b>        set history=50</b><span>

Keep 50 commands and 50 search patterns in the history.  Use another number if
you want to remember fewer or more lines.
<font color="#e5e5e5">&gt;</font>

<span class="highlight"><b>        set ruler</b><span>

Always display the current cursor position in the lower right corner of the
Vim window.

<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        set showcmd</b><span>

Display an incomplete command in the lower right corner of the Vim window,
left of the ruler.  For example, when you type &quot;2f&quot;, Vim is waiting for you to
type the character to find and &quot;2f&quot; is displayed.  When you press &quot;w&quot; next,
the &quot;2fw&quot; command is executed and the displayed &quot;2f&quot; is removed.

        +-------------------------------------------------+
        |text in the Vim window                           |
        |~                                                |
        |~                                                |
        |-- VISUAL --                   2f     43,8   17% |
        +-------------------------------------------------+
         ^^^^^^^^^^^                  ^^^^^^^^ ^^^^^^^^^^
          <span class="highlight"><i>'showmode'</i></font></span>                 <span class="highlight"><i>'showcmd'</i><span>  <span class="highlight"><i>'ruler'</i><span>

<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        set incsearch</b><span>

Display the match for a search pattern when halfway typing it.

<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        map Q gq</b><span>

This defines a key mapping.  More about that in the next section.  This
defines the &quot;Q&quot; command to do formatting with the &quot;gq&quot; operator.  This is how
it worked before Vim 5.0.  Otherwise the &quot;Q&quot; command starts Ex mode, but you
will not need it.

<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        vnoremap p &lt;Esc&gt;:let current_reg = @&quot;&lt;CR&gt;gvs&lt;C-R&gt;=current_reg&lt;CR&gt;&lt;Esc&gt;</b><span>

This is a complicated mapping.  It will not be explained how it works here.
What it does is to make &quot;p&quot; in Visual mode overwrite the selected text with
the previously yanked text.  You can see that mappings can be used to do quite
complicated things.  Still, it is just a sequence of commands that are
executed like you typed them.

<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        if &amp;t_Co &gt; 2 || has(&quot;gui_running&quot;)</b><span>
<span class="highlight"><b>          syntax on</b><span>
<span class="highlight"><b>          set hlsearch</b><span>
<span class="highlight"><b>        endif</b><span>

This switches on syntax highlighting, but only if colors are available.  And
the <span class="highlight"><i>'hlsearch'</i><span> option tells Vim to highlight matches with the last used search
pattern.  The &quot;if&quot; command is very useful to set options only when some
condition is met.  More about that in <span class="highlight"><i>|usr_41.txt|</i><span>.

<span class="highlight"><b>                                                        </b></font></span><span class="highlight"><b><i>*vimrc-filetype*</i></b><span> <font color="#e5e5e5"> &gt;</font>
<span class="highlight"><b>        filetype plugin indent on</b><span>

This switches on three very clever mechanisms:
1. Filetype detection.
   Whenever you start editing a file, Vim will try to figure out what kind of
   file this is.  When you edit &quot;main.c&quot;, Vim will see the &quot;.c&quot; extension and
   recognize this as a &quot;c&quot; filetype.  When you edit a file that starts with
   &quot;#!/bin/sh&quot;, Vim will recognize it as a &quot;sh&quot; filetype.
   The filetype detection is used for syntax highlighting and the other two
   items below.
   See <span class="highlight"><i>|filetypes|</i><span>.

2. Using filetype plugin files
   Many different filetypes are edited with different options.  For example,
   when you edit a &quot;c&quot; file, it's very useful to set the <span class="highlight"><i>'cindent'</i><span> option to
   automatically indent the lines.  These commonly useful option settings are
   included with Vim in filetype plugins.  You can also add your own, see
   <span class="highlight"><i>|write-filetype-plugin|</i><span>.

3. Using indent files
   When editing programs, the indent of a line can often be computed
   automatically.  Vim comes with these indent rules for a number of
   filetypes.  See <span class="highlight"><i>|:filetype-indent-on|</i></font></span> and <span class="highlight"><i>'indentexpr'</i><span>.

<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        autocmd FileType text setlocal textwidth=78</b><span>

This makes Vim break text to avoid lines getting longer than 78 characters.
But only for files that have been detected to be plain text.  There are
actually two parts here.  &quot;autocmd FileType text&quot; is an autocommand.  This
defines that when the file type is set to &quot;text&quot; the following command is
automatically executed.  &quot;setlocal textwidth=78&quot; sets the <span class="highlight"><i>'textwidth'</i><span> option
to 78, but only locally in one file.
<font color="#e5e5e5">&gt;</font>

<span class="highlight"><b>        autocmd BufReadPost *</b><span>
<span class="highlight"><b>            \ if line(&quot;'\&quot;&quot;) &gt; 0 &amp;&amp; line(&quot;'\&quot;&quot;) &lt;= line(&quot;$&quot;) |</b><span>
<span class="highlight"><b>            \   exe &quot;normal g`\&quot;&quot; |</b><span>
<span class="highlight"><b>            \ endif</b><span>

Another autocommand.  This time it is used after reading any file.  The
complicated stuff after it checks if the '&quot; mark is defined, and jumps to it
if so.  The backslash at the start of a line is used to continue the command
from the previous line.  That avoids a line getting very long.
See <span class="highlight"><i>|line-continuation|</i><span>.  This only works in a Vim script file, not when
typing commands at the command-line.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*05.3*</i></b><span>  Simple mappings

A mapping enables you to bind a set of Vim commands to a single key.  Suppose,
for example, that you need to surround certain words with curly braces.  In
other words, you need to change a word such as &quot;amount&quot; into &quot;<span class="highlight"><i>{amount}</i><span>&quot;.  With
the :map command, you can tell Vim that the F5 key does this job.  The command
is as follows:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :map &lt;F5&gt; i{&lt;Esc&gt;ea}&lt;Esc&gt;</b><span>
<font color="#e5e5e5">&lt;</font>
        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        When entering this command, you must enter <span class="highlight"><i>&lt;F5&gt;</i><span> by typing four
        characters.  Similarly, <span class="highlight"><i>&lt;Esc&gt;</i></font></span> is not entered by pressing the <span class="highlight"><i>&lt;Esc&gt;</i><span>
        key, but by typing five characters.  Watch out for this difference
        when reading the manual!

Let's break this down:
    <span class="highlight"><i>&lt;F5&gt;</i><span>        The F5 function key.  This is the trigger key that causes the
                command to be executed as the key is pressed.

    i{<span class="highlight"><i>&lt;Esc&gt;</i></font></span>     Insert the { character.  The <span class="highlight"><i>&lt;Esc&gt;</i><span> key ends Insert mode.

    e           Move to the end of the word.

    a}<span class="highlight"><i>&lt;Esc&gt;</i><span>     Append the } to the word.

After you execute the &quot;:map&quot; command, all you have to do to put {} around a
word is to put the cursor on the first character and press F5.

In this example, the trigger is a single key; it can be any string.  But when
you use an existing Vim command, that command will no longer be available.
You better avoid that.
   One key that can be used with mappings is the backslash.  Since you
probably want to define more than one mapping, add another character.  You
could map &quot;\p&quot; to add parens around a word, and &quot;\c&quot; to add curly braces, for
example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :map \p i(&lt;Esc&gt;ea)&lt;Esc&gt;</b><span>
<span class="highlight"><b>        :map \c i{&lt;Esc&gt;ea}&lt;Esc&gt;</b><span>

You need to type the \ and the p quickly after another, so that Vim knows they
belong together.

The &quot;:map&quot; command (with no arguments) lists your current mappings.  At
least the ones for Normal mode.  More about mappings in section <span class="highlight"><i>|40.1|</i><span>.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*05.4*</i></b></font></span>  Adding a plugin                                 <span class="highlight"><b><i>*add-plugin*</i></b><span> <span class="highlight"><b><i>*plugin*</i></b><span>

Vim's functionality can be extended by adding plugins.  A plugin is nothing
more than a Vim script file that is loaded automatically when Vim starts.  You
can add a plugin very easily by dropping it in your plugin directory.
<span class="highlight"><i>{not available when Vim was compiled without the </i></font></span><span class="highlight"><i>|+eval|</i><span><span class="highlight"><i> feature}</i><span>

There are two types of plugins:

    global plugin: Used for all kinds of files
  filetype plugin: Only used for a specific type of file

The global plugins will be discussed first, then the filetype ones
<span class="highlight"><i>|add-filetype-plugin|</i><span>.


<span class="highlight"><b>GLOBAL PLUGINS                                          </b></font></span><span class="highlight"><b><i>*standard-plugin*</i></b><span>

When you start Vim, it will automatically load a number of global plugins.
You don't have to do anything for this.  They add functionality that most
people will want to use, but which was implemented as a Vim script instead of
being compiled into Vim.  You can find them listed in the help index
<span class="highlight"><i>|standard-plugin-list|</i></font></span>.  Also see <span class="highlight"><i>|load-plugins|</i><span>.

<span class="highlight"><b>                                                        </b></font></span><span class="highlight"><b><i>*add-global-plugin*</i></b><span>
You can add a global plugin to add functionality that will always be present
when you use Vim.  There are only two steps for adding a global plugin:
1. Get a copy of the plugin.
2. Drop it in the right directory.


GETTING A GLOBAL PLUGIN

Where can you find plugins?
- Some come with Vim.  You can find them in the directory $VIMRUNTIME/macros
  and its sub-directories.
- Download from the net, check out http://vim.sf.net.
- They are sometimes posted in a Vim <span class="highlight"><i>|maillist|</i><span>.
- You could write one yourself, see <span class="highlight"><i>|write-plugin|</i><span>.


USING A GLOBAL PLUGIN

First read the text in the plugin itself to check for any special conditions.
Then copy the file to your plugin directory:

<span class="highlight"><b>        system          plugin directory </b><span><font color="#e5e5e5">~</font>
        Unix            ~/.vim/plugin/
        PC and OS/2     $HOME/vimfiles/plugin or $VIM/vimfiles/plugin
        Amiga           s:vimfiles/plugin
        Macintosh       $VIM:vimfiles:plugin
        RISC-OS         Choices:vimfiles.plugin

Example for Unix (assuming you didn't have a plugin directory yet):<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        mkdir ~/.vim</b><span>
<span class="highlight"><b>        mkdir ~/.vim/plugin</b><span>
<span class="highlight"><b>        cp /usr/local/share/vim/vim60/macros/justify.vim ~/.vim/plugin</b><span>

That's all!  Now you can use the commands defined in this plugin to justify
text.


<span class="highlight"><b>FILETYPE PLUGINS                        </b></font></span><span class="highlight"><b><i>*add-filetype-plugin*</i></b><span> <span class="highlight"><b><i>*ftplugins*</i></b><span>

The Vim distribution comes with a set of plugins for different filetypes that
you can start using with this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :filetype plugin on</b><span>

That's all!  See <span class="highlight"><i>|vimrc-filetype|</i><span>.

If you are missing a plugin for a filetype you are using, or you found a
better one, you can add it.  There are two steps for adding a filetype plugin:
1. Get a copy of the plugin.
2. Drop it in the right directory.


GETTING A FILETYPE PLUGIN

You can find them in the same places as the global plugins.  Watch out if the
type of file is mentioned, then you know if the plugin is a global or a
filetype one.  The scripts in $VIMRUNTIME/macros are global ones, the filetype
plugins are in $VIMRUNTIME/ftplugin.


USING A FILETYPE PLUGIN

You can add a filetype plugin by dropping it in the right directory.  The
name of this directory is in the same directory mentioned above for global
plugins, but the last part is &quot;ftplugin&quot;.  Suppose you have found a plugin for
the &quot;stuff&quot; filetype, and you are on Unix.  Then you can move this file to the
ftplugin directory:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        mv thefile ~/.vim/ftplugin/stuff.vim</b><span>

If that file already exists you already have a plugin for &quot;stuff&quot;.  You might
want to check if the existing plugin doesn't conflict with the one you are
adding.  If it's OK, you can give the new one another name:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        mv thefile ~/.vim/ftplugin/stuff_too.vim</b><span>

The underscore is used to separate the name of the filetype from the rest,
which can be anything.  If you would use &quot;otherstuff.vim&quot; it wouldn't work, it
would be loaded for the &quot;otherstuff&quot; filetype.

On MS-DOS you cannot use long filenames.  You would run into trouble if you
add a second plugin and the filetype has more than six characters.  You can
use an extra directory to get around this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        mkdir $VIM/vimfiles/ftplugin/fortran</b><span>
<span class="highlight"><b>        copy thefile $VIM/vimfiles/ftplugin/fortran/too.vim</b><span>

The generic names for the filetype plugins are:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        ftplugin/&lt;filetype&gt;.vim</b><span>
<span class="highlight"><b>        ftplugin/&lt;filetype&gt;_&lt;name&gt;.vim</b><span>
<span class="highlight"><b>        ftplugin/&lt;filetype&gt;/&lt;name&gt;.vim</b><span>

Here &quot;<span class="highlight"><i>&lt;name&gt;</i><span>&quot; can be any name that you prefer.
Examples for the &quot;stuff&quot; filetype on Unix:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        ~/.vim/ftplugin/stuff.vim</b><span>
<span class="highlight"><b>        ~/.vim/ftplugin/stuff_def.vim</b><span>
<span class="highlight"><b>        ~/.vim/ftplugin/stuff/header.vim</b><span>

The <span class="highlight"><i>&lt;filetype&gt;</i><span> part is the name of the filetype the plugin is to be used for.
Only files of this filetype will use the settings from the plugin.  The <span class="highlight"><i>&lt;name&gt;</i><span>
part of the plugin file doesn't matter, you can use it to have several plugins
for the same filetype.  <span class="highlight"><b><i><u>Note</u></i></b><span> that it must end in &quot;.vim&quot;.


Further reading:
<span class="highlight"><i>|filetype-plugins|</i><span>      Documentation for the filetype plugins and information
                        about how to avoid that mappings cause problems.
<span class="highlight"><i>|load-plugins|</i><span>          When the global plugins are loaded during startup.
<span class="highlight"><i>|ftplugin-overrule|</i><span>     Overruling the settings from a global plugin.
<span class="highlight"><i>|write-plugin|</i><span>          How to write a plugin script.
<span class="highlight"><i>|plugin-details|</i><span>        For more information about using plugins or when your
                        plugin doesn't work.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*05.5*</i></b></font></span>  Adding a help file                      <span class="highlight"><b><i>*add-local-help*</i></b><span>

If you are lucky, the plugin you installed also comes with a help file.  We
will explain how to install the help file, so that you can easily find help
for your new plugin.
   Let us use the &quot;matchit.vim&quot; plugin as an example (it is included with
Vim).  This plugin makes the &quot;%&quot; command jump to matching HTML tags,
if/else/endif in Vim scripts, etc.  Very useful, although it's not backwards
compatible (that's why it is not enabled by default).
   This plugin comes with documentation: &quot;matchit.txt&quot;.  Let's first copy the
plugin to the right directory.  This time we will do it from inside Vim, so
that we can use $VIMRUNTIME.  (You may skip some of the &quot;mkdir&quot; commands if
you already have the directory.)<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :!mkdir ~/.vim</b><span>
<span class="highlight"><b>        :!mkdir ~/.vim/plugin</b><span>
<span class="highlight"><b>        :!cp $VIMRUNTIME/macros/matchit.vim ~/.vim/plugin</b><span>

Now create a &quot;doc&quot; directory in one of the directories in <span class="highlight"><i>'runtimepath'</i><span>.<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :!mkdir ~/.vim/doc</b><span>

Copy the help file to the &quot;doc&quot; directory.<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :!cp $VIMRUNTIME/macros/matchit.txt ~/.vim/doc</b><span>

Now comes the trick, which allows you to jump to the subjects in the new help
file: Generate the local tags file with the <span class="highlight"><i>|:helptags|</i><span> command.<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :helptags ~/.vim/doc</b><span>

Now you can use the<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :help g%</b><span>

command to find help for &quot;g%&quot; in the help file you just added.  You can see an
entry for the local help file when you do:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :help</b><span>

Go down to the &quot;LOCAL ADDITIONS&quot; section.  The title lines from the local help
files are automagically added to this section.  There you can see which local
help files have been added and jump to them through the tag.

For writing a local help file, see <span class="highlight"><i>|write-local-help|</i><span>.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*05.6*</i></b><span>  The option window

If you are looking for an option that does what you want, you can search in
the help files here: <span class="highlight"><i>|options|</i><span>.  Another way is by using this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :options</b><span>

This opens a new window, with a list of options with a one-line explanation.
The options are grouped by subject.  Move the cursor to a subject and press
<span class="highlight"><i>&lt;Enter&gt;</i></font></span> to jump there.  Press <span class="highlight"><i>&lt;Enter&gt;</i><span> again to jump back.  Or use <span class="highlight"><i>CTRL-O</i><span>.

You can change the value of an option.  For example, move to the &quot;displaying
text&quot; subject.  Then move the cursor down to this line:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        set wrap        nowrap</b><span>

When you hit <span class="highlight"><i>&lt;Enter&gt;</i><span>, the line will change to:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        set nowrap      wrap</b><span>

The option has now been switched off.

Just above this line is a short description of the <span class="highlight"><i>'wrap'</i><span> option.  Move the
cursor one line up to place it in this line.  Now hit <span class="highlight"><i>&lt;Enter&gt;</i><span> and you jump to
the full help on the <span class="highlight"><i>'wrap'</i></font></span> option.  Use <span class="highlight"><i>CTRL-O</i><span> to jump back.

For options that take a number or string argument you can edit the value.
Then press <span class="highlight"><i>&lt;Enter&gt;</i><span> to apply the new value.  For example, move the cursor a few
lines up to this line:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        set so=0</b><span>

Position the cursor on the zero with &quot;$&quot;.  Change it into a five with &quot;r5&quot;.
Then press <span class="highlight"><i>&lt;Enter&gt;</i><span> to apply the new value.  When you now move the cursor
around you will notice that the text starts scrolling before you reach the
border.  This is what the <span class="highlight"><i>'scrolloff'</i><span> option does, it specifies an offset
from the window border where scrolling starts.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*05.7*</i></b><span>  Often used options

There are an awful lot of options.  Most of them you will hardly ever use.
Some of the more useful ones will be mentioned here.  Don't forget you can
find more help on these options with the &quot;:help&quot; command, with single quotes
before and after the option name.  For example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :help 'wrap'</b><span>

In case you have messed up an option value, you can set it back to the
default by putting a ampersand (&amp;) after the option name.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set iskeyword&amp;</b><span>


NOT WRAPPING LINES

Vim normally wraps long lines, so that you can see all of the text.  Sometimes
it's better to let the text continue right of the window.  Then you need to
scroll the text left-right to see all of a long line.  Switch wrapping of with
this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set nowrap</b><span>

Vim will automatically scroll the text when you move to text that is not
displayed.  To see a context of ten characters, do this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set sidescroll=10</b><span>

This doesn't change the text in the file, only the way it is displayed.


WRAPPING MOVEMENT COMMANDS

Most commands for moving around will stop moving at the start and end of a
line.  You can change that with the <span class="highlight"><i>'whichwrap'</i><span> option.  This sets it to the
default value:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set whichwrap=b,s</b><span>

This allows the <span class="highlight"><i>&lt;BS&gt;</i><span> key, when used in the first position of a line, to move
the cursor to the end of the previous line.  And the <span class="highlight"><i>&lt;Space&gt;</i><span> key moves from
the end of a line to the start of the next one.

To allow the cursor keys <span class="highlight"><i>&lt;Left&gt;</i></font></span> and <span class="highlight"><i>&lt;Right&gt;</i><span> to also wrap, use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set whichwrap=b,s,&lt;,&gt;</b><span>

This is still only for Normal mode.  To let <span class="highlight"><i>&lt;Left&gt;</i></font></span> and <span class="highlight"><i>&lt;Right&gt;</i><span> do this in
Insert mode as well:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set whichwrap=b,s,&lt;,&gt;,[,]</b><span>

There are a few other flags that can be added, see <span class="highlight"><i>'whichwrap'</i><span>.


VIEWING TABS

When there are tabs in a file, you cannot see where they are.  To make them
visible:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set list</b><span>

Now every Tab is displayed as ^I.  And a $ is displayed at the end of each
line, so that you can spot trailing spaces that would otherwise go unnoticed.
   A disadvantage is that this looks ugly when there are many Tabs in a file.
If you have a color terminal, or are using the GUI, Vim can show the spaces
and tabs as highlighted characters.  Use the <span class="highlight"><i>'listchars'</i><span> option:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set listchars=tab:&gt;-,trail:-</b><span>

Now every tab will be displayed as &quot;&gt;---&quot; and trailing white space as &quot;-&quot;.
Looks a lot better, doesn't it?


KEYWORDS

The <span class="highlight"><i>'iskeyword'</i><span> option specifies which characters can appear in a word:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set iskeyword</b><span>
<font color="#e5e5e5">&lt;</font>         iskeyword=@,48-57,_,192-255<font color="#e5e5e5"> &gt;</font>

The &quot;@&quot; stands for all alphabetic letters.  &quot;48-57&quot; stands for ASCII
characters 48 to 57, which are the numbers 0 to 9.  &quot;192-255&quot; are the
printable latin characters.
   Sometimes you will want to include a dash in keywords, so that commands
like &quot;w&quot; consider &quot;upper-case&quot; to be one word.  You can do it like this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set iskeyword+=-</b><span>
<span class="highlight"><b>        :set iskeyword</b><span>
<font color="#e5e5e5">&lt;</font>         iskeyword=@,48-57,_,192-255,-

If you look at the new value, you will see that Vim has added a comma for you.
   To remove a character use &quot;-=&quot;.  For example, to remove the underscore:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set iskeyword-=_</b><span>
<span class="highlight"><b>        :set iskeyword</b><span>
<font color="#e5e5e5">&lt;</font>         iskeyword=@,48-57,192-255,-

This time a comma is automatically deleted.


ROOM FOR MESSAGES

When Vim starts there is one line at the bottom that is used for messages.
When a message is long, it is either truncated, thus you can only see part of
it, or the text scrolls and you have to press <span class="highlight"><i>&lt;Enter&gt;</i><span> to continue.
   You can set the <span class="highlight"><i>'cmdheight'</i><span> option to the number of lines used for
messages.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set cmdheight=3</b><span>

This does mean there is less room to edit text, thus it's a compromise.

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_06.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2001 Sep 03


                          Using syntax highlighting


Black and white text is boring.  With colors your file comes to life.  This
not only looks nice, it also speeds up your work.  Change the colors used for
the different sorts of text.  Print your text, with the colors you see on the
screen.

<span class="highlight"><i>|06.1|</i><span>  Switching it on
<span class="highlight"><i>|06.2|</i><span>  No or wrong colors?
<span class="highlight"><i>|06.3|</i><span>  Different colors
<span class="highlight"><i>|06.4|</i><span>  With colors or without colors
<span class="highlight"><i>|06.5|</i><span>  Printing with colors
<span class="highlight"><i>|06.6|</i><span>  Further reading


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*06.1*</i></b><span>  Switching it on

It all starts with one simple command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax enable</b><span>

That should work in most situations to get color in your files.  Vim will
automagically detect the type of file and load the right syntax highlighting.
Suddenly comments are blue, keywords brown and strings red.  This makes it
easy to overview the file.  After a while you will find that black&amp;white text
slows you down!

If you always want to use syntax highlighting, put the &quot;syntax enable&quot; command
in your <span class="highlight"><i>|vimrc|</i><span> file.

If you want syntax highlighting only when the terminal supports colors, you
can put this in your <span class="highlight"><i>|vimrc|</i><span> file:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        if &amp;t_Co &gt; 1</b><span>
<span class="highlight"><b>           syntax enable</b><span>
<span class="highlight"><b>        endif</b><span>

If you want syntax highlighting only in the GUI version, put the &quot;:syntax
enable&quot; command in your <span class="highlight"><i>|gvimrc|</i><span> file.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*06.2*</i></b><span>  No or wrong colors?

There can be a number of reasons why you don't see colors:

- Your terminal does not support colors.
        Vim will use bold, italic and underlined text, but this doesn't look
        very nice.  You probably will want to try to get a terminal with
        colors.  For Unix, I recommend the xterm from the XFree86 project:
        <span class="highlight"><i>|xfree-xterm|</i><span>.

- Your terminal does support colors, but Vim doesn't know this.
        Make sure your $TERM setting is correct.  For example, when using an
        xterm that supports colors:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>                setenv TERM xterm-color</b><span>
<font color="#e5e5e5">&lt;</font>
        or (depending on your shell):<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>                TERM=xterm-color; export TERM</b><span>

<font color="#e5e5e5">&lt;</font>       The terminal name must match the terminal you are using.  If it
        still doesn't work, have a look at <span class="highlight"><i>|xterm-color|</i><span>, which shows a few
        ways to make Vim display colors (not only for an xterm).

- The file type is not recognized.
        Vim doesn't know all file types, and sometimes it's near to impossible
        to tell what language a file uses.  Try this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>                :set filetype</b><span>
<font color="#e5e5e5">&lt;</font>
        If the result is &quot;filetype=&quot; then the problem is indeed that Vim
        doesn't know what type of file this is.  You can set the type
        manually:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>                :set filetype=fortran</b><span>

<font color="#e5e5e5">&lt;</font>       To see which types are available, look in the directory
        $VIMRUNTIME/syntax.  For the GUI you can use the Syntax menu.
        Setting the filetype can also be done with a <span class="highlight"><i>|modeline|</i><span>, so that the
        file will be highlighted each time you edit it.  For example, this
        line can be used in a Makefile (put it near the start or end of the
        file):<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>                # vim: syntax=make</b><span>

<font color="#e5e5e5">&lt;</font>       You might know how to detect the file type yourself.  Often the file
        name extension (after the dot) can be used.
        See <span class="highlight"><i>|new-filetype|</i><span> for how to tell Vim to detect that file type.

- There is no highlighting for your file type.
        You could try using a similar file type by manually setting it as
        mentioned above.  If that isn't good enough, you can write your own
        syntax file, see <span class="highlight"><i>|mysyntaxfile|</i><span>.


Or the colors could be wrong:

- The colored text is very hard to read.
        Vim guesses the background color that you are using.  If it is black
        (or another dark color) it will use light colors for text.  If it is
        white (or another light color) it will use dark colors for text.  If
        Vim guessed wrong the text will be hard to read.  To solve this, set
        the <span class="highlight"><i>'background'</i><span> option.  For a dark background:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>                :set background=dark</b><span>

<font color="#e5e5e5">&lt;</font>       And for a light background:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>                :set background=light</b><span>

<font color="#e5e5e5">&lt;</font>       Make sure you put this _before_ the &quot;:syntax enable&quot; command,
        otherwise the colors will already have been set.  You could do
        &quot;:syntax reset&quot; after setting <span class="highlight"><i>'background'</i><span> to make Vim set the default
        colors again.

- The colors are wrong when scrolling bottom to top.
        Vim doesn't read the whole file to parse the text.  It starts parsing
        wherever you are viewing the file.  That saves a lot of time, but
        sometimes the colors are wrong.  A simple fix is hitting <span class="highlight"><i>CTRL-L</i><span>.  Or
        scroll back a bit and then forward again.
        For a real fix, see <span class="highlight"><i>|:syn-sync|</i><span>.  Some syntax files have a way to make
        it look further back, see the help for the specific syntax file.  For
        example, <span class="highlight"><i>|tex.vim|</i><span> for the TeX syntax.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*06.3*</i></b></font></span>  Different colors                                <span class="highlight"><b><i>*:syn-default-override*</i></b><span>

If you don't like the default colors, you can select another color scheme.  In
the GUI use the Edit/Color Scheme menu.  You can also type the command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :colorscheme evening</b><span>

&quot;evening&quot; is the name of the color scheme.  There are several others you might
want to try out.  Look in the directory $VIMRUNTIME/colors.

When you found the color scheme that you like, add the &quot;:colorscheme&quot; command
to your <span class="highlight"><i>|vimrc|</i><span> file.

You could also write your own color scheme.  This is how you do it:

1. Select a color scheme that comes close.  Copy this file to your own Vim
   directory.  For Unix, this should work:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        !mkdir ~/.vim/colors</b><span>
<span class="highlight"><b>        !cp $VIMRUNTIME/colors/morning.vim ~/.vim/colors/mine.vim</b><span>
<font color="#e5e5e5">&lt;</font>
   This is done from Vim, because it knows the value of $VIMRUNTIME.

2. Edit the color scheme file.  These entries are useful:

        term            attributes in a B&amp;W terminal
        cterm           attributes in a color terminal
        ctermfg         foreground color in a color terminal
        ctermbg         background color in a color terminal
        gui             attributes in the GUI
        guifg           foreground color in the GUI
        guibg           background color in the GUI

   For example, to make comments green:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :highlight Comment ctermfg=green guifg=green</b><span>
<font color="#e5e5e5">&lt;</font>
   Attributes you can use for &quot;cterm&quot; and &quot;gui&quot; are &quot;bold&quot; and &quot;underline&quot;.
   If you want both, use &quot;bold,underline&quot;.  For details see the <span class="highlight"><i>|:highlight|</i><span>
   command.

3. Tell Vim to always use your color scheme.  Put this line in your <span class="highlight"><i>|vimrc|</i><span>:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        colorscheme mine</b><span>

If you want to see what the most often used color combinations look like, use
these commands:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :edit $VIMRUNTIME/syntax/colortest.vim</b><span>
<span class="highlight"><b>        :source %</b><span>

You will see text in various color combinations.  You can check which ones are
readable and look nice.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*06.4*</i></b><span>  With colors or without colors

Displaying text in color takes a lot of effort.  If you find the displaying
too slow, you might want to disable syntax highlighting for a moment:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax clear</b><span>

When editing another file (or the same one) the colors will come back.

<span class="highlight"><b>                                                        </b></font></span><span class="highlight"><b><i>*:syn-off*</i></b><span>
If you want to stop highlighting completely use:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax off</b><span>

This will completely disable syntax highlighting and remove it immediately for
all buffers.

<span class="highlight"><b>                                                        </b></font></span><span class="highlight"><b><i>*:syn-manual*</i></b><span>
If you want syntax highlighting only for specific files, use this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax manual</b><span>

This will enable the syntax highlighting, but not switch it on automatically
when starting to edit a buffer.  To switch highlighting on for the current
buffer, set the <span class="highlight"><i>'syntax'</i><span> option:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set syntax=ON</b><span>
<font color="#e5e5e5">&lt;</font>
<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*06.5*</i></b></font></span>  Printing with colors                            <span class="highlight"><b><i>*syntax-printing*</i></b><span>

In the MS-Windows version you can print the current file with this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :hardcopy</b><span>

You will get the usual printer dialog, where you can select the printer and a
few settings.  If you have a color printer, the paper output should look the
same as what you see inside Vim.  But when you use a dark background the
colors will be adjusted to look good on white paper.

There are several options that change the way Vim prints:
        <span class="highlight"><i>'printdevice'</i><span>
        <span class="highlight"><i>'printheader'</i><span>
        <span class="highlight"><i>'printfont'</i><span>
        <span class="highlight"><i>'printoptions'</i><span>

To print only a range of lines,  use Visual mode to select the lines and then
type the command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        v100j:hardcopy</b><span>

&quot;v&quot; starts Visual mode.  &quot;100j&quot; moves a hundred lines down, they will be
highlighted.  Then &quot;:hardcopy&quot; will print those lines.  You can use other
commands to move in Visual mode, of course.

This also works on Unix, if you have a PostScript printer.  Otherwise, you
will have to do a bit more work.  You need to convert the text to HTML first,
and then print it from a web browser such as Netscape.

Convert the current file to HTML with this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :source $VIMRUNTIME/syntax/2html.vim</b><span>

You will see it crunching away, this can take quite a while for a large file.
Some time later another window shows the HTML code.  Now write this somewhere
(doesn't matter where, you throw it away later):
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        :write main.c.html</b><span>

Open this file in your favorite browser and print it from there.  If all goes
well, the output should look exactly as it does in Vim.  See <span class="highlight"><i>|2html.vim|</i><span> for
details.  Don't forget to delete the HTML file when you are done with it.

Instead of printing, you could also put the HTML file on a web server, and let
others look at the colored text.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*06.6*</i></b><span>  Further reading

<span class="highlight"><i>|usr_44.txt|</i><span>  Your own syntax highlighted.
<span class="highlight"><i>|syntax|</i><span>      All the details.

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_07.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2001 Sep 03


                          Editing more than one file


No matter how many files you have, you can edit them without leaving Vim.
Define a list of files to work on and jump from one to the other.  Copy text
from one file and put it in another one.

<span class="highlight"><i>|07.1|</i><span>  Edit another file
<span class="highlight"><i>|07.2|</i><span>  A list of files
<span class="highlight"><i>|07.3|</i><span>  Jumping from file to file
<span class="highlight"><i>|07.4|</i><span>  Backup files
<span class="highlight"><i>|07.5|</i><span>  Copy text between files
<span class="highlight"><i>|07.6|</i><span>  Viewing a file
<span class="highlight"><i>|07.7|</i><span>  Changing the file name


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*07.1*</i></b><span>  Edit another file

So far you had to start Vim for every file you wanted to edit.  There is a
simpler way.  To start editing another file, use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :edit foo.txt</b><span>

You can use any file name instead of &quot;foo.txt&quot;.  Vim will close the current
file and open the new one.  If the current file has unsaved changes, however,
Vim displays an error message and does not open the new file:

<span class="highlight"><b>        E37: No write since last change (use ! to override) </b><span><font color="#e5e5e5">~</font>

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        Vim puts an error ID at the start of each error message.  If you do
        not understand the message or what caused it, look in the help system
        for this ID.  In this case:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>                :help E37</b><span>

At this point, you have a number of alternatives.  You can write the file
using this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :write</b><span>

Or you can force Vim to discard your changes and edit the new file, using the
force (!) character:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :edit! foo.txt</b><span>

If you want to edit another file, but not write the changes in the current
file yet, you can make it hidden:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :hide edit foo.txt</b><span>

The text with changes is still there, but you can't see it.  This is further
explained in section <span class="highlight"><i>|22.4|</i><span>: The buffer list.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*07.2*</i></b><span>  A list of files

You can start Vim to edit a sequence of files.  For example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        vim one.c two.c three.c</b><span>

This command starts Vim and tells it that you will be editing three files.
Vim displays just the first file.  After you have done your thing in this
file, to edit the next file you use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :next</b><span>

If you have unsaved changes in the current file, you will get an error
message and the &quot;:next&quot; will not work.  This is the same problem as with
&quot;:edit&quot; mentioned in the previous section.  To abandon the changes:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :next!</b><span>

But mostly you want to save the changes and move on to the next file.  There
is a special command for this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :wnext</b><span>

This does the same as using two separate commands:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :write</b><span>
<span class="highlight"><b>        :next</b><span>


WHERE AM I?

To see which file in the argument list you are editing, look in the window
title.  It should show something like &quot;(2 of 3)&quot;.  This means you are editing
the second file out of three files.
   If you want to see the list of files, use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :args</b><span>

This is short for &quot;arguments&quot;.  The output might look like this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        one.c [two.c] three.c</b><span>

These are the files you started Vim with.  The one you are currently editing,
&quot;two.c&quot;, is in square brackets.


MOVING TO OTHER ARGUMENTS

To go back one file:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :previous</b><span>

This is just like the &quot;:next&quot; command, except that it moves in the other
direction.  Again, there is a shortcut command for when you want to write the
file first:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :wprevious</b><span>

To move to the very last file in the list:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :last</b><span>

And to move back to the first one again:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :first</b><span>

There is no &quot;:wlast&quot; or &quot;wfirst&quot; command though!

You can use a count for &quot;:next&quot; and &quot;:previous&quot;.  To skip two files forward:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :2next</b><span>


AUTOMATIC WRITING

When moving around the files and making changes, you have to remember to use
&quot;:write&quot;.  Otherwise you will get an error message.  If you are sure you
always want to write modified files, you can tell Vim to automatically write
them:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set autowrite</b><span>

When you are editing a file which you may not want to write, switch it off
again:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set noautowrite</b><span>


EDITING ANOTHER LIST OF FILES

You can redefine the list of files without the need to exit Vim and start it
again.  Use this command to edit three other files:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :args five.c six.c seven.h</b><span>

Or use a wildcard, like it's used in the shell:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :args *.txt</b><span>

Vim will take you to the first file in the list.  Again, if the current file
has changes, you can either write the file first, or use &quot;:args!&quot; (with !
added) to abandon the changes.


DID YOU EDIT THE LAST FILE?
<span class="highlight"><b>                                                        </b></font></span><span class="highlight"><b><i>*arglist-quit*</i></b><span>
When you use a list of files, Vim assumes you want to edit them all.  To
protect you from exiting too early, you will get this error when you didn't
edit the last file in the list yet:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        E173: 46 more files to edit</b><span>

If you really want to exit, just do it again.  Then it will work (but not when
you did other commands in between).

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*07.3*</i></b><span>  Jumping from file to file

To quickly jump between two files, press <span class="highlight"><i>CTRL-^</i><span> (on English-US keyboards the ^
is above the 6 key).  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :args one.c two.c three.c</b><span>

You are now in one.c.<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :next</b><span>

Now you are in two.c.  Now use <span class="highlight"><i>CTRL-^</i></font></span> to go back to one.c.  Another <span class="highlight"><i>CTRL-^</i><span> and
you are back in two.c.  Another <span class="highlight"><i>CTRL-^</i><span> and you are in one.c again.  If you now
do:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :next</b><span>

You are in three.c.  Notice that the <span class="highlight"><i>CTRL-^</i><span> command does not change the idea
of where you are in the list of files.  Only commands like &quot;:next&quot; and
&quot;:previous&quot; do that.

The file you were previously editing is called the &quot;alternate&quot; file.  When you
just started Vim <span class="highlight"><i>CTRL-^</i><span> will not work, since there isn't a previous file.


PREDEFINED MARKS

After jumping to another file, you can use two predefined marks which are very
useful:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        `&quot;</b><span>

This takes you to the position where the cursor was when you left the file.
Another mark that is remembered is the position where you made the last
change:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        `.</b><span>

Suppose you are editing the file &quot;one.txt&quot;.  Somewhere halfway the file you
use &quot;x&quot; to delete a character.  Then you go to the last line with &quot;G&quot; and
write the file with &quot;:w&quot;.  You edit several other files, and then use &quot;:edit
one.txt&quot; to come back to &quot;one.txt&quot;.  If you now use `&quot; Vim jumps to the last
line of the file.  Using `. takes you to the position where you deleted the
character.  Even when you move around in the file `&quot; and `. will take you to
the remembered position.  At least until you make another change or leave the
file.


FILE MARKS

In chapter 4 was explained how you can place a mark in a file with &quot;mx&quot; and
jump to that position with &quot;`x&quot;.  That works within one file.  If you edit
another file and place marks there, these are specific for that file.  Thus
each file has its own set of marks, they are local to the file.
   So far we were using marks with a lowercase letter.  There are also marks
with an uppercase letter.  These are global, they can be used from any file.
For example suppose that we are editing the file &quot;foo.txt&quot;.  Go to halfway the
file (&quot;50%&quot;) and place the F mark there (F for foo):<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        50%mF</b><span>

Now edit the file &quot;bar.txt&quot; and place the B mark (B for bar) at its last line:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        GmB</b><span>

Now you can use the &quot;'F&quot; command to jump back to halfway foo.txt.  Or edit yet
another file, type &quot;'B&quot; and you are at the end of bar.txt again.

The file marks are remembered until they are placed somewhere else.  Thus you
can place the mark, do hours of editing and still be able to jump back to that
mark.
   It's often useful to think of a simple connection between the mark letter
and where it is placed.  For example, use the H mark in a header file, M in
a Makefile and C in a C code file.

To see where a specific mark is, give an argument to the &quot;:marks&quot; command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :marks M</b><span>

You can also give several arguments:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :marks MCP</b><span>

Don't forget that you can use <span class="highlight"><i>CTRL-O</i></font></span> and <span class="highlight"><i>CTRL-I</i><span> to jump to older and newer
positions without placing marks there.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*07.4*</i></b><span>  Backup files

Usually Vim does not produce a backup file. If you want to have one, all you
need to do is execute the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set backup</b><span>

The name of the backup file is the original file with a  ~  added to the end.
If your file is named data.txt, for example, the backup file name is
data.txt~.
   If you do not like the fact that the backup files end with ~, you can
change the extension:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set backupext=.bak</b><span>

This will use data.txt.bak instead of data.txt~.
   Another option that matters here is <span class="highlight"><i>'backupdir'</i><span>.  It specifies where the
backup file is written.  The default, to write the backup in the same
directory as the original file, will mostly be the right thing.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        When the <span class="highlight"><i>'backup'</i></font></span> option isn't set but the <span class="highlight"><i>'writebackup'</i><span> is, Vim will
        still create a backup file.  However, it is deleted as soon as writing
        the file was completed successfully.  This functions as a safety
        against losing your original file when writing fails in some way (disk
        full is the most common cause; being hit by lightning might be
        another, although less common).


KEEPING THE ORIGINAL FILE

If you are editing source files, you might want to keep the file before you
make any changes.  But the backup file will be overwritten each time you write
the file.  Thus it only contains the previous version, not the first one.
   To make Vim keep the original file, set the <span class="highlight"><i>'patchmode'</i><span> option.  This
specifies the extension used for the first backup of a changed file.  Usually
you would do this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set patchmode=.orig</b><span>

When you now edit the file data.txt for the first time, make changes and write
the file, Vim will keep a copy of the unchanged file under the name
&quot;data.txt.orig&quot;.
   If you make further changes to the file, Vim will notice that
&quot;data.txt.orig&quot; already exists and leave it alone.  Further backup files will
then be called &quot;data.txt~&quot; (or whatever you specified with <span class="highlight"><i>'backupext'</i><span>).
   If you leave patchmode empty (that is the default), the original file will
not be kept.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*07.5*</i></b><span>  Copy text between files

This explains how to copy text from one file to another.  Let's start with a
simple example.  Edit the file that contains the text you want to copy.  Move
the cursor to the start of the text and press &quot;v&quot;.  This starts Visual mode.
Now move the cursor to the end of the text and press &quot;y&quot;.  This yanks (copies)
the selected text.
   To copy the above paragraph, you would do:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :edit thisfile</b><span>
<span class="highlight"><b>        /This</b><span>
<span class="highlight"><b>        vjjjj$y</b><span>

Now edit the file you want to put the text in.  Move the cursor to the
character where you want the text to appear after.  Use &quot;p&quot; to put the text
there.<font color="#e5e5e5"> &gt;</font>
<span class="highlight"><b>        :edit otherfile</b><span>
<span class="highlight"><b>        /There</b><span>
<span class="highlight"><b>        p</b><span>

Of course you can use many other commands to yank the text.  For example, to
select whole lines start Visual mode with &quot;V&quot;.  Or use <span class="highlight"><i>CTRL-V</i><span> to select a
rectangular block.  Or use &quot;Y&quot; to yank a single line, &quot;yaw&quot; to yank-a-word,
etc.
   The &quot;p&quot; command puts the text after the cursor.  Use &quot;P&quot; to put the text
before the cursor.  Notice that Vim remembers if you yanked a whole line or a
block, and puts it back that way.


USING REGISTERS

When you want to copy several pieces of text from one file to another, having
to switch between the files and writing the target file takes a lot of time.
To avoid this, copy each piece of text to its own register.
   A register is a place where Vim stores text.  Here we will use the
registers named a to z (later you will find out there are others).  Let's copy
a sentence to the f register (f for First):<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        &quot;fyas</b><span>

The &quot;yas&quot; command yanks a sentence like before.  It's the &quot;f that tells Vim
the text should be place in the f register.  This must come just before the
yank command.
   Now yank three whole lines to the l register (l for line):<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        &quot;l3Y</b><span>

The count could be before the &quot;l just as well.  To yank a block of text to the
b (for block) register:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        CTRL-Vjjww&quot;by</b><span>

Notice that the register specification &quot;b is just before the &quot;y&quot; command.
This is required.  If you would have put it before the &quot;w&quot; command, it would
not have worked.
   Now you have three pieces of text in the f, l and b registers.  Edit
another file, move around and place the text where you want it:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        &quot;fp</b><span>

Again, the register specification &quot;f comes before the &quot;p&quot; command.
   You can put the registers in any order.  And the text stays in the register
until you yank something else into it.  Thus you can put it as many times as
you like.

When you delete text, you can also specify a register.  Use this to move
several pieces of text around.  For example, to delete-a-word and write it in
the w register:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        &quot;wdaw</b><span>

Again, the register specification comes before the delete command &quot;d&quot;.


APPENDING TO A FILE

When collecting lines of text into one file, you can use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :write &gt;&gt; logfile</b><span>

This will write the text of the current file to the end of &quot;logfile&quot;.  Thus it
is appended.  This avoids that you have to copy the lines, edit the log file
and put them there.  Thus you save two steps.  But you can only append to the
end of a file.
   To append only a few lines, select them in Visual mode before typing
&quot;:write&quot;.  In chapter 10 you will learn other ways to select a range of lines.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*07.6*</i></b><span>  Viewing a file

Sometimes you only want to see what a file contains, without the intention to
ever write it back.  There is the risk that you type &quot;:w&quot; without thinking and
overwrite the original file anyway.  To avoid this, edit the file read-only.
   To start Vim in readonly mode, use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        vim -R file</b><span>

On Unix this command should do the same thing:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        view file</b><span>

You are now editing &quot;file&quot; in read-only mode.  When you try using &quot;:w&quot; you
will get an error message and the file won't be written.
   When you try to make a change to the file Vim will give you a warning:

<span class="highlight"><b>        W10: Warning: Changing a readonly file </b><span><font color="#e5e5e5">~</font>

The change will be done though.  This allows for formatting the file, for
example, to be able to read it easily.
   If you make changes to a file and forgot that it was read-only, you can
still write it.  Add the ! to the write command to force writing.

If you really want to forbid making changes in a file, do this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        vim -M file</b><span>

Now every attempt to change the text will fail.  The help files are like this,
for example.  If you try to make a change you get this error message:

<span class="highlight"><b>        E21: Cannot make changes, 'modifiable' is off </b><span><font color="#e5e5e5">~</font>

You could use the -M argument to setup Vim to work in a viewer mode.  This is
only voluntary though, since these commands will remove the protection:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set modifiable</b><span>
<span class="highlight"><b>        :set write</b><span>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*07.7*</i></b><span>  Changing the file name

A clever way to start editing a new file is by using an existing file that
contains most of what you need.  For example, you start writing a new program
to move a file.  You know that you already have a program that copies a file,
thus you start with:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :edit copy.c</b><span>

You can delete the stuff you don't need.  Now you need to save the file under
a new name.  The &quot;:saveas&quot; command can be used for this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :saveas move.c</b><span>

Vim will write the file under the given name, and edit that file.  Thus the
next time you do &quot;:write&quot;, it will write &quot;move.c&quot;.  &quot;copy.c&quot; remains
unmodified.
   When you want to change the name of the file you are editing, but don't
want to write the file, you can use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :file move.c</b><span>

Vim will mark the file as &quot;not edited&quot;.  This means that Vim knows this is not
the file you started editing.  When you try to write the file, you might get
this message:

<span class="highlight"><b>        E13: File exists (use ! to override) </b><span><font color="#e5e5e5">~</font>

This protects you from accidentally overwriting another file.

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_08.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2002 Mar 09


                              Splitting windows


Display two different files above each other.  Or view two locations in the
file at the same time.  See the difference between two files by putting them
side by side.  All this is possible with split windows.

<span class="highlight"><i>|08.1|</i><span>  Split a window
<span class="highlight"><i>|08.2|</i><span>  Split a window on another file
<span class="highlight"><i>|08.3|</i><span>  Window size
<span class="highlight"><i>|08.4|</i><span>  Vertical splits
<span class="highlight"><i>|08.5|</i><span>  Moving windows
<span class="highlight"><i>|08.6|</i><span>  Commands for all windows
<span class="highlight"><i>|08.7|</i><span>  Viewing differences with vimdiff
<span class="highlight"><i>|08.8|</i><span>  Various


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*08.1*</i></b><span>  Split a window

The easiest way to open a new window is to use the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :split</b><span>

This command splits the screen into two windows and leaves the cursor in the
top one:

        +----------------------------------+
        |/* file one.c */                  |
        |~                                 |
        |~                                 |
        |one.c=============================|
        |/* file one.c */                  |
        |~                                 |
        |one.c=============================|
        |                                  |
        +----------------------------------+

What you see here is two windows on the same file.  The line with &quot;====&quot; is
that status line.  It displays information about the window above it.  (in
practice the status line will be in reverse video.)
   The two windows allow you to view two parts of the same file.  For example,
you could make the top window show the variable declarations of a program, and
the bottom one the code that uses these variables.

The <span class="highlight"><i>CTRL-W</i><span> w command can be used to jump between the windows.  If you are in
the top window, <span class="highlight"><i>CTRL-W</i><span> w jumps to the window below it.  If you are in the
bottom window it will jump to the first window. (<span class="highlight"><i>CTRL-W</i></font></span> <span class="highlight"><i>CTRL-W</i><span> does the same
thing, in case you let go of the CTRL key a bit later).


CLOSE THE WINDOW

To close a window, use the command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :close</b><span>

Actually, any command that quits editing a file works, like &quot;:quit&quot; and &quot;ZZ&quot;.
But &quot;:close&quot; prevents you from accidentally exiting Vim when you close the
last window.


CLOSING ALL OTHER WINDOWS

If you have opened a whole bunch of windows, but now want to concentrate on
one of them, this command will be useful:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :only</b><span>

This closes all windows, except for the current one.  If any of the other
windows has changes, you will get an error message and that window won't be
closed.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*08.2*</i></b><span>  Split a window on another file

The following command opens a second window and starts editing the given file:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        :split two.c</b><span>

If you were editing one.c, then the result looks like this:

        +----------------------------------+
        |/* file two.c */                  |
        |~                                 |
        |~                                 |
        |two.c=============================|
        |/* file one.c */                  |
        |~                                 |
        |one.c=============================|
        |                                  |
        +----------------------------------+

To open a window on a new, empty file, use this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :new</b><span>

You can repeat the &quot;:split&quot; and &quot;:new&quot; commands to create as many windows as
you like.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*08.3*</i></b><span>  Window size

The :split command can take a number argument.  If specified, this will be the
height of the new window.  For example, the following opens a new window three
lines high and starts editing the file alpha.c:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :3split alpha.c</b><span>

For existing windows you can change the size in several ways.  When you have a
working mouse, it is easy: Move the mouse pointer to the status line that
separates two windows, and drag it up or down.

To increase the size of a window:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        CTRL-W +</b><span>

To decrease it:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        CTRL-W -</b><span>

Both of these commands take a count and increase or decrease the window size
by that many lines.  Thus &quot;4 <span class="highlight"><i>CTRL-W</i><span> +&quot; make the window four lines higher.

To set the window height to a specified number of lines:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        {height}CTRL-W _</b><span>

That's: a number <span class="highlight"><i>{height}</i></font></span>, <span class="highlight"><i>CTRL-W</i><span> and then an underscore (the - key with Shift
on English-US keyboards).
   To make a window as high as it can be, use the <span class="highlight"><i>CTRL-W</i><span> _ command without a
count.


USING THE MOUSE

In Vim you can do many things very quickly from the keyboard.  Unfortunately,
the window resizing commands require quite a bit of typing.  In this case,
using the mouse is faster.  Position the mouse pointer on a status line.  Now
press the left mouse button and drag.  The status line will move, thus making
the window on one side higher and the other smaller.


OPTIONS

The <span class="highlight"><i>'winheight'</i><span> option can be set to a minimal desired height of a window and
<span class="highlight"><i>'winminheight'</i><span> to a hard minimum height.
   Likewise, there is <span class="highlight"><i>'winwidth'</i><span> for the minimal desired width and
<span class="highlight"><i>'winminwidth'</i><span> for the hard minimum width.
   The <span class="highlight"><i>'equalalways'</i><span> option, when set, makes Vim equalize the windows sizes
when a window is closed or opened.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*08.4*</i></b><span>  Vertical splits

The &quot;:split&quot; command creates the new window above the current one.  To make
the window appear at the left side, use:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :vsplit</b><span>

or:<font color="#e5e5e5"> &gt;</font>
<span class="highlight"><b>        :vsplit two.c</b><span>

The result looks something like this:

        +--------------------------------------+
        |/* file two.c */   |/* file one.c */  |
        |~                  |~                 |
        |~                  |~                 |
        |~                  |~                 |
        |two.c===============one.c=============|
        |                                      |
        +--------------------------------------+

Actually, the | lines in the middle will be in reverse video.  This is called
the vertical separator.  It separates the two windows left and right of it.

There is also the &quot;vnew&quot; command, to open a vertically split window on a new,
empty file.  Another way to do this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :vertical new</b><span>

The &quot;:vertical&quot; command can be inserted before another command that splits a
window.  This will cause that command to split the window vertically instead
of horizontally.  (if the command doesn't split a window, it works
unmodified).


MOVING BETWEEN WINDOWS

Since you can split windows horizontally and vertically as much as you like,
you can create any layout of windows.  Then you can use these commands to move
between them:

        <span class="highlight"><i>CTRL-W</i><span> h        move to the window on the left
        <span class="highlight"><i>CTRL-W</i><span> j        move to the window below
        <span class="highlight"><i>CTRL-W</i><span> k        move to the window above
        <span class="highlight"><i>CTRL-W</i><span> l        move to the window on the right

        <span class="highlight"><i>CTRL-W</i><span> t        move to the TOP window
        <span class="highlight"><i>CTRL-W</i><span> b        move to the BOTTOM window

You will notice the same letters as used for moving the cursor.  And the
cursor keys can also be used, if you like.
   More commands to move to other windows: <span class="highlight"><i>|Q_wi|</i><span>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*08.5*</i></b><span>  Moving windows

You have split a few windows, but now they are in the wrong place.  Then you
need a command to move the window somewhere else.  For example, you have three
windows like this:

        +----------------------------------+
        |/* file two.c */                  |
        |~                                 |
        |~                                 |
        |two.c=============================|
        |/* file three.c */                |
        |~                                 |
        |~                                 |
        |three.c===========================|
        |/* file one.c */                  |
        |~                                 |
        |one.c=============================|
        |                                  |
        +----------------------------------+

Clearly the last one should be at the top.  Go to that window (using <span class="highlight"><i>CTRL-W</i><span> w)
and the type this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        CTRL-W K</b><span>

This uses the uppercase letter K.  What happens is that the window is moved to
the very top.  You will notice that K is again used for moving upwards.
   When you have vertical splits, <span class="highlight"><i>CTRL-W</i><span> K will move the current window to the
top and make it occupy the full with of the Vim window.  If this is your
layout:

        +-------------------------------------------+
        |/* two.c */  |/* three.c */  |/* one.c */  |
        |~            |~              |~            |
        |~            |~              |~            |
        |~            |~              |~            |
        |~            |~              |~            |
        |~            |~              |~            |
        |two.c=========three.c=========one.c========|
        |                                           |
        +-------------------------------------------+

Then using <span class="highlight"><i>CTRL-W</i><span> K in the middle window (three.c) will result in:

        +-------------------------------------------+
        |/* three.c */                              |
        |~                                          |
        |~                                          |
        |three.c====================================|
        |/* two.c */           |/* one.c */         |
        |~                     |~                   |
        |two.c==================one.c===============|
        |                                           |
        +-------------------------------------------+

The other three similar commands (you can probably guess these now):

        <span class="highlight"><i>CTRL-W</i><span> H        move window to the far left
        <span class="highlight"><i>CTRL-W</i><span> J        move window to the bottom
        <span class="highlight"><i>CTRL-W</i><span> L        move window to the far right

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*08.6*</i></b><span>  Commands for all windows

When you have several windows open and you want to quit Vim, you can close
each window separately.  A quicker way is using this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :qall</b><span>

This stands for &quot;quit all&quot;.  If any of the windows contain changes, Vim will
not exit.  The cursor will automatically be positioned in a window with
changes.  You can then either use &quot;:write&quot; to save the changes, or &quot;:quit!&quot; to
throw them away.

If you know there are windows with changes, and you want to save all these
changes, use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :wall</b><span>

This stands for &quot;:write all&quot;.  But actually, it only writes files with
changes.  Vim knows it doesn't make sense to write files that were not
changed.
   And then there is the combination of &quot;:qall&quot; and &quot;wall&quot;: the &quot;write and
quit all&quot; command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :wqall</b><span>

This writes all modified files and quits Vim.
   Finally, there is a command that quits Vim and throws away all changes:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :qall!</b><span>

Be careful, there is no way to undo this command!


OPENING A WINDOW FOR ALL ARGUMENTS

To make Vim open a window for each file, start it with the &quot;-o&quot; argument:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        vim -o one.txt two.txt three.txt</b><span>

This results in:

        +-------------------------------+
        |file one.txt                   |
        |~                              |
        |one.txt========================|
        |file two.txt                   |
        |~                              |
        |two.txt========================|
        |file three.txt                 |
        |~                              |
        |three.txt======================|
        |                               |
        +-------------------------------+

The &quot;-O&quot; argument is used to get vertically split windows.
   When vim is already running, the &quot;:all&quot; command opens a window for each
file in the argument list.  &quot;:vertical all&quot; does it with vertical splits.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*08.7*</i></b><span>  Viewing differences with vimdiff

There is a special way to start Vim, which shows the differences between two
files.  Let's take a file &quot;main.c&quot; and insert a few characters in one line.
Write this file with the <span class="highlight"><i>'backup'</i><span> option set, so that the backup file
&quot;main.c~&quot; will contain the previous version of the file.
   Type this command in a shell (not in Vim):<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        vimdiff main.c~ main.c</b><span>

Vim will start, with two windows side by side.  You will only see the line
in which you added characters, and a few lines above and below it.

         VV                   VV
        +-----------------------------------------+
        |+ +--123 lines: /* a|+ +--123 lines: /* a|  &lt;- fold
        |  text              |  text              |
        |  text              |  text              |
        |  text              |  text              |
        |  text              |  changed text      |  &lt;- changed line
        |  text              |  text              |
        |  text              |  ------------------|  &lt;- deleted line
        |  text              |  text              |
        |  text              |  text              |
        |  text              |  text              |
        |+ +--432 lines: text|+ +--432 lines: text|  &lt;- fold
        |  ~                 |  ~                 |
        |  ~                 |  ~                 |
        |main.c~==============main.c==============|
        |                                         |
        +-----------------------------------------+

(This picture doesn't show the highlighting, use the vimdiff command for a
better look.)

   The lines that were not modified have been collapsed into one line.  This
is called a closed fold.  The are indicated in the picture with &quot;&lt;- fold&quot;.
Thus the single fold line at the top stands for 123 text lines.  These lines
are equal in both files.
   The line marked with &quot;&lt;- changed line&quot; is highlighted, and the inserted
text is displayed with another color.  This clearly shows what the difference
is between the two files.
   The line that was deleted is displayed with &quot;---&quot; in the main.c window.
See the &quot;&lt;- deleted line&quot; marker in the picture.  These characters are not
really there.  They just fill up main.c, so that it displays the same number
of lines as the other window.


THE FOLD COLUMN

Each window has a column on the left with a slightly different background.  In
the picture above these are indicated with &quot;VV&quot;.  You notice there is a plus
character there, in front of each closed fold.  Move the mouse pointer to that
plus and click the left button.  The fold will open, and you can see the text
that it contains.
   The fold column contains a minus sign for an open fold.  If you click on
this -, the fold will close.
   Obviously, this only works when you have a working mouse.  You can also use
&quot;zo&quot; to open a fold and &quot;zc&quot; to close it.


DIFFING IN VIM

Another way to start in diff mode can be done from inside Vim.  Edit the
&quot;main.c&quot; file, then make a split and show the differences:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :edit main.c</b><span>
<span class="highlight"><b>        :vertical diffsplit main.c~</b><span>

The &quot;:vertical&quot; command is used to make the window split vertically.  If you
omit this, you will get a horizontal split.

If you have a patch or diff file, you can use the third way to start diff
mode.  First edit the file to which the patch applies.  Then tell Vim the name
of the patch file:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :edit main.c</b><span>
<span class="highlight"><b>        :vertical diffpatch main.c.diff</b><span>

WARNING: The patch file must contain only one patch, for the file you are
editing.  Otherwise you will get a lot of error messages, and some files might
be patched unexpectedly.
   The patching will only be done to the copy of the file in Vim.  The file on
your harddisk will remain unmodified (until you decide to write the file).


SCROLL BINDING

When the files have more changes, you can scroll in the usual way.  Vim will
try to keep both the windows start at the same position, so you can easily see
the differences side by side.
   When you don't want this for a moment, use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set noscrollbind</b><span>


JUMPING TO CHANGES

When you have disabled folding in some way, it may be difficult to find the
changes.  Use this command to jump forward to the next change:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        ]c</b><span>

To go the other way use:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        [c</b><span>

Prepended a count to jump further away.


REMOVING CHANGES

You can move text from one window to the other.  This either removes
differences or adds new ones.  Vim doesn't keep the highlighting updated in
all situations.  To update it use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :diffupdate</b><span>

To remove a difference, you can move the text in a highlighted block from one
window to another.  Take the &quot;main.c&quot; and &quot;main.c~&quot; example above.  Move the
cursor to the left window, on the line that was deleted in the other window.
Now type this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        dp</b><span>

The change will be removed by putting the text of the current window in the
other window.  &quot;dp&quot; stands for &quot;diff put&quot;.
   You can also do it the other way around.  Move the cursor to the right
window, to the line where &quot;changed&quot; was inserted.  Now type this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        do</b><span>

The change will now be removed by getting the text from the other window.
Since there are no changes left now, Vim puts all text in a closed fold.
&quot;do&quot; stands for &quot;diff obtain&quot;.  &quot;dg&quot; would have been better, but that already
has a different meaning (&quot;dgg&quot; deletes from the cursor until the first line).

For details about diff mode, see <span class="highlight"><i>|vimdiff|</i><span>.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*08.8*</i></b><span>  Various

The <span class="highlight"><i>'laststatus'</i><span> option can be used to specify when the last window has a
statusline:

        0       never
        1       only when there are split windows (the default)
        2       always

Many commands that edit another file have a variant that splits the window.
For Command-line commands this is done by prepending an &quot;s&quot;.  For example:
&quot;:tag&quot; jumps to a tag, &quot;:stag&quot; splits the window and jumps to a
tag.
   For Normal mode commands a <span class="highlight"><i>CTRL-W</i></font></span> is prepended.  <span class="highlight"><i>CTRL-^</i><span> jumps to the
alternate file, <span class="highlight"><i>CTRL-W</i></font></span> <span class="highlight"><i>CTRL-^</i><span> splits the window and edits the alternate file.

The <span class="highlight"><i>'splitbelow'</i><span> option can be set to make a new window appear below the
current window.  The <span class="highlight"><i>'splitright'</i><span> option can be set to make a vertically split
window appear right of the current window.

When splitting a window you can prepend a modifier command to tell where the
window is to appear:

        :leftabove <span class="highlight"><i>{cmd}</i><span>        left or above the current window
        :aboveleft <span class="highlight"><i>{cmd}</i><span>        idem
        :rightbelow <span class="highlight"><i>{cmd}</i><span>       right or below the current window
        :belowright <span class="highlight"><i>{cmd}</i><span>       idem
        :topleft <span class="highlight"><i>{cmd}</i><span>          at the top or left of the Vim window
        :botright <span class="highlight"><i>{cmd}</i><span>         at the bottom or right of the Vim window

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_09.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2001 Sep 03


                                Using the GUI


Vim works in an ordinary terminal.  GVim can do the same things and a few
more.  The GUI offers menus, a toolbar, scrollbars and other items.  This
chapter is about these extra things that the GUI offers.

<span class="highlight"><i>|09.1|</i><span>  Parts of the GUI
<span class="highlight"><i>|09.2|</i><span>  Using the mouse
<span class="highlight"><i>|09.3|</i><span>  The clipboard
<span class="highlight"><i>|09.4|</i><span>  Select mode


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*09.1*</i></b><span>  Parts of the GUI

You might have an icon on your desktop that starts gVim.  Otherwise, one of
these commands should do it:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        gvim file.txt</b><span>
<span class="highlight"><b>        vim -g file.txt</b><span>

If this doesn't work you don't have a version of Vim with GUI support.  You
will have to install one first.
   Vim will open a window and display &quot;file.txt&quot; in it.  What the window looks
like depends on the version of Vim.  It should resemble the following picture
(for as far as this can be shown in ASCII!).

        +----------------------------------------------------+
        | file.txt + (~/dir) - VIM                         X |  &lt;- window title
        +----------------------------------------------------+
        | File  Edit  Tools  Syntax  Buffers  Window  Help   |  &lt;- menubar
        +----------------------------------------------------+
        | aaa  bbb  ccc  ddd  eee  fff  ggg  hhh  iii  jjj   |  &lt;- toolbar
        | aaa  bbb  ccc  ddd  eee  fff  ggg  hhh  iii  jjj   |
        +----------------------------------------------------+
        | file text                                      | ^ |
        | ~                                              | # |
        | ~                                              | # |  &lt;- scrollbar
        | ~                                              | # |
        | ~                                              | # |
        | ~                                              | # |
        |                                                | V |
        +----------------------------------------------------+

The largest space is occupied by the file text.  This shows the file in the
same way as in a terminal.  With some different colors and another font
perhaps.


THE WINDOW TITLE

At the very top is the window title.  This is drawn by your window system.
Vim will set the title to show the name of the current file.  First comes the
name of the file.  Then some special characters and the directory of the file
in parens.  These special character can be present:

        -       The file cannot be modified (e.g., a help file)
        +       The file contains changes
        =       The file is read-only
        =+      The file is read-only, contains changes anyway

If nothing is shown you have an ordinary, unchanged file.


THE MENUBAR

You know how menus work, right?  Vim has the usual items, plus a few more.
Browse them to get an idea of what you can use them for.  A relevant submenu
is Edit/Global Settings.  You will find these entries:

        Toggle Toolbar          make the toolbar appear/disappear
        Toggle Bottom Scrollbar make a scrollbar appear/disappear at the bottom
        Toggle Left Scrollbar   make a scrollbar appear/disappear at the left
        Toggle Right Scrollbar  make a scrollbar appear/disappear at the right

On most systems you can tear-off the menus.  Select the top item of the menu,
the one that looks like a dashed line.  You will get a separate window with
the items of the menu.  It will hang around until you close the window.


THE TOOLBAR

This contains icons for the most often used actions.  Hopefully the icons are
self-explanatory.  There are tooltips to get an extra hint (move the mouse
pointer to the icon without clicking and don't move it for a second).

The &quot;Edit/Global Settings/Toggle Toolbar&quot; menu item can be used to make the
toolbar disappear.  If you never want a toolbar, use this command in your
vimrc file:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set guioptions-=T</b><span>

This removes the 'T' flag from the <span class="highlight"><i>'guioptions'</i><span> option.  Other parts of the
GUI can also be enabled or disabled with this option.  See the help for it.


THE SCROLLBARS

By default there is one scrollbar on the right.  It does the obvious thing.
When you split the window, each window will get its own scrollbar.
   You can make a horizontal scrollbar appear with the menu item
Edit/Global Settings/Toggle Bottom Scrollbar.  This is useful in diff mode, or
when the <span class="highlight"><i>'wrap'</i><span> option has been reset (more about that later).

When there are vertically split windows, only the windows on the right side
will have a scrollbar.  However, when you move the cursor to a window on the
left, it will be this one the that scrollbar controls.  This takes a bit of
time to get used to.
   When you work with vertically split windows, consider adding a scrollbar on
the left.  This can be done with a menu item, or with the <span class="highlight"><i>'guioptions'</i><span> option:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        :set guioptions+=l</b><span>

This adds the 'l' flag to <span class="highlight"><i>'guioptions'</i><span>.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*09.2*</i></b><span>  Using the mouse

Standards are wonderful.  In Microsoft Windows, you can use the mouse to
select text in a standard manner.  The X Window system also has a standard
system for using the mouse.  Unfortunately, these two standards are not the
same.
   Fortunately, you can customize Vim.  You can make the behavior of the mouse
work like an X Window system mouse or a Microsoft Windows mouse. The following
command makes the mouse behave like an X Window mouse:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :behave xterm</b><span>

The following command makes the mouse work like a Microsoft Windows mouse:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :behave mswin</b><span>

The default behavior of the mouse on UNIX systems is xterm.  The default
behavior on a Microsoft Windows system is selected during the installation
process.  For details about what the two behaviors are, see <span class="highlight"><i>|:behave|</i><span>.  Here
follows a summary.


XTERM MOUSE BEHAVIOR

Left mouse click                position the cursor
Left mouse drag                 select text in Visual mode
Middle mouse click              paste text from the clipboard
Right mouse click               extend the selected text until the mouse
                                pointer


MSWIN MOUSE BEHAVIOR

Left mouse click                position the cursor
Left mouse drag                 select text in Select mode (see <span class="highlight"><i>|09.4|</i><span>)
Left mouse click, with Shift    extend the selected text until the mouse
                                pointer
Middle mouse click              paste text from the clipboard
Right mouse click               display a pop-up menu


The mouse can be further tuned.  Check out these options if you want to change
the way how the mouse works:

        <span class="highlight"><i>'mouse'</i><span>                 in which mode the mouse is used by Vim
        <span class="highlight"><i>'mousemodel'</i><span>            what effect a mouse click has
        <span class="highlight"><i>'mousetime'</i><span>             time between clicks for a double-click
        <span class="highlight"><i>'mousehide'</i><span>             hide the mouse while typing
        <span class="highlight"><i>'selectmode'</i><span>            whether the mouse starts Visual or Select mode

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*09.3*</i></b><span>  The clipboard

In section <span class="highlight"><i>|04.7|</i><span> the basic use of the clipboard was explained.  There is one
essential thing to explain about X-windows: There are actually two places to
exchange text between programs.  MS-Windows doesn't have this.

In X-Windows there is the &quot;current selection&quot;.  This is the text that is
currently highlighted.  In Vim this is the Visual area (this assumes you are
using the default option settings).  You can paste this selection in another
application without any further action.
   For example, in this text select a few words with the mouse.  Vim will
switch to Visual mode and highlight the text.  Now start another gVim, without
a file name argument, so that it displays an empty window.  Click the middle
mouse button.  The selected text will be inserted.

The &quot;current selection&quot; will only remain valid until some other text is
selected.  After doing the paste in the other gVim, now select some characters
in that window.  You will notice that the words that were previously selected
in the other gVim window are displayed differently.  This means that it no
longer is the current selection.

You don't need to select text with the mouse, using the keyboard commands for
Visual mode works just as well.


THE REAL CLIPBOARD

Now for the other place with which text can be exchanged.  We call this the
&quot;real clipboard&quot;, to avoid confusion.  Often both the &quot;current selection&quot; and
the &quot;real clipboard&quot; are called clipboard, you'll have to get used to that.
   To put text on the real clipboard, select a few different words in one of
the gVims you have running.  Then use the Edit/Copy menu entry.  Now the text
has been copied to the real clipboard.  You can't see this, unless you have
some application that shows the clipboard contents (e.g., KDE's klipper).
   Now select the other gVim, position the cursor somewhere and use the
Edit/Paste menu.  You will see the text from the real clipboard is inserted.


USING BOTH

This use of both the &quot;current selection&quot; and the &quot;real clipboard&quot; might sound
a bit confusing.  But it is very useful.  Let's show this with an example.
Use one gVim with a text file and perform these actions:

-  Select two words in Visual mode.
-  Use the Edit/Copy menu to get these words onto the clipboard.
-  Select one other word in Visual mode.
-  Use the Edit/Paste menu item.  What will happen is that the single selected
   word is replaced with the two words from the clipboard.
-  Move the mouse pointer somewhere else and click the middle button.  You
   will see that the word you just overwrote with the clipboard is inserted
   here.

If you use the &quot;current selection&quot; and the &quot;real clipboard&quot; with care, you can
do a lot of useful editing with them.


USING THE KEYBOARD

If you don't like using the mouse, you can access the current selection and
the real clipboard with two registers.  The &quot;* register is for the current
selection.
   To make text become the current selection, use Visual mode.  For example,
to select a whole line just press &quot;V&quot;.
   To insert the current selection before the cursor:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        &quot;*P</b><span>

Notice the uppercase &quot;P&quot;.  The lowercase &quot;p&quot; puts the text after the cursor.

The &quot;+ register is used for the real clipboard.  For example, to copy the text
from the cursor position until the end of the line to the clipboard:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        &quot;+y$</b><span>

Remember, &quot;y&quot; is yank, which is Vim's copy command.
   To insert the contents of the real clipboard before the cursor:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        &quot;+P</b><span>

It's the same as for the current selection, but uses the plus (+) register
instead of the star (*) register.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*09.4*</i></b><span>  Select mode

And now something that is used more often on MS-Windows than on X-Windows.
But both can do it.  You already know about Visual mode.  Select mode is like
Visual mode, because it is also used to select text.  But there is an obvious
difference: When typing text, the selected text is deleted and the typed text
replaces it.

To start working with Select mode, you must first enable it (for MS-Windows
it is probably already enabled, but you can do this anyway):<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set selectmode+=mouse</b><span>

Now use the mouse to select some text.  It is highlighted like in Visual mode.
Now press a letter.  The selected text is deleted, and the single letter
replaces it.  You are in Insert mode now, thus you can continue typing.

Since typing normal text causes the selected text to be deleted, you can not
use the normal movement commands &quot;hjkl&quot;, &quot;w&quot;, etc.  Instead, use the shifted
function keys.  <span class="highlight"><i>&lt;S-Left&gt;</i><span> (shifted cursor left key) moves the cursor left.  The
selected text is changed like in Visual mode.  The other shifted cursor keys
do what you expect.  <span class="highlight"><i>&lt;S-End&gt;</i></font></span> and <span class="highlight"><i>&lt;S-Home&gt;</i><span> also work.

You can tune the way Select mode works with the <span class="highlight"><i>'selectmode'</i><span> option.

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_10.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2001 Sep 18


                             Making big changes


In chapter 4 several ways to make small changes were explained.  This chapter
goes into making changes that are repeated or can affect a large amount of
text.  The Visual mode allows doing various things with blocks of text.  Use
an external program to do really complicated things.

<span class="highlight"><i>|10.1|</i><span>  Record and playback commands
<span class="highlight"><i>|10.2|</i><span>  Substitution
<span class="highlight"><i>|10.3|</i><span>  Command ranges
<span class="highlight"><i>|10.4|</i><span>  The global command
<span class="highlight"><i>|10.5|</i><span>  Visual block mode
<span class="highlight"><i>|10.6|</i><span>  Reading and writing part of a file
<span class="highlight"><i>|10.7|</i><span>  Formatting text
<span class="highlight"><i>|10.8|</i><span>  Changing case
<span class="highlight"><i>|10.9|</i><span>  Using an external program


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*10.1*</i></b><span>  Record and playback commands

The &quot;.&quot; command repeats the preceding change.  But what if you want to do
something more complex than a single change?  That's where command recording
comes in.  There are three steps:

1. The &quot;q<span class="highlight"><i>{register}</i><span>&quot; command starts recording keystrokes into the register
   named <span class="highlight"><i>{register}</i><span>.  The register name must be between a and z.
2. Type your commands.
3. To finish recording, press q (without any extra character).

You can now execute the macro by typing the command &quot;@<span class="highlight"><i>{register}</i><span>&quot;.

Take a look at how to use these commands in practice.  You have a list of
filenames that look like this:

<span class="highlight"><b>        stdio.h </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        fcntl.h </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        unistd.h </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        stdlib.h </b><span><font color="#e5e5e5">~</font>

And what you want is the following:

<span class="highlight"><b>        #include &quot;stdio.h&quot; </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        #include &quot;fcntl.h&quot; </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        #include &quot;unistd.h&quot; </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        #include &quot;stdlib.h&quot; </b><span><font color="#e5e5e5">~</font>

You start by moving to the first character of the first line.  Next you
execute the following commands:

        qa                      Start recording a macro in register a.
        ^                       Move to the beginning of the line.
        i#include &quot;<span class="highlight"><i>&lt;Esc&gt;</i><span>        Insert the string #include &quot; at the beginning
                                of the line.
        $                       Move to the end of the line.
        a&quot;<span class="highlight"><i>&lt;Esc&gt;</i><span>                 Append the character double quotation mark (&quot;)
                                to the end of the line.
        j                       Go to the next line.
        q                       Stop recording the macro.

Now that you have done the work once, you can repeat the change by typing the
command &quot;@a&quot; three times.
The &quot;@a&quot; command can be preceded by a count, which will cause the macro to be
executed that number of times.  In this case you would type:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        3@a</b><span>


MOVE AND EXECUTE

You might have the lines you want to change in various places.  Just move the
cursor to each location and use the &quot;@a&quot; command.  If you have done that once,
you can do it again with &quot;@@&quot;.  That's a bit easier to type.  If you now
execute register b with &quot;@b&quot;, the next &quot;@@&quot; will use register b.
   If you compare the playback method with using &quot;.&quot;, there are several
differences.  First of all, &quot;.&quot; can only repeat one change.  As seen in the
example above, &quot;@a&quot; can do several changes, and move around as well.
Secondly, &quot;.&quot; can only remember the last change.  Executing a register allows
you to make any changes and then still use &quot;@a&quot; to replay the recorded
commands.  Finally, you can use 26 different registers.  Thus you can remember
26 different command sequences to execute.


USING REGISTERS

The registers used for recording are the same ones you used for yank and
delete commands.  This allows you to mix recording with other commands to
manipulate the registers.
   Suppose you have recorded a few commands in register n.  When you execute
this with &quot;@n&quot; you notice you did something wrong.  You could try recording
again, but perhaps you will make another mistake.  Instead, use this trick:

        G                       Go to the end of the file.
        o<span class="highlight"><i>&lt;Esc&gt;</i><span>                  Create an empty line.
        &quot;np                     Put the text from the n register.  You now see
                                the commands you typed as text in the file.
        <span class="highlight"><i>{edits}</i><span>                 Change the commands that were wrong.  This is
                                just like editing text.
        0                       Go to the start of the line.
        &quot;ny$                    Yank the corrected commands into the n
                                register.
        dd                      Delete the scratch line.

Now you can execute the corrected commands with &quot;@n&quot;.  (If your recorded
commands include line breaks, adjust the last two items in the example to
include all the lines).


APPENDING TO A REGISTER

So far we have used a lowercase letter for the register name.  To append to a
register, use an uppercase letter.
   Suppose you have recorded a command to change a word to register c.  It
works properly, but you would like to add a search for the next word to
change.  This can be done with:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        qC/word&lt;Enter&gt;q</b><span>

You start with &quot;qC&quot;, which records to the c register and appends.  Thus
writing to an uppercase register name means to append to the register with
the same letter, but lowercase.

This works both with recording and with yank and delete commands.  For
example, you want to collect a sequence of lines into the a register.  Yank
the first line with:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        &quot;aY</b><span>

Now move to the second line, and type:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        &quot;AY</b><span>

Repeat this command for all lines.  The a register now contains all those
lines, in the order you yanked them.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*10.2*</i></b><span>  Substitution

The &quot;:substitute&quot; command enables you to perform string replacements on a
whole range of lines.  The general form of this command is as follows:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :[range]substitute/from/to/[flags]</b><span>

This command changes the &quot;from&quot; string to the &quot;to&quot; string in the lines
specified with <span class="highlight"><i>[range]</i><span>.  For example, you can change &quot;Professor&quot; to &quot;Teacher&quot;
in all lines with the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :%substitute/Professor/Teacher/</b><span>
<font color="#e5e5e5">&lt;</font>
        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        The :substitute command is almost never spelled out completely.  Most
        of the time, people use the abbreviated version &quot;:s&quot;.  From here on
        the abbreviation will be used.

The &quot;%&quot; before the command specifies the command works on all lines.  Without
a range, &quot;:s&quot; only works on the current line.  More about ranges in the next
section.

By default, the &quot;:substitute&quot; command changes only the first occurrence on
each line.  For example, the preceding command changes the line:

<span class="highlight"><b>        Professor Smith criticized Professor Johnson today. </b><span><font color="#e5e5e5">~</font>

to:

<span class="highlight"><b>        Teacher Smith criticized Professor Johnson today. </b><span><font color="#e5e5e5">~</font>

To change every occurrence on the line, you need to add the g (global) flag.
The command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :%s/Professor/Teacher/g</b><span>

results in (starting with the original line):

<span class="highlight"><b>        Teacher Smith criticized Teacher Johnson today. </b><span><font color="#e5e5e5">~</font>

Other flags include p (print), which causes the &quot;:substitute&quot; command to print
out each line it changes.  The c (confirm) flag tells &quot;:substitute&quot; to ask you
for confirmation before it performs each substitution.  Enter the following:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :%s/Professor/Teacher/c</b><span>

Vim finds the first occurrence of &quot;Professor&quot; and displays the text it is
about to change.  You get the following prompt:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        replace with Teacher (y/n/a/q/l/^E/^Y)?</b><span>

At this point, you must enter one of the following answers:

        y               Yes; make this change.
        n               No; skip this match.
        a               All; make this change and all remaining ones without
                        further confirmation.
        q               Quit; don't make any more changes.
        l               Last; make this change and then quit.
        <span class="highlight"><i>CTRL-E</i><span>          Scroll the text one line up.
        <span class="highlight"><i>CTRL-Y</i><span>          Scroll the text one line down.


The &quot;from&quot; part of the substitute command is actually a pattern.  The same
kind as used for the search command.  For example, this command only
substitutes &quot;the&quot; when it appears at the start of a line:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :s/^the/these/</b><span>

If you are substituting with a &quot;from&quot; or &quot;to&quot; part that includes a slash, you
need to put a backslash before it.  A simpler way is to use another character
instead of the slash.  A plus, for example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :s+one/two+one or two+</b><span>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*10.3*</i></b><span>  Command ranges

The &quot;:substitute&quot; command, and many other : commands, can be applied to a
selection of lines.  This is called a range.
   The simple form of a range is <span class="highlight"><i>{number}</i></font></span>,<span class="highlight"><i>{number}</i><span>.  For example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :1,5s/this/that/g</b><span>

Executes the substitute command on the lines 1 to 5.  Line 5 is included.
The range is always placed before the command.

A single number can be used to address one specific line:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :54s/President/Fool/</b><span>

Some commands work on the whole file when you do not specify a range.  To make
them work on the current line the &quot;.&quot; address is used.  The &quot;:write&quot; command
works like that.  Without a range, it writes the whole file.  To make it write
only the current line into a file:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :.write otherfile</b><span>

The first line always has number one.  How about the last line?  The &quot;$&quot;
character is used for this.  For example, to substitute in the lines from the
cursor to the end:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :.,$s/yes/no/</b><span>

The &quot;%&quot; range that we used before, is actually a short way to say &quot;1,$&quot;, from
the first to the last line.


USING A PATTERN IN A RANGE

Suppose you are editing a chapter in a book, and want to replace all
occurences of &quot;grey&quot; with &quot;gray&quot;.  But only in this chapter, not in the next
one.  You know that only chapter boundaries have the word &quot;Chapter&quot; in the
first column.  This command will work then:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :?^Chapter?,/^Chapter/s=grey=gray=g</b><span>

You can see a search pattern is used twice.  The first &quot;?^Chapter?&quot; finds the
line above the current position that matches this pattern.  Thus the ?pattern?
range is used to search backwards.  Similarly, &quot;/^Chapter/&quot; is used to search
forward for the start of the next chapter.
   To avoid confusion with the slashes, the &quot;=&quot; character was used in the
substitute command here.  A slash or another character would have worked as
well.


ADD AND SUBTRACT

There is a slight error in the above command: If the title of the next chapter
had included &quot;grey&quot; it would be replaced as well.  Maybe that's what you
wanted, but what if you didn't?  Then you can specify an offset.
   To search for a pattern and then use the line above it:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /Chapter/-1</b><span>

You can use any number instead of the 1.  To address the second line below the
match:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /Chapter/+2</b><span>

The offsets can also be used with the other items in a range.  Look at this
one:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :.+3,$-5</b><span>

This specifies the range that starts three lines below the cursor and ends
five lines before the last line in the file.


USING MARKS

Instead of figuring out the line numbers of certain positions, remembering them
and typing them in a range, you can use marks.
   Place the marks as mentioned in chapter 3.  For example, use &quot;mt&quot; to mark
the top of an area and &quot;mb&quot; to mark the bottom.  Then you can use this range
to specify the lines between the marks (including the lines with the marks):<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :'t,'b</b><span>


VISUAL MODE AND RANGES

You can select text with Visual mode.  If you then press &quot;:&quot; to start a colon
command, you will see this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :'&lt;,'&gt;</b><span>

Now you can type the command and it will be applied to the range of lines that
was visually selected.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        When using Visual mode to select part of a line, or using <span class="highlight"><i>CTRL-V</i><span> to
        select a block of text, the colon commands will still apply to whole
        lines.  This might change in a future version of Vim.

The '&lt; and '&gt; are actually marks, placed at the start and end of the Visual
selection.  The marks remain at their position until another Visual selection
is made.  Thus you can use the &quot;'&lt;&quot; command to jump to position where the
Visual area started.  And you can mix the marks with other items:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :'&gt;,$</b><span>

This addresses the lines from the end of the Visual area to the end of the
file.


A NUMBER OF LINES

When you know how many lines you want to change, you can type the number and
then &quot;:&quot;.  For example, when you type &quot;5:&quot;, you will get:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :.,.+4</b><span>

Now you can type the command you want to use.  It will use the range &quot;.&quot;
(current line) until &quot;.+4&quot; (four lines down).  Thus it spans five lines.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*10.4*</i></b><span>  The global command

The &quot;:global&quot; command is one of the more powerful features of Vim.  It allows
you to find a match for a pattern and execute a command there.  The general
form is:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :[range]global/{pattern}/{command}</b><span>

This is similar to the &quot;:substitute&quot; command.  But, instead of replacing the
matched text with other text, the command <span class="highlight"><i>{command}</i><span> is executed.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        The command executed for &quot;:global&quot; must be one that starts with a
        colon.  Normal mode commands can not be used directly.  The <span class="highlight"><i>|:normal|</i><span>
        command can do this for you.

Suppose you want to change &quot;foobar&quot; to &quot;barfoo&quot;, but only in C++ style
comments.  These comments start with &quot;//&quot;.  Use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :g+//+s/foobar/barfoo/g</b><span>

This starts with &quot;:g&quot;.  That is short for &quot;:global&quot;, just like &quot;:s&quot; is short
for &quot;:substitute&quot;.  Then the pattern, enclosed in plus characters.  Since the
pattern we are looking for contains a slash, this uses the plus character to
separate the pattern.  Next comes the substitute command that changes &quot;foobar&quot;
into &quot;barfoo&quot;.
   The default range for the global command is the whole file.  Thus no range
was specified in this example.  This is different from &quot;:substitute&quot;, which
works on one line without a range.
   The command isn't perfect, since it also matches lines where &quot;//&quot; appears
halfway a line, and the substitution will also take place before the &quot;//&quot;.

Just like with &quot;:substitute&quot;, any pattern can be used.  When you learn more
complicated patterns later, you can use them here.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*10.5*</i></b><span>  Visual block mode

With <span class="highlight"><i>CTRL-V</i><span> you can start selection of a rectangular area of text.  There are
a few commands that do something special with the text block.

There is something special about using the &quot;$&quot; command in Visual block mode.
When the last motion command used was &quot;$&quot;, all lines in the Visual selection
will extend until the end of the line, also when the line with the cursor is
shorter.  This remains effective until you use a motion command that moves the
cursor horizontally.  Thus using &quot;j&quot; keeps it, &quot;h&quot; stops it.


INSERTING TEXT

The command  &quot;I<span class="highlight"><i>{string}&lt;Esc&gt;</i></font></span>&quot; inserts the text <span class="highlight"><i>{string}</i><span> in each line, just
left of the visual block.  You start by pressing <span class="highlight"><i>CTRL-V</i><span> to enter visual block
mode.  Now you move the cursor to define your block.  Next you type I to enter
Insert mode, followed by the text to insert.  As you type, the text appears on
the first line only.
   After you press <span class="highlight"><i>&lt;Esc&gt;</i><span> to end the insert, the text will magically be
inserted in the rest of the lines contained in the visual selection.  Example:

<span class="highlight"><b>        include one </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        include two </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        include three </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        include four </b><span><font color="#e5e5e5">~</font>

Move the cursor to the &quot;o&quot; of &quot;one&quot; and press <span class="highlight"><i>CTRL-V</i><span>.  Move it down with &quot;3j&quot;
to &quot;four&quot;.  You now have a block selection that spans four lines.  Now type:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        Imain.&lt;Esc&gt;</b><span>

The result:

<span class="highlight"><b>        include main.one </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        include main.two </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        include main.three </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        include main.four </b><span><font color="#e5e5e5">~</font>

If the block spans short lines that do not extend into the block, the text is
not inserted in that line.  For example, make a Visual block selection that
includes the word &quot;long&quot; in the first and last line of this text, and thus has
no text selected in the second line:

<span class="highlight"><b>        This is a long line </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        short </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        Any other long line </b><span><font color="#e5e5e5">~</font>

                  ^^^^ selected block

Now use the command &quot;Ivery <span class="highlight"><i>&lt;Esc&gt;</i><span>&quot;.  The result is:

<span class="highlight"><b>        This is a very long line </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        short </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        Any other very long line </b><span><font color="#e5e5e5">~</font>

In the short line no text was inserted.

If the string you insert contains a newline, the &quot;I&quot; acts just like a Normal
insert command and affects only the first line of the block.

The &quot;A&quot; command works the same way, except that it appends after the right
side of the block.
   There is one special case for &quot;A&quot;: Select a Visual block and then use &quot;$&quot;
to make the block extend to the end of each line.  Using &quot;A&quot; now will append
the text to the end of each line.
   Using the same example from above, and then typing &quot;$A XXX<span class="highlight"><i>&lt;Esc&gt;</i><span>, you get
this result:

<span class="highlight"><b>        This is a long line XXX </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        short XXX </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        Any other long line XXX </b><span><font color="#e5e5e5">~</font>

This really requires using the &quot;$&quot; command.  Vim remembers that it was used.
Making the same selection by moving the cursor to the end of the longest line
with other movement commands will not have the same result.


CHANGING TEXT

The Visual block &quot;c&quot; command deletes the block and then throws you into Insert
mode to enable you to type in a string.  The string will be inserted in each
line in the block.
   Starting with the same selection of the &quot;long&quot; words as above, then typing
&quot;c_LONG_<span class="highlight"><i>&lt;Esc&gt;</i><span>&quot;, you get this:

<span class="highlight"><b>        This is a _LONG_ line </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        short </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        Any other _LONG_ line </b><span><font color="#e5e5e5">~</font>

Just like with &quot;I&quot; the short line is not changed.  Also, you can't enter a
newline in the new text.

The &quot;C&quot; command deletes text from the left edge of the block to the end of
line.  It then puts you in Insert mode so that you can type in a string,
which is added to the end of each line.
   Starting with the same text again, and typing &quot;Cnew text<span class="highlight"><i>&lt;Esc&gt;</i><span>&quot; you get:

<span class="highlight"><b>        This is a new text </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        short </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        Any other new text </b><span><font color="#e5e5e5">~</font>

Notice that, even though only the &quot;long&quot; word was selected, the text after it
is deleted as well.  Thus only the location of the left edge of the visual
block really matters.
   Again, short lines that do not reach into the block are excluded.

Other commands that change the characters in the block:

        ~       swap case       (a -&gt; A and A -&gt; a)
        U       make uppercase  (a -&gt; A and A -&gt; A)
        u       make lowercase  (a -&gt; a and A -&gt; a)


FILLING WITH A CHARACTER

To fill the whole block with one character, use the &quot;r&quot; command.  Again,
starting with the same example text from above, and then typing &quot;rx&quot;:

<span class="highlight"><b>        This is a xxxx line </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        short </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        Any other xxxx line </b><span><font color="#e5e5e5">~</font>


        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        If you want to include characters beyond the end of the line in the
        block, check out the <span class="highlight"><i>'virtualedit'</i><span> feature in chapter 25.


SHIFTING

The command &quot;&gt;&quot; shifts the selected text to the right one shift amount,
inserting whitespace.  The starting point for this shift is the left edge of
the visual block.
   With the same example again, &quot;&gt;&quot; gives this result:

<span class="highlight"><b>        This is a         long line </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        short </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        Any other         long line </b><span><font color="#e5e5e5">~</font>

The shift amount is specified with the <span class="highlight"><i>'shiftwidth'</i><span> option.  To change it to
use 4 spaces:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set shiftwidth=4</b><span>

The &quot;&lt;&quot; command removes one shift amount of whitespace at the left
edge of the block.  This command is limited by the amount of text that is
there; so if there is less than a shift amount of whitespace available, it
removes what it can.


JOINING LINES

The &quot;J&quot; command joins all selected lines together into one line.  Thus it
removes the line breaks.  Actually, the line break, leading white space and
trailing white space is replaced by one space.  Two spaces are used after a
line ending (that can be changed with the <span class="highlight"><i>'joinspaces'</i><span> option).
   Let's use the example that we got so familiar with now.  The result of
using the &quot;J&quot; command:

<span class="highlight"><b>        This is a long line short Any other long line </b><span><font color="#e5e5e5">~</font>

The &quot;J&quot; command doesn't require a blockwise selection.  It works with &quot;v&quot; and
&quot;V&quot; selection in exactly the same way.

If you don't want the white space to be changed, use the &quot;gJ&quot; command.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*10.6*</i></b><span>  Reading and writing part of a file

When you are writing an e-mail message, you may want to include another file.
This can be done with the &quot;:read <span class="highlight"><i>{filename}</i><span>&quot; command.  The text of the file is
put below the cursor line.
   Starting with this text:

<span class="highlight"><b>        Hi John, </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        Here is the diff that fixes the bug: </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        Bye, Pierre. </b><span><font color="#e5e5e5">~</font>

Move the cursor to the second line and type:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :read patch</b><span>

The file named &quot;patch&quot; will be inserted, with this result:

<span class="highlight"><b>        Hi John, </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        Here is the diff that fixes the bug: </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        2c2 </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        &lt;       for (i = 0; i &lt;= length; ++i) </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        --- </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        &gt;       for (i = 0; i &lt; length; ++i) </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        Bye, Pierre. </b><span><font color="#e5e5e5">~</font>

The &quot;:read&quot; command accepts a range.  The file will be put below the last line
number of this range.  Thus &quot;:$r patch&quot; appends the file &quot;patch&quot; at the end of
the file.
   What if you want to read the file above the first line?  This can be done
with the line number zero.  This line doesn't really exist, you will get an
error message when using it with most commands.  But this command is allowed:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        :0read patch</b><span>

The file &quot;patch&quot; will be put above the first line of the file.


WRITING A RANGE OF LINES

To write a range of lines to a file, the &quot;:write&quot; command can be used.
Without a range it writes the whole file.  With a range only the specified
lines are written:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :.,$write tempo</b><span>

This writes the lines from the cursor until the end of the file into the file
&quot;tempo&quot;.  If this file already exists you will get an error message.  Vim
protects you from accidentally overwriting an existing file.  If you know what
you are doing and want to overwrite the file, append !:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :.,$write! tempo</b><span>

CAREFUL: The ! must follow the &quot;:write&quot; command immediately, without white
space.  Otherwise it becomes a filter command, which is explained later in
this chapter.


APPENDING TO A FILE

In the first section of this chapter was explained how to collect a number of
lines into a register.  The same can be done to collect lines in a file.
Write the first line with this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :.write collection</b><span>

Now move the cursor to the second line you want to collect, and type this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :.write &gt;&gt;collection</b><span>

The &quot;&gt;&gt;&quot; tells Vim the &quot;collection&quot; file is not to be written as a new file,
but the line must be appended at the end.   You can repeat this as many times
as you like.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*10.7*</i></b><span>  Formatting text

When you are typing plain text, it's nice if the length of each line is
automatically trimmed to fit in the window.  To make this happen while
inserting text, set the <span class="highlight"><i>'textwidth'</i><span> option:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set textwidth=72</b><span>

You might remember that in the example vimrc file this command was used for
every text file.  Thus if you are using that vimrc file, you were already
using it.  To check the current value of <span class="highlight"><i>'textwidth'</i><span>:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set textwidth</b><span>

Now lines will be broken to take only up to 72 characters.  But when you
insert text halfway a line, or when you delete a few words, the lines will get
too long or too short.  Vim doesn't automatically reformat the text.
   To tell Vim to format the current paragraph:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        gqap</b><span>

This starts with the &quot;gq&quot; command, which is an operator.  Following is &quot;ap&quot;,
the text object that stands for &quot;a paragraph&quot;.  A paragraph is separated from
the next paragraph by an empty line.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        A blank line, which contains white space, does NOT separate
        paragraphs.  This is hard to notice!

Instead of &quot;ap&quot; you could use any motion or text object.  If your paragraphs
are properly separated, you can use this command to format the whole file:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        gggqG</b><span>

&quot;gg&quot; takes you to the first line, &quot;gq&quot; is the format operator and &quot;G&quot; the
motion that jumps to the last line.

In case your paragraphs aren't clearly defined, you can format just the lines
you manually select.  Move the cursor to the first line you want to format.
Start with the command &quot;gqj&quot;.  This formats the current line and the one below
it.  If the first line was short, words from the next line will be appended.
If it was too long, words will be moved to the next line.  The cursor moves to
the second line.  Now you can use &quot;.&quot; to repeat the command.  Keep doing this
until you are at the end of the text you want to format.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*10.8*</i></b><span>  Changing case

You have text with section headers in lowercase.  You want to make the word
&quot;section&quot; all uppercase.  Do this with the &quot;gU&quot; operator.  Start with the
cursor in the first column:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>                             gUw</b><span>
<font color="#e5e5e5">&lt;</font>       section header      ----&gt;      SECTION header

The &quot;gu&quot; operator does exactly the opposite:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>                             guw</b><span>
<font color="#e5e5e5">&lt;</font>       SECTION header      ----&gt;      section header

You can also use &quot;g~&quot; to swap case.  All these are operators, thus they work
with any motion command, with text objects and in Visual mode.
   To make an operator work on lines you double it.  The delete operator is
&quot;d&quot;, thus to delete a line you use &quot;dd&quot;.  Similarly, &quot;gugu&quot; makes a whole line
lowercase.  This can be shortened to &quot;guu&quot;.  &quot;gUgU&quot; is shortened to &quot;gUU&quot; and
&quot;g~g~&quot; to &quot;g~~&quot;.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>                                g~~</b><span>
<font color="#e5e5e5">&lt;</font><span class="highlight"><b>       Some GIRLS have Fun    ----&gt;   sOME girls HAVE fUN </b><span><font color="#e5e5e5">~</font>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*10.9*</i></b><span>  Using an external program

Vim has a very powerful set of commands, it can do anything.  But there may
still be something that an external command can do better or faster.
   The command &quot;!<span class="highlight"><i>{motion}{program}</i><span>&quot; takes a block of text and filters it
through an external program.  In other words, it runs the system command
represented by <span class="highlight"><i>{program}</i></font></span>, giving it the block of text represented by <span class="highlight"><i>{motion}</i><span>
as input.  The output of this command then replaces the selected block.
   Because this summarizes badly if you are unfamiliar with UNIX filters, take
a look at an example.  The sort command sorts a file.  If you execute the
following command, the unsorted file input.txt will be sorted and written to
output.txt. (This works on both UNIX and Microsoft Windows.)<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        sort &lt;input.txt &gt;output.txt</b><span>

Now do the same thing in Vim.  You want to sort lines 1 through 5 of a file.
You start by putting the cursor on line 1.  Next you execute the following
command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        !5G</b><span>

The &quot;!&quot; tells Vim that you are performing a filter operation.  The Vim editor
expects a motion command to follow, indicating which part of the file to
filter.  The &quot;5G&quot; command tells Vim to go to line 5, so it now knows that it
is to filter lines 1 (the current line) through 5.
   In anticipation of the filtering, the cursor drops to the bottom of the
screen and a ! prompt displays.  You can now type in the name of the filter
program, in this case &quot;sort&quot;.  Therefore, your full command is as follows:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        !5Gsort&lt;Enter&gt;</b><span>

The result is that the sort program is run on the first 5 lines.  The output
of the program replaces these lines.

        line 55                       line 11
        line 33                       line 22
        line 11        --&gt;            line 33
        line 22                       line 44
        line 44                       line 55
        last line                     last line

The &quot;!!&quot; command filters the current line through a filter.  In Unix the &quot;date&quot;
command prints the current time and date.  &quot;!!date<span class="highlight"><i>&lt;Enter&gt;</i><span>&quot; replaces the current
line with the output of &quot;date&quot;.  This is useful to add a timestamp to a file.


WHEN IT DOESN'T WORK

Starting a shell, sending it text and capturing the output requires that Vim
knows how the shell works exactly.  When you have problems with filtering,
check the values of these options:

        <span class="highlight"><i>'shell'</i><span>         specifies the program that Vim uses to execute
                        external programs.
        <span class="highlight"><i>'shellcmdflag'</i><span>  argument to pass a command to the shell
        <span class="highlight"><i>'shellquote'</i><span>    quote to be used around the command
        <span class="highlight"><i>'shellxquote'</i><span>   quote to be used around the command and redirection
        <span class="highlight"><i>'shelltype'</i><span>     kind of shell (only for the Amiga)
        <span class="highlight"><i>'shellslash'</i><span>    use forward slashes in the command (only for
                        MS-Windows and alikes)
        <span class="highlight"><i>'shellredir'</i><span>    string used to write the command output into a file

On Unix this is hardly ever a problem, because there are two kinds of shells:
&quot;sh&quot; like and &quot;csh&quot; like.  Vim checks the <span class="highlight"><i>'shell'</i><span> option and sets related
options automatically, depending on whether it sees &quot;csh&quot; somewhere in
<span class="highlight"><i>'shell'</i><span>.
   On MS-Windows, however, there are many different shells and you might have
to tune the options to make filtering work.  Check the help for the options
for more information.


READING COMMAND OUTPUT

To read the contents of the current directory into the file, use this:

on Unix:<font color="#e5e5e5"> &gt;</font>
<span class="highlight"><b>        :read !ls</b><span>
on MS-Windows:<font color="#e5e5e5"> &gt;</font>
<span class="highlight"><b>        :read !dir</b><span>

The output of the &quot;ls&quot; or &quot;dir&quot; command is captured and inserted in the text,
below the cursor.  This is similar to reading a file, except that the &quot;!&quot; is
used to tell Vim that a command follows.
   The command may have arguments.  And a range can be used to tell where Vim
should put the lines:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :0read !date -u</b><span>

This inserts the current time and date in UTC format at the top of the file.
(Well, if you have a date command that accepts the &quot;-u&quot; argument.)  <span class="highlight"><b><i><u>Note</u></i></b><span> the
difference with using &quot;!!date&quot;: that replaced a line, while &quot;:read !date&quot; will
insert a line.


WRITING TEXT TO A COMMAND

The Unix command &quot;wc&quot; counts words.  To count the words in the current file:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :write !wc</b><span>

This is the same write command as before, but instead of a file name the &quot;!&quot;
character is used and the name of an external command.  The written text will
be passed to the specified command as its standard input.  The output could
look like this:

<span class="highlight"><b>       4      47     249 </b><span><font color="#e5e5e5">~</font>

The &quot;wc&quot; command isn't verbose.  This means you have 4 lines, 47 words and 249
characters.

Watch out for this mistake:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :write! wc</b><span>

This will write the file &quot;wc&quot; in the current directory, with force.  White
space is important here!


REDRAWING THE SCREEN

If the external command produced an error message, the display may have been
messed up.  Vim is very efficient and only redraws those parts of the screen
that it knows need redrawing.  But it can't know about what another program
has written.  To tell Vim to redraw the screen:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        CTRL-L</b><span>

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_11.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2001 Sep 03


                           Recovering from a crash


Did your computer crash?  And you just spent hours editing?  Don't panic!  Vim
keeps enough information on harddisk to be able to restore most of your work.
This chapter shows you how to get your work back and explains how the swap
file is used.

<span class="highlight"><i>|11.1|</i><span>  Basic recovery
<span class="highlight"><i>|11.2|</i><span>  Where is the swap file?
<span class="highlight"><i>|11.3|</i><span>  Crashed or not?
<span class="highlight"><i>|11.4|</i><span>  Further reading


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*11.1*</i></b><span>  Basic recovery

In most cases recovering a file is quite simple, assuming you know which file
you were editing (and the harddisk is still working).  Start Vim on the file,
with the &quot;-r&quot; argument added:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        vim -r help.txt</b><span>

Vim will read the swap file (used to store text you were editing) and may read
bits and pieces of the original file.  If all is well, you will see these
messages (with different file names, of course):

<span class="highlight"><b>        Using swap file &quot;.help.txt.swp&quot; </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        Original file &quot;~/vim/runtime/doc/help.txt&quot; </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        Recovery completed. You should check if everything is OK. </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        (You might want to write out this file under another name </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        and run diff with the original file to check for changes) </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        Delete the .swp file afterwards. </b><span><font color="#e5e5e5">~</font>

To be on the safe side, write this file under another name:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :write help.txt.recovered</b><span>

Compare the file with the original file to check if you ended up with what you
expected.  Vimdiff is very useful for this <span class="highlight"><i>|08.7|</i><span>.  Watch out for the original
file to contain a more recent version (you saved the file just before the
computer crashed).  And check that no lines are missing (something went wrong
that Vim could not recover).
   If Vim produces warning messages when recovering, read them carefully.
This is rare though.

It's normal that the last few changes can not be recovered.  Vim flushes the
changes to disk when you don't type for about four seconds, or after typing
about two hundred characters.  This is set with the <span class="highlight"><i>'updatetime'</i><span> and
<span class="highlight"><i>'updatecount'</i><span> options.  Thus when Vim didn't get a chance to save itself when
the system went down, the changes after the last flush will be lost.

If you were editing without a file name, give an empty string as argument:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        vim -r &quot;&quot;</b><span>

You must be in the right directory, otherwise Vim can't find the swap file.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*11.2*</i></b><span>  Where is the swap file?

Vim can store the swap file in several places.  Normally it is in the same
directory as the original file.  To find it, change to the directory of the
file, and use:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        vim -r</b><span>

Vim will list the swap files that it can find.  It will also look in other
directories where the swap file for files in the current directory may be
located.  It will not find swap files in any other directories though, it
doesn't search the directory tree.
   The output could look like this:

<span class="highlight"><b>        Swap files found: </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>           In current directory: </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        1.    .main.c.swp </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                  owned by: mool   dated: Tue May 29 21:00:25 2001 </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                 file name: ~mool/vim/vim6/src/main.c </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                  modified: YES </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                 user name: mool   host name: masaka.moolenaar.net </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                process ID: 12525 </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>           In directory ~/tmp: </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>              -- none -- </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>           In directory /var/tmp: </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>              -- none -- </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>           In directory /tmp: </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>              -- none -- </b><span><font color="#e5e5e5">~</font>

If there are several swap files that look like they may be the one you want to
use, a list is given of these swap files and you are requested to enter the
number of the one you want to use.  Carefully look at the dates to decide
which one you want to use.
   In case you don't know which one to use, just try them one by one and check
the resulting files if they are what you expected.


USING A SPECIFIC SWAP FILE

If you know which swap file needs to be used, you can recover by giving the
swap file name.  Vim will then finds out the name of the original file from
the swap file.

Example:<font color="#e5e5e5"> &gt;</font>
<span class="highlight"><b>        Vim -r .help.txt.swo</b><span>

This is also handy when the swap file is in another directory than expected.
If this still does not work, see what file names Vim reports and rename the
files accordingly.  Check the <span class="highlight"><i>'directory'</i><span> option to see where Vim may have
put the swap file.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        Vim tries to find the swap file by searching the directories in the
        <span class="highlight"><i>'dir'</i><span> option, looking for files that match &quot;filename.sw?&quot;.  If
        wildcard expansion doesn't work (e.g., when the <span class="highlight"><i>'shell'</i><span> option is
        invalid), Vim does a desperate try to find the file &quot;filename.swp&quot;.
        If that fails too, you will have to give the name of the swapfile
        itself to be able to recover the file.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*11.3*</i></b></font></span>  Crashed or not?                                 <span class="highlight"><b><i>*ATTENTION*</i></b><span> <span class="highlight"><b><i>*E325*</i></b><span>

Vim tries to protect you from doing stupid things.  Suppose you innocently
start editing a file, expecting the contents of the file to show up.  Instead,
Vim produces a very long message:

<span class="highlight"><b>                E325: ATTENTION </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        Found a swap file by the name &quot;.main.c.swp&quot; </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                  owned by: mool   dated: Tue May 29 21:09:28 2001 </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                 file name: ~mool/vim/vim6/src/main.c </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                  modified: no </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                 user name: mool   host name: masaka.moolenaar.net </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                process ID: 12559 (still running) </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        While opening file &quot;main.c&quot; </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                     dated: Tue May 29 19:46:12 2001 </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b> </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        (1) Another program may be editing the same file. </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>            If this is the case, be careful not to end up with two </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>            different instances of the same file when making changes. </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>            Quit, or continue with caution. </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b> </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        (2) An edit session for this file crashed. </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>            If this is the case, use &quot;:recover&quot; or &quot;vim -r main.c&quot; </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>            to recover the changes (see &quot;:help recovery&quot;). </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>            If you did this already, delete the swap file &quot;.main.c.swp&quot; </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>            to avoid this message. </b><span><font color="#e5e5e5">~</font>

You get this message, because, when starting to edit a file, Vim checks if a
swap file already exists for that file.  If there is one, there must be
something wrong.  It may be one of these two situations.

1. Another edit session is active on this file.  Look in the message for the
   line with &quot;process ID&quot;.  It might look like this:

<span class="highlight"><b>                process ID: 12559 (still running) </b><span><font color="#e5e5e5">~</font>

   The text &quot;(still running)&quot; indicates that the process editing this file
   runs on the same computer.  When working on a non-Unix system you will not
   get this extra hint.  When editing a file over a network, you may not see
   the hint, because the process might be running on another computer.  In
   those two cases you must find out what the situation is yourself.
      If there is another Vim editing the same file, continuing to edit will
   result in two versions of the same file.  The one that is written last will
   overwrite the other one, resulting in loss of changes.  You better quit
   this Vim.

2. The swap file might be the result from a previous crash of Vim or the
   computer.  Check the dates mentioned in the message.  If the date of the
   swap file is newer than the file you were editing, and this line appears:

<span class="highlight"><b>                modified: YES </b><span><font color="#e5e5e5">~</font>

   Then you very likely have a crashed edit session that is worth recovering.
      If the date of the file is newer than the date of the swap file, it was
   probably changed after the crash.  Perhaps you recovered it earlier, but
   didn't delete the swap file?  Vim will warn you for this with this extra
   line:

<span class="highlight"><b>      NEWER than swap file! </b><span><font color="#e5e5e5">~</font>


WHAT TO DO?

If dialogs are supported you will be asked to select one of five choices:

<span class="highlight"><b>  Swap file &quot;.main.c.swp&quot; already exists! </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>  [O]pen Read-Only, (E)dit anyway, (R)ecover, (Q)uit, (D)elete it: </b><span><font color="#e5e5e5">~</font>

O  Open the file readonly.  Use this when you just want to view the file and
   don't need to recover it.  You might want to use this when you know someone
   else is editing the file, but you just want to look in it and not make
   changes.

E  Edit the file anyway.  Use this with caution!  If the file is being edited
   in another Vim, you might end up with two versions of the file.  Vim will
   try to warn you when this happens, but better be safe then sorry.

R  Recover the file from the swap file.  Use this if you know that the swap
   file contains changes that you want to recover.

Q  Quit.  This avoids starting to edit the file.  Use this if there is another
   Vim editing the same file.
      When you just started Vim, this will exit Vim.  When starting Vim with
   files in several windows, Vim quits only if there is a swap file for the
   first one.  When using an edit command, the file will not be loaded and you
   are taken back to the previously edited file.

D  Delete the swap file.  Use this when you are sure you no longer need it.
   For example, when it doesn't contain changes, or when the file itself is
   newer than the swap file.
      On Unix this choice is only offered when the process that created the
   swap file does not appear to be running.

If you do not get the dialog (you are running a version of Vim that does not
support it), you will have to do it manually.  To recover the file, use this
command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :recover</b><span>


Vim cannot always detect that a swap file already exists for a file.  This is
the case when the other edit session puts the swap files in another directory
or when the path name for the file is different when editing it on different
machines.  Therefore, don't rely on Vim always warning you.

If you really don't want to see this message, you can add the 'A' flag to the
<span class="highlight"><i>'shortmess'</i><span> option.  But it's very unusual that you need this.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*11.4*</i></b><span>  Further reading

<span class="highlight"><i>|swap-file|</i><span>     An explanation about where the swap file will be created and
                what its name is.
<span class="highlight"><i>|:preserve|</i><span>     Manually flushing the swap file to disk.
<span class="highlight"><i>|:swapname|</i><span>     See the name of the swap file for the current file.
<span class="highlight"><i>'updatecount'</i><span>   Number of key strokes after which the swap file is flushed to
                disk.
<span class="highlight"><i>'updatetime'</i><span>    Timeout after which the swap file is flushed to disk.
<span class="highlight"><i>'swapsync'</i><span>      Whether the disk is synced when the swap file is flushed.
<span class="highlight"><i>'directory'</i><span>     List of directory names where to store the swap file.
<span class="highlight"><i>'maxmem'</i><span>        Limit for memory usage before writing text to the swap file.
<span class="highlight"><i>'maxmemtot'</i><span>     Same, but for all files in total.

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_12.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2001 Oct 23


                                Clever tricks


By combining several commands you can make Vim do nearly everything.  In this
chapter a number of useful combinations will be presented.  This uses the
commands introduced in the previous chapters and a few more.

<span class="highlight"><i>|12.1|</i><span>  Replace a word
<span class="highlight"><i>|12.2|</i><span>  Change &quot;Last, First&quot; to &quot;First Last&quot;
<span class="highlight"><i>|12.3|</i><span>  Sort a list
<span class="highlight"><i>|12.4|</i><span>  Reverse line order
<span class="highlight"><i>|12.5|</i><span>  Count words
<span class="highlight"><i>|12.6|</i><span>  Find a man page
<span class="highlight"><i>|12.7|</i><span>  Trim blanks
<span class="highlight"><i>|12.8|</i><span>  Find where a word is used


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*12.1*</i></b><span>  Replace a word

The substitute command can be used to replace all occurrences of a word with
another word:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :%s/four/4/g</b><span>

The &quot;%&quot; range means to replace in all lines.  The &quot;g&quot; flag at the end causes
all words in a line to be replaced.
   This will not do the right thing if your file also contains &quot;thirtyfour&quot;.
It would be replaced with &quot;thirty4&quot;.  To avoid this, use the &quot;\&lt;&quot; item to
match the start of a word:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :%s/\&lt;four/4/g</b><span>

Obviously, this still goes wrong on &quot;fourty&quot;.  Use &quot;\&gt;&quot; to match the end of a
word:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :%s/\&lt;four\&gt;/4/g</b><span>

If you are programming, you might want to replace &quot;four&quot; in comments, but not
in the code.  Since this is difficult to specify, add the &quot;c&quot; flag to have the
substitute command prompt you for each replacement:<font color="#e5e5e5"> &gt;</font>


<span class="highlight"><b>        :%s/\&lt;four\&gt;/4/gc</b><span>


REPLACING IN SEVERAL FILES

Suppose you want to replace a word in more than one file.  You could edit each
file and type the command manually.  It's a lot faster to use record and
playback.
   Let's assume you have a directory with C++ files, all ending in &quot;.cpp&quot;.
There is a function called &quot;GetResp&quot; that you want to rename to &quot;GetAnswer&quot;.

        vim *.cpp               Start Vim, defining the argument list to
                                contain all the C++ files.  You are now in the
                                first file.
        qq                      Start recording into the q register
        :%s/\&lt;GetResp\&gt;/GetAnswer/g
                                Do the replacements in the first file.
        :wnext                  Write this file and move to the next one.
        q                       Stop recording.
        @q                      Execute the q register.  This will replay the
                                substitution and &quot;:wnext&quot;.  You can verify
                                that this doesn't produce an error message.
        999@q                   Execute the q register on the remaining files.

At the last file you will get an error message, because &quot;:wnext&quot; cannot move
to the next file.  This stops the execution, and everything is done.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        When playing back a recorded sequence, an error stops the execution.
        Therefore, make sure you don't get an error message when recording.

There is one catch: If one of the .cpp files does not contain the word
&quot;GetResp&quot;, you will get an error and replacing will stop.  To avoid this, add
the &quot;e&quot; flag to the substitute command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :%s/\&lt;GetResp\&gt;/GetAnswer/ge</b><span>

The &quot;e&quot; flag tells &quot;:substitute&quot; that not finding a match is not an error.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*12.2*</i></b><span>  Change &quot;Last, First&quot; to &quot;First Last&quot;

You have a list of names in this form:

<span class="highlight"><b>        Doe, John </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        Smith, Peter </b><span><font color="#e5e5e5">~</font>

You want to change that to:

<span class="highlight"><b>        John Doe </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        Peter Smith </b><span><font color="#e5e5e5">~</font>

This can be done with just one command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :%s/\([^,]*\), \(.*\)/\2 \1/</b><span>

Let's break this down in parts.  Obviously it starts with a substitute
command.  The &quot;%&quot; is the line range, which stands for the whole file.  Thus
the substitution is done in every line in the file.
   The arguments for the substitute command are &quot;/from/to/&quot;.  The slashes
separate the &quot;from&quot; pattern and the &quot;to&quot; string.  This is what the &quot;from&quot;
pattern contains:
<span class="highlight"><b>                                                        \([^,]*\), \(.*\) </b><span><font color="#e5e5e5">~</font>

        The first part between \( \) matches &quot;Last&quot;     \(     \)
            match anything but a comma                    [^,]
            any number of times                               *
        matches &quot;, &quot; literally                                   ,
        The second part between \( \) matches &quot;First&quot;              \(  \)
            any character                                            .
            any number of times                                       *

In the &quot;to&quot; part we have &quot;\2&quot; and &quot;\1&quot;.  These are called backreferences.
They refer to the text matched by the \( \) parts in the pattern.  &quot;\2&quot; refers
to the text matched by the second &quot;\( \)&quot;, which is the &quot;First&quot; name.  &quot;\1&quot;
refers to the first \( \), which is the &quot;Last&quot; name.
   You can use up to nine backreferences in the &quot;to&quot; part of a substitute
command.  &quot;\0&quot; stands for the whole matched pattern.  There are a few more
special items in a substitute command, see <span class="highlight"><i>|sub-replace-special|</i><span>.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*12.3*</i></b><span>  Sort a list

In a Makefile you often have a list of files.  For example:

<span class="highlight"><b>        OBJS = \ </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                version.o \ </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                pch.o \ </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                getopt.o \ </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                util.o \ </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                getopt1.o \ </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                inp.o \ </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                patch.o \ </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                backup.o </b><span><font color="#e5e5e5">~</font>

To sort this list, filter the text through the external sort command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /^OBJS</b><span>
<span class="highlight"><b>        j</b><span>
<span class="highlight"><b>        :.,/^$/-1!sort</b><span>

This goes to the first line, where &quot;OBJS&quot; is the first thing in the line.
Then it goes one line down and filters the lines until the next empty line.
You could also select the lines in Visual mode and then use &quot;!sort&quot;.  That's
easier to type, but more work when there are many lines.
   The result is this:

<span class="highlight"><b>        OBJS = \ </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                backup.o </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                getopt.o \ </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                getopt1.o \ </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                inp.o \ </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                patch.o \ </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                pch.o \ </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                util.o \ </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                version.o \ </b><span><font color="#e5e5e5">~</font>


Notice that a backslash at the end of each line is used to indicate the line
continues.  After sorting, this is wrong!  The &quot;backup.o&quot; line that was at
the end didn't have a backslash.  Now that it sorts to another place, it
must have a backslash.
   The simplest solution is to add the backslash with &quot;A \<span class="highlight"><i>&lt;Esc&gt;</i><span>&quot;.  You can
keep the backslash in the last line, if you make sure an empty line comes
after it.  That way you don't have this problem again.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*12.4*</i></b><span>  Reverse line order

The <span class="highlight"><i>|:global|</i></font></span> command can be combined with the <span class="highlight"><i>|:move|</i><span> command to move all the
lines before the first line, resulting in a reversed file.  The command is:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :global/^/m 0</b><span>

Abbreviated:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :g/^/m 0</b><span>

The &quot;^&quot; regular expression matches the beginning of the line (even if the line
is blank).  The <span class="highlight"><i>|:move|</i><span> command moves the matching line to after the mythical
zeroeth line, so the current matching line becomes the first line of the file.
As the <span class="highlight"><i>|:global|</i><span> command is not confused by the changing line numbering,
<span class="highlight"><i>|:global|</i><span> proceeds to match all remaining lines of the file and puts each as
the first.

This also works on a range of lines.  First move to above the first line and
mark it with &quot;mt&quot;.  Then move the cursor to the last line in the range and
type:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :'t+1,.g/^/m 't</b><span>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*12.5*</i></b><span>  Count words

Sometimes you have to write a text with a maximum number of words.  Vim can
count the words for you.
   When the whole file is what you want to count the words in, use this
command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        g CTRL-G</b><span>

Do not type a space after the g, this is just used here to make the command
easy to read.
   The output looks like this:

<span class="highlight"><b>        Col 1 of 0; Line 141 of 157; Word 748 of 774; Byte 4489 of 4976 </b><span><font color="#e5e5e5">~</font>

You can see on which word you are (748), and the total number of words in the
file (774).

When the text is only part of a file, you could move to the start of the text,
type &quot;g <span class="highlight"><i>CTRL-G</i></font></span>&quot;, move to the end of the text, type &quot;g <span class="highlight"><i>CTRL-G</i><span>&quot; again, and then
use your brain to compute the difference in the word position.  That's a good
exercise, but there is an easier way.  With Visual mode, select the text you
want to count words in.  Then type g <span class="highlight"><i>CTRL-G</i><span>.  The result:

<span class="highlight"><b>        Selected 5 of 293 Lines; 70 of 1884 Words; 359 of 10928 Bytes </b><span><font color="#e5e5e5">~</font>

For other ways to count words, lines and other items, see <span class="highlight"><i>|count-items|</i><span>.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*12.6*</i></b><span>  Find a man page

While editing a shell script or C program, you are using a command or function
that you want to find the man page for (this is on Unix).  Let's first use a
simple way: Move the cursor to the word you want to find help on and press<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        K</b><span>

Vim will run the external &quot;man&quot; program on the word.  If the man page is
found, it is displayed.  This uses the normal pager to scroll through the text
(mostly the &quot;more&quot; program).  When you get to the end pressing <span class="highlight"><i>&lt;Enter&gt;</i><span> will
get you back into Vim.

A disadvantage is that you can't see the man page and the text you are working
on at the same time.  There is a trick to make the man page appear in a Vim
window.  First, load the man filetype plugin:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :source $VIMRUNTIME/ftplugin/man.vim</b><span>

Put this command in your vimrc file if you intend to do this often.  Now you
can use the &quot;:Man&quot; command to open a window on a man page:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :Man csh</b><span>

You can scroll around and the text is highlighted.  This allows you to find
the help you were looking for.  Use <span class="highlight"><i>CTRL-W</i><span> w to jump to the window with the
text you were working on.
   To find a man page in a specific section, put the section number first.
For example, to look in section 3 for &quot;echo&quot;:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :Man 3 echo</b><span>

To jump to another man page, which is in the text with the typical form
&quot;word(1)&quot;, press <span class="highlight"><i>CTRL-]</i><span> on it.  Further &quot;:Man&quot; commands will use the same
window.

To display a man page for the word under the cursor, use this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        \K</b><span>

(If you redefined the <span class="highlight"><i>&lt;Leader&gt;</i><span>, use it instead of the backslash).
For example, you want to know the return value of &quot;strstr()&quot; while editing
this line:

<span class="highlight"><b>        if (strstr(input, &quot;aap&quot;) == ) </b><span><font color="#e5e5e5">~</font>

Move the cursor to somewhere on &quot;strstr&quot; and type &quot;\K&quot;.  A window will open
to display the man page for strstr().

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*12.7*</i></b><span>  Trim blanks

Some people find spaces and tabs at the end of a line useless, wasteful, and
ugly.  To remove whitespace at the end of every line, execute the following
command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :%s/\s\+$//</b><span>

The line range &quot;%&quot; is used, thus this works on the whole file.  The pattern
that the &quot;:substitute&quot; command matches with is &quot;\s\+$&quot;.  This finds white
space characters (\s), 1 or more of them (\+), before the end-of-line ($).
Later will be explained how you write patterns like this <span class="highlight"><i>|usr_27.txt|</i><span>.
   The &quot;to&quot; part of the substitute command is empty: &quot;//&quot;.  Thus it replaces
with nothing, effectively deleting the matched white space.

Another wasteful use of spaces is placing them before a Tab.  Often these can
be deleted without changing the amount of white space.  But not always!
Therefore, you can best do this manually.  Use this search command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /       </b><span>

You cannot see it, but there is a space before a tab in this command.  Thus
it's &quot;/<span class="highlight"><i>&lt;Space&gt;&lt;Tab&gt;</i><span>&quot;.   Now use &quot;x&quot; to delete the space and check that the
amount of white space doesn't change.  You might have to insert a Tab if it
does change.  Type &quot;n&quot; to find the next match.  Repeat this until no more
matches can be found.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*12.8*</i></b><span>  Find where a word is used

If you are a UNIX user, you can use a combination of Vim and the grep command
to edit all the files that contain a given word.  This is extremely useful if
you are working on a program and want to view or edit all the files that
contain a specific variable.
   For example, suppose you want to edit all the C program files that contain
the word &quot;frame_counter&quot;.  To do this you use the command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        vim `grep -l frame_counter *.c`</b><span>

Let's look at this command in detail.  The grep command searches through a set
of files for a given word.  Because the -l argument is specified, the command
will only list the files containing the word and not print the matching lines.
The word it is searching for is &quot;frame_counter&quot;.  Actually, this can be any
regular expression.  (<span class="highlight"><b><i><u>Note</u></i></b><span>: What grep uses for regular expressions is not
exactly the same as what Vim uses.)
   The entire command is enclosed in backticks (`).  This tells the UNIX shell
to run this command and pretend that the results were typed on the command
line.  So what happens is that the grep command is run and produces a list of
files, these files are put on the Vim command line.  This results in Vim
editing the file list that is the output of grep.  You can then use commands
like &quot;:next&quot; and &quot;:first&quot; to browse through the files.


FINDING EACH LINE

The above command only finds the files in which the word is found.  You still
have to find the word within the files.
   Vim has a built-in command that you can use to search a set of files for a
given string.  If you want to find all occurrences of &quot;error_string&quot; in all C
program files, for example, enter the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :grep error_string *.c</b><span>

This causes Vim to search for the string &quot;error_string&quot; in all the specified
files (*.c).  The editor will now open the first file where a match is found
and position the cursor on the first matching line.  To go to the next
matching line (no matter in what it is file), use the &quot;:cnext&quot; command.  To go
to the previous match, use the &quot;:cprev&quot; command.  Use &quot;:clist&quot; to see all the
matches and where they are.
   The &quot;:grep&quot; command uses the external commands grep (on Unix) or findstr
(on Windows).  You can change this by setting the option <span class="highlight"><i>'grepprg'</i><span>.

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_20.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2002 Mar 04


                     Typing command-line commands quickly


Vim has a few generic features that makes it easier to enter commands.  Colon
commands can be abbreviated, edited and repeated.  Completion is available for
nearly everyting.

<span class="highlight"><i>|20.1|</i><span>  Command line editing
<span class="highlight"><i>|20.2|</i><span>  Command line abbreviations
<span class="highlight"><i>|20.3|</i><span>  Command line completion
<span class="highlight"><i>|20.4|</i><span>  Command line history
<span class="highlight"><i>|20.5|</i><span>  Command line window


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*20.1*</i></b><span>  Command line editing

When you use a colon (:) command or search for a string with / or ?, Vim puts
the cursor on the bottom of the screen.  There you type the command or search
pattern.  This is called the Command line.  Also when it's used for entering a
search command.

The most obvious way to edit the command you type is by pressing the <span class="highlight"><i>&lt;BS&gt;</i><span> key.
This erases the character before the cursor.  To erase another character,
typed earlier, first move the cursor with the cursor keys.
   For example, you have typed this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :s/col/pig/</b><span>

Before you hit Enter, you notice that &quot;col&quot; should be &quot;cow&quot;.  To correct this,
you type <span class="highlight"><i>&lt;Left&gt;</i></font></span> five times.  The cursor is now just after &quot;col&quot;.  Type &quot;<span class="highlight"><i>&lt;BS&gt;</i><span>
and &quot;w&quot; to correct:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :s/cow/pig/</b><span>

Now you can press <span class="highlight"><i>&lt;Enter&gt;</i><span> directly.  You don't have to move the cursor to the
end of the line before executing the command.

The most often used keys to move around in the command line:

        <span class="highlight"><i>&lt;Left&gt;</i><span>                  one character left
        <span class="highlight"><i>&lt;Right&gt;</i><span>                 one character right
        <span class="highlight"><i>&lt;S-Left&gt;</i></font></span> or <span class="highlight"><i>&lt;C-Left&gt;</i><span>    one word left
        <span class="highlight"><i>&lt;S-Right&gt;</i></font></span> or <span class="highlight"><i>&lt;C-Right&gt;</i><span>  one word right
        <span class="highlight"><i>CTRL-B</i></font></span> or <span class="highlight"><i>&lt;Home&gt;</i><span>        to begin of command line
        <span class="highlight"><i>CTRL-E</i></font></span> or <span class="highlight"><i>&lt;End&gt;</i><span>         to end of command line

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        <span class="highlight"><i>&lt;S-Left&gt;</i></font></span> (cursor left key with Shift key pressed) and <span class="highlight"><i>&lt;C-Left&gt;</i><span> (cursor
        left key with Control pressed) will not work on all keyboards.  Same
        for the other Shift and Control combinations.

You can also use the mouse to move the cursor.


DELETING

As mentioned, <span class="highlight"><i>&lt;BS&gt;</i><span> deletes the character before the cursor.  To delete a whole
word use <span class="highlight"><i>CTRL-W</i><span>.

<span class="highlight"><b>        /the fine pig </b><span><font color="#e5e5e5">~</font>

                     <span class="highlight"><i>CTRL-W</i><span>

<span class="highlight"><b>        /the fine </b><span><font color="#e5e5e5">~</font>

<span class="highlight"><i>CTRL-U</i><span> removes all text, thus allows you to start all over again.


OVERSTRIKE

The <span class="highlight"><i>&lt;Insert&gt;</i><span> key toggles between inserting characters and replacing the
existing ones.  Start with this text:

<span class="highlight"><b>        /the fine pig </b><span><font color="#e5e5e5">~</font>

Move the cursor to the start of &quot;fine&quot; with <span class="highlight"><i>&lt;S-Left&gt;</i></font></span> twice (or <span class="highlight"><i>&lt;Left&gt;</i><span> eight
times, if <span class="highlight"><i>&lt;S-Left&gt;</i></font></span> doesn't work).  Now press <span class="highlight"><i>&lt;Insert&gt;</i><span> to switch to overstrike
and type &quot;great&quot;:

<span class="highlight"><b>        /the greatpig </b><span><font color="#e5e5e5">~</font>

Oops, we lost the space.  Now, don't use <span class="highlight"><i>&lt;BS&gt;</i><span>, because it would delete the
&quot;t&quot; (this is different from Replace mode).  Instead, press <span class="highlight"><i>&lt;Insert&gt;</i><span> to switch
from overstrike to inserting, and type the space:

<span class="highlight"><b>        /the great pig </b><span><font color="#e5e5e5">~</font>


CANCELLING

You thought of executing a : or / command, but changed your mind.  To get rid
of what you already typed, without executing it, press <span class="highlight"><i>CTRL-C</i></font></span> or <span class="highlight"><i>&lt;Esc&gt;</i><span>.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        <span class="highlight"><i>&lt;Esc&gt;</i><span> is the universal &quot;get out&quot; key.  Unfortunately, in the good old
        Vi pressing <span class="highlight"><i>&lt;Esc&gt;</i><span> in a command line executed the command!  Since that
        might be considered to be a bug, Vim uses <span class="highlight"><i>&lt;Esc&gt;</i><span> to cancel the command.
        But with the <span class="highlight"><i>'cpoptions'</i><span> option it can be made Vi compatible.  And
        when using a mapping (which might be written for Vi) <span class="highlight"><i>&lt;Esc&gt;</i><span> also works
        Vi compatible.  Therefore, using <span class="highlight"><i>CTRL-C</i><span> is a method that always works.

If you are at the start of the command line, pressing <span class="highlight"><i>&lt;BS&gt;</i><span> will cancel the
command.  It's like deleting the &quot;:&quot; or &quot;/&quot; that the line starts with.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*20.2*</i></b><span>  Command line abbreviations

Some of the &quot;:&quot; commands are really long.  We already mentioned that
&quot;:substitute&quot; can be abbreviated to &quot;:s&quot;.  This is a generic mechanism, all
&quot;:&quot; commands can be abbreviated.

How short can a command get?  There are 26 letters, and many more commands.
For example, &quot;:set&quot; also starts with &quot;:s&quot;, but &quot;:s&quot; doesn't start a &quot;:set&quot;
command.  Instead &quot;:set&quot; can be abbreviated to &quot;:se&quot;.
   When the shorter form of a command could be used for two commands, it
stands for only one of them.  There is no logic behind which one, you have to
learn them.  In the help files the shortest form that works is mentioned.  For
example:

        :s[ubstitute]

This means that the shortest form of &quot;:substitute&quot; is &quot;:s&quot;.  The following
characters are optional.  Thus &quot;:su&quot; and &quot;:sub&quot; also work.

In the user manual we will either use the full name of command, or a short
version that is still readable.  For example, &quot;:function&quot; can be abbreviated
to &quot;:fu&quot;.  But since most people don't understand what that stands for, we
will use &quot;:fun&quot;.  (Vim doesn't have a &quot;:funny&quot; command, otherwise &quot;:fun&quot; would
be confusing too.)

It is recommended that in Vim scripts you write the full command name.  That
makes it easier to read back when you make later changes.  Except for some
often used commands like &quot;:w&quot; (&quot;:write&quot;) and &quot;:r&quot; (&quot;:read&quot;).
   A particularly confusing one is &quot;:end&quot;, which could stand for &quot;:endif&quot;,
&quot;:endwhile&quot; or &quot;:endfunction&quot;.  Therefore, always use the full name.


SHORT OPTION NAMES

In the user manual the long version of the option names is used.  Many options
also have a short name.  Unlike &quot;:&quot; commands, there is only one short name
that works.  For example, the short name of <span class="highlight"><i>'autoindent'</i></font></span> is <span class="highlight"><i>'ai'</i><span>.  Thus these
two commands do the same thing:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set autoindent</b><span>
<span class="highlight"><b>        :set ai</b><span>

You can find the full list of long and short names here: <span class="highlight"><i>|option-list|</i><span>.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*20.3*</i></b><span>  Command line completion

This is one of those Vim features that, by itself, is a reason to switch from
Vi to Vim.  Once you have used this, you can't do without.

Suppose you have a directory that contains these files:

        info.txt
        intro.txt
        bodyofthepaper.txt

To edit the last one, you use the command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :edit bodyofthepaper.txt</b><span>

It's easy to type this wrong.  A much quicker way is:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :edit b&lt;Tab&gt;</b><span>

Which will result in the same command.  What happened?  The <span class="highlight"><i>&lt;Tab&gt;</i><span> key does
completion of the word before the cursor.  In this case &quot;b&quot;.  Vim looks in the
directory and finds only one file that starts with a &quot;b&quot;.  That must be the
one you are looking for, thus Vim completes the file name for you.

Now type:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :edit i&lt;Tab&gt;</b><span>

Vim will beep, and give you:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :edit info.txt</b><span>

The beep means that Vim has found more than one match.  It then uses the first
match it found (alphabetically).  If you press <span class="highlight"><i>&lt;Tab&gt;</i><span> again, you get:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :edit intro.txt</b><span>

Thus, if the first <span class="highlight"><i>&lt;Tab&gt;</i><span> doesn't give you the file you were looking for, press
it again.  If there are more matches, you will see them all, one at a time.
   If you press <span class="highlight"><i>&lt;Tab&gt;</i><span> on the last matching entry, you will go back to what you
first typed:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :edit i</b><span>

Then it starts all over again.  Thus Vim cycles through the list of matches.
Use <span class="highlight"><i>CTRL-P</i><span> to go through the list in the other direction:

              &lt;------------------- <span class="highlight"><i>&lt;Tab&gt;</i><span> -------------------------+
                                                                  |
                  <span class="highlight"><i>&lt;Tab&gt;</i></font></span> --&gt;                    <span class="highlight"><i>&lt;Tab&gt;</i><span> --&gt;
        :edit i               :edit info.txt               :edit intro.txt
                  &lt;-- <span class="highlight"><i>CTRL-P</i></font></span>                   &lt;-- <span class="highlight"><i>CTRL-P</i><span>
           |
           +---------------------- <span class="highlight"><i>CTRL-P</i><span> ------------------------&gt;


CONTEXT

When you type &quot;:set i&quot; instead of &quot;:edit i&quot; and press <span class="highlight"><i>&lt;Tab&gt;</i><span> you get:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set icon</b><span>

Hey, why didn't you get &quot;:set info.txt&quot;?  That's because Vim has context
sensitive completion.  The kind of words Vim will look for depends on the
command before it.  Vim knows that you cannot use a file name just after a
&quot;:set&quot; command, but you can use an option name.
   Again, if you repeat typing the <span class="highlight"><i>&lt;Tab&gt;</i><span>, Vim will cycle through all matches.
There are quite a few, it's better to type more characters first:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set isk&lt;Tab&gt;</b><span>

Gives:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set iskeyword</b><span>

Now type &quot;=&quot; and press <span class="highlight"><i>&lt;Tab&gt;</i><span>:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set iskeyword=@,48-57,_,192-255</b><span>

What happens here is that Vim inserts the old value of the option.  Now you
can edit it.
   What is completed with <span class="highlight"><i>&lt;Tab&gt;</i><span> is what Vim expects in that place.  Just try
it out to see how it works.  In some situations you will not get what you
want.  That's either because Vim doesn't know what you want, or because
completion was not implemented for that situation.  In that case you will get
a <span class="highlight"><i>&lt;Tab&gt;</i><span> inserted (displayed as ^I).


LIST MATCHES

When there are many matches, you would like to see an overview.  Do this by
pressing <span class="highlight"><i>CTRL-D</i></font></span>.  For example, pressing <span class="highlight"><i>CTRL-D</i><span> after:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set is</b><span>

results in:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set is</b><span>
<span class="highlight"><b>        incsearch  isfname    isident    iskeyword  isprint</b><span>
<span class="highlight"><b>        :set is</b><span>

Vim lists the matches and then comes back with the text you typed.  You can
now check the list for the item you wanted.  If it isn't there, you can use
<span class="highlight"><i>&lt;BS&gt;</i><span> to correct the word.  If there are many matches, type a few more
characters before pressing <span class="highlight"><i>&lt;Tab&gt;</i><span> to complete the rest.
   If you have watched carefully, you will have noticed that &quot;incsearch&quot;
doesnt' start with &quot;is&quot;.  In this case &quot;is&quot; stands for the short name of
&quot;incsearch&quot;. (Many options have a short and a long name.)  Vim is clever
enough to know that you might have wanted to expand the short name of the
option into the long name.


THERE IS MORE

The <span class="highlight"><i>CTRL-L</i><span> command completes the word to the longest unambiguous string.  If
you type &quot;:edit i&quot; and there are files &quot;info.txt&quot; and &quot;info_backup.txt&quot; you
will get &quot;:edit info&quot;.

The <span class="highlight"><i>'wildmode'</i><span> option can be used to change the way completion works.
The <span class="highlight"><i>'wildmenu'</i><span> option can be used to get a menu-like list of matches.
Use the <span class="highlight"><i>'suffixes'</i><span> option to specify files that are less important and appear
at the end of the list of files.
The <span class="highlight"><i>'wildignore'</i><span> option specifies files that are not listed at all.

More about all of this here: <span class="highlight"><i>|cmdline-completion|</i><span>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*20.4*</i></b><span>  Command line history

In chapter 3 we briefly mentioned the history.  The basics are that you can
use the <span class="highlight"><i>&lt;Up&gt;</i></font></span> key to recall an older command line.  <span class="highlight"><i>&lt;Down&gt;</i><span> then takes you back
to newer commands.

There are actually four histories.  The ones we will mention here are for &quot;:&quot;
commands and for &quot;/&quot; and &quot;?&quot; search commands.  The &quot;/&quot; and &quot;?&quot; commands share
the same history, because they are both search commands.  The two other
histories are for expressions and input lines for the input() function.
<span class="highlight"><i>|cmdline-history|</i><span>

Suppose you have done a &quot;:set&quot; command, typed ten more colon commands and then
want to repeat that &quot;:set&quot; command again.  You could press &quot;:&quot; and then ten
times <span class="highlight"><i>&lt;Up&gt;</i><span>.  There is a quicker way:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :se&lt;Up&gt;</b><span>

Vim will now go back to the previous command that started with &quot;se&quot;.  You have
a good chance that this is the &quot;:set&quot; command you were looking for.  At least
you should not have to press <span class="highlight"><i>&lt;Up&gt;</i><span> very often (unless &quot;:set&quot; commands is all
you have done).

The <span class="highlight"><i>&lt;Up&gt;</i><span> key will use the text typed so far and compare it with the lines in
the history.  Only matching lines will be used.
   If you do not find the line you were looking for, use <span class="highlight"><i>&lt;Down&gt;</i><span> to go back to
what you typed and correct that.  Or use <span class="highlight"><i>CTRL-U</i><span> to start all over again.

To see all the lines in the history:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :history</b><span>

That's the history of &quot;:&quot; commands.  The search history is displayed with this
command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :history /</b><span>

In case you don't want to use the cursor keys, <span class="highlight"><i>CTRL-P</i></font></span> will do the same as <span class="highlight"><i>&lt;Up&gt;</i><span>
and <span class="highlight"><i>CTRL-N</i></font></span> as <span class="highlight"><i>&lt;Down&gt;</i></font></span>.  <span class="highlight"><i>CTRL-P</i><span> stands for previous, <span class="highlight"><i>CTRL-N</i><span> for next.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*20.5*</i></b><span>  Command line window

Typing the text in the command line works different from typing text in Insert
mode.  It doesn't allow many commands to change the text.  For most commands
that's OK, but sometimes you have to type a complicated command.  That's where
the command line window is useful.

Open the command line window with this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        q:</b><span>

Vim now opens a (small) window at the bottom.  It contains the command line
history, and an empty line at the end:

        +-------------------------------------+
        |other window                         |
        |~                                    |
        |file.txt=============================|
        |:e c                                 |
        |:e config.h.in                       |
        |:set path=.,/usr/include,,           |
        |:set iskeyword=@,48-57,_,192-255     |
        |:set is                              |
        |:q                                   |
        |:                                    |
        |command-line=========================|
        |                                     |
        +-------------------------------------+

You are now in Normal mode.  You can use the &quot;hjkl&quot; keys to move around.  For
example, move up with &quot;5k&quot; to the &quot;:e config.h.in&quot; line.  Type &quot;$h&quot; to go to
the &quot;i&quot; of &quot;in&quot; and type &quot;cwout&quot;.  Now you have changed the line to:

<span class="highlight"><b>        :e config.h.out </b><span><font color="#e5e5e5">~</font>

Now press <span class="highlight"><i>&lt;Enter&gt;</i><span> and this command will be executed.  The command line window
will close.
   The <span class="highlight"><i>&lt;Enter&gt;</i><span> command will execute the line under the cursor.  It doesn't
matter whether Vim is in Insert mode or in Normal mode.
   Changes in the command line window are lost.  They do not result in the
history to be changed.  Except that the command you execute will be added to
the end of the history, like with all executed commands.

The command line window is very useful when you want to have overview of the
history, lookup a similar command, change it a bit and execute it.  A search
command can be used to find something.
   In the previous example the &quot;?config&quot; search command could have been used
to find the previous command that contains &quot;config&quot;.  It's a bit strange,
because you are using a command line to search in the command line window.
While typing that search command you can't open another command line window,
there can only be one.

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_21.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2001 Sep 03


                           Go away and come back


This chapter goes into mixing the use of other programs with Vim.  Either by
executing program from inside Vim or by leaving Vim and coming back later.
Furthermore, this is about the ways to remember the state of Vim and restore
it later.

<span class="highlight"><i>|21.1|</i><span>  Suspend and resume
<span class="highlight"><i>|21.2|</i><span>  Executing shell commands
<span class="highlight"><i>|21.3|</i><span>  Remembering information; viminfo
<span class="highlight"><i>|21.4|</i><span>  Sessions
<span class="highlight"><i>|21.5|</i><span>  Views
<span class="highlight"><i>|21.6|</i><span>  Modelines


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*21.1*</i></b><span>  Suspend and resume

Like most Unix programs Vim can be suspended by pressing <span class="highlight"><i>CTRL-Z</i><span>.  This stops
Vim and takes you back to the shell it was started in.  You can then do any
other commands until you are bored with them.  Then bring back Vim with the
&quot;fg&quot; command.<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        CTRL-Z</b><span>
<span class="highlight"><b>        {any sequence of shell commands}</b><span>
<span class="highlight"><b>        fg</b><span>

You are right back where you left Vim, nothing has changed.
   In case pressing <span class="highlight"><i>CTRL-Z</i><span> doesn't work, you can also use &quot;:suspend&quot;.
Don't forget to bring Vim back to the foreground, you would lose any changes
that you made!

Only Unix has support for this.  On other systems Vim will start a shell for
you.  This also has the functionality of being able to execute shell commands.
But it's a new shell, not the one that you started Vim from.
   When you are running the GUI you can't go back to the shell where Vim was
started.  <span class="highlight"><i>CTRL-Z</i><span> will minimize the Vim window instead.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*21.2*</i></b><span>  Executing shell commands

To execute a single shell command from Vim use &quot;:!<span class="highlight"><i>{command}</i><span>&quot;.  For example, to
see a directory listing:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :!ls</b><span>
<span class="highlight"><b>        :!dir</b><span>

The first one is for Unix, the second one for MS-Windows.
   Vim will execute the program.  When it ends you will get a prompt to hit
<span class="highlight"><i>&lt;Enter&gt;</i><span>.  This allows you to have a look at the output from the command before
returning to the text you were editing.
   The &quot;!&quot; is also used in other places where a program is run.  Let's take
a look at an overview:

        :!<span class="highlight"><i>{program}</i></font></span>             execute <span class="highlight"><i>{program}</i><span>
        :r !<span class="highlight"><i>{program}</i></font></span>           execute <span class="highlight"><i>{program}</i><span> and read its output
        :w !<span class="highlight"><i>{program}</i></font></span>           execute <span class="highlight"><i>{program}</i><span> and send text to its input
        :<span class="highlight"><i>[range]</i></font></span>!<span class="highlight"><i>{program}</i><span>      filter text through <span class="highlight"><i>{program}</i><span>

Notice that the precense of a range before &quot;!<span class="highlight"><i>{program}</i><span>&quot; makes a big
difference.  Without it executes the program normally, with the range a number
of text lines is filtered through the program.

Executing a whole row of programs this way is possible.  But a shell is much
better at it.  You can start a new shell this way:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :shell</b><span>

This is similar to using <span class="highlight"><i>CTRL-Z</i><span> to suspend Vim.  The difference is that a new
shell is started.

When using the GUI the shell will be using the Vim window for its input and
output.  Since Vim is not a terminal emulator, this will not work perfectly.
If you have trouble, try toggling the <span class="highlight"><i>'guipty'</i><span> option.  If this still doesn't
work well enough, start a new terminal to run the shell in.  For example with:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        :!xterm&amp;</b><span>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*21.3*</i></b><span>  Remembering information; viminfo

After editing for a while you will have text in registers, marks in various
files, a command line history filled with carefully crafted commands.  When
you exit Vim all of this is lost.  But you can get it back!

The viminfo file is designed to store status information:

        Command-line and Search pattern history
        Text in registers
        Marks for various files
        The buffer list
        Global variables

Each time you exit Vim it will store this information in a file, the viminfo
file.  When Vim starts again, the viminfo file is read and the information
restored.

The <span class="highlight"><i>'viminfo'</i><span> option is set by default to restore a limited number of items.
You might want to set it to remember more information.  This is done through
the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set viminfo=string</b><span>

The string specifies what to save.  The syntax of this string is an option
character followed by an argument.  The option/argument pairs are separated by
commas.
   Take a look at how you can build up your own viminfo string.  First, the '
option is used to specify how many files for which you save marks (a-z).  Pick
a nice even number for this option (1000, for instance).  Your command now
looks like this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set viminfo='1000</b><span>

The f option controls whether global marks (A-Z and 0-9) are stored.  If this
option is 0, none are stored. If it is 1 or you do not specify an f option,
the marks are stored.  You want this feature, so now you have this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set viminfo='1000,f1</b><span>

The &quot; option controls how many lines are saved for each of the registers.  By
default, all the lines are saved.  If 0, nothing is saved.  To avoid adding
thousands of lines to your viminfo file (which might never get used and makes
starting Vim slower) you use a maximum of 500 lines:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set viminfo='1000,f1,\&quot;500</b><span>
<font color="#e5e5e5">&lt;</font>
        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        Since the &quot; character starts a comment, it must be preceded with a
        backslash.

Other options you might want to use:
        :       number of lines to save from the command line history
        @       number of lines to save from the input line history
        /       number of lines to save from the search history
        r       removable media, for which no marks will be stored (can be
                used several times)
        !       global variables that start with an uppercase letter and
                don't contain lowercase letters
        h       disable <span class="highlight"><i>'hlsearch'</i><span> highlighting when starting
        %       the buffer list (only restored when starting Vim without file
                arguments)
        c       convert the text using <span class="highlight"><i>'encoding'</i><span>
        n       name used for the viminfo file (must be the last option)

See the <span class="highlight"><i>'viminfo'</i></font></span> option and <span class="highlight"><i>|viminfo-file|</i><span> for more information.

When you run Vim multiple times, the last one exiting will store its
information.  This may cause information that previously exiting Vims stored
to be lost.  Each item can be remembered only once.


GETTING BACK TO WHERE YOU WERE

You are halfway editing a file and it's time to leave for holidays.  You exit
Vim and go enjoy yourselves, forgetting all about your work.  After a couple
of weeks you start Vim, and type:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        '0</b><span>

And you are right back where you left Vim.  So you can get on with your work.
   Vim creates a mark each time you exit Vim.  The last one is '0.  The
postion that '0 pointed to is made '1.  And '1 is made to '2, and so forth.
Mark '9 is lost.
   The &quot;:marks&quot; command is useful to find out where '0 to '9 will take you.


MOVE INFO FROM ONE VIM TO ANOTHER

You can use the &quot;:wviminfo&quot; and &quot;:rviminfo&quot; commands to save and restore the
information while still running Vim.  This is useful for exchanging register
contents between two instances of Vim, for example.  In the first Vim do:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :wviminfo! ~/tmp/viminfo</b><span>

And in the second Vim do:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :rviminfo! ~/tmp/viminfo</b><span>

Obviously, the &quot;w&quot; stands for &quot;write&quot; and the &quot;r&quot; for &quot;read&quot;.
   The ! character is used by &quot;:wviminfo&quot; to forcefully overwrite an existing
file.  When it is omitted, and the file exists, the information is merged into
the file.
   The ! character used for &quot;:rviminfo&quot; means that all the information is
used, this may overwrite existing information.  Without the ! only information
that wasn't set is used.
   These commands can also be used to store info and use it again later.  You
could make a directory full of viminfo files, each containing info for a
different purpose.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*21.4*</i></b><span>  Sessions

Suppose you are editing along, and it is the end of the day.  You want to quit
work and pick up where you left off the next day.  You can do this by saving
your editing session and restoring it the next day.
   A Vim session contains all the information about what you are editing.
This includes things such as the file list, window layout, global variables,
options and other information. (Exactly what is remembered is controlled by
the <span class="highlight"><i>'sessionoptions'</i><span> option, described below.)
   The following command creates a session file:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :mksession vimbook.vim</b><span>

Later if you want to restore this session, you can use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :source vimbook.vim</b><span>

If you want to start Vim and restore a specific session, you can use the
following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        vim -S vimbook.vim</b><span>

This tells Vim to read a specific file on startup.  The 'S' stands for
session (actually, you can source any Vim script with -S, thus it might as
well stand for &quot;source&quot;).

The windows that were open are restored, with the same position and size as
before.  Mappings and option values are like before.
   What exactly is restored depends on the <span class="highlight"><i>'sessionoptions'</i><span> option.  The
default value is &quot;blank,buffers,curdir,folds,help,options,winsize&quot;.

        blank           keep empty windows
        buffers         all buffers, not only the ones in a window
        curdir          the current directory
        folds           folds, also manually created ones
        help            the help window
        options         all options and mappings
        winsize         window sizes

Change this to your liking.  To also restore the size of the Vim window, for
example, use:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set sessionoptions+=resize</b><span>


SESSION HERE, SESSION THERE

The obvious way to use sessions is when working on different projects.
Suppose you store you session files in the directory &quot;~/.vim&quot;.  You are
currently working on the &quot;secret&quot; project and have to switch to the &quot;boring&quot;
project:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :wall</b><span>
<span class="highlight"><b>        :mksession! ~/.vim/secret.vim</b><span>
<span class="highlight"><b>        :source ~/.vim/boring.vim</b><span>

This first uses &quot;:wall&quot; to write all modified files.  Then the current session
is saved, using &quot;:mksession!&quot;.  This overwrites the previous session.  The
next time you load the secret session you can continue where you were at this
point.  And finally you load the new &quot;boring&quot; session.

If you open help windows, split and close various window, and generally mess
up the window layout, you can go back to the last saved session:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :source ~/.vim/boring.vim</b><span>

Thus you have complete control over whether you want to continue next time
where you are now, by saving the current setup in a session, or keep the
session file as a starting point.
   Another way of using sessions is to create a window layout that you like to
use, and save this in a session.  Then you can go back to this layout whenever
you want.
   For example, this is a nice layout to use:

        +----------------------------------------+
        |                  VIM - main help file  |
        |                                        |
        |Move around:  Use the cursor keys, or &quot;h|
        |help.txt================================|
        |explorer   |                            |
        |dir        |~                           |
        |dir        |~                           |
        |file       |~                           |
        |file       |~                           |
        |file       |~                           |
        |file       |~                           |
        |~/=========|[No File]===================|
        |                                        |
        +----------------------------------------+

This has a help window at the top, so that you can read this text.  The narrow
vertical window on the left contains a file explorer.  This is a Vim plugin
that lists the contents of a directory.  You can select files to edit there.
More about this in the next chapter.
   Create this from a just started Vim with:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :help</b><span>
<span class="highlight"><b>        CTRL-W w</b><span>
<span class="highlight"><b>        :vertical split ~/</b><span>

You can resize the windows a bit to your liking.  Then save the session with:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        :mksession ~/.vim/mine.vim</b><span>

Now you can start Vim with this layout:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        vim -S ~/.vim/mine.vim</b><span>

Hint: To open a file you see listed in the explorer window in the empty
window, move the cursor to the filename and press &quot;O&quot;.  Double clicking with
the mouse will also do this.


UNIX AND MS-WINDOWS

Some people have to do work on MS-Windows systems one day and on Unix another
day.  If you are one of them, consider adding &quot;slash&quot; and &quot;unix&quot; to
<span class="highlight"><i>'sessionoptions'</i><span>.  The session files will then be written in a format that can
be used on both systems.  This is the command to put in your vimrc file:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set sessionoptions+=unix,slash</b><span>

Vim will use the Unix format then, because the MS-Windows Vim can read and
write Unix files, but Unix Vim can't read MS-Windows format session files.
Similarly, MS-Windows Vim understands file names with / to separate names, but
Unix Vim doesn't understand \.


SESSIONS AND VIMINFO

Sessions store many things, but not the position of marks, contents of
registers and the command line history.  You need to use the viminfo feature
for these things.
   In most situations you will want to use sessions separately from viminfo.
This can be used to switch to another session, but keep the command line
history.  And yank text into registers in one session, and paste it back in
another session.
   You might prefer to keep the info with the session.  You will have to do
this yourself then.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :mksession! ~/.vim/secret.vim</b><span>
<span class="highlight"><b>        :wviminfo! ~/.vim/secret.viminfo</b><span>

And to restore this again:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :source ~/.vim/secret.vim</b><span>
<span class="highlight"><b>        :rviminfo! ~/.vim/secret.viminfo</b><span>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*21.5*</i></b><span>  Views

A session stores the looks of the whole of Vim.  When you want to store the
properties for one window only, use a view.
   The use of a view is for when you want to edit a file in a specific way.
For example, you have line numbers enabled with the <span class="highlight"><i>'number'</i><span> option and
defined a few folds.  Just like with sessions, you can remember this view on
the file and restore it later.  Actually, when you store a session, it stores
the view of each window.
   There are two basic ways to use views.  The first is to let Vim pick a name
for the view file.  You can restore the view when you later edit the same
file.  To store the view for the current window:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :mkview</b><span>

Vim will decide where to store the view.  When you later edit the same file
you get the view back with this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :loadview</b><span>

That's easy, isn't it?
   Now you want to view the file without the <span class="highlight"><i>'number'</i><span> option on, or with all
folds open, you can set the options to make the window look that way.  Then
store this view with:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :mkview 1</b><span>

Obviously, you can get this back with:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :loadview 1</b><span>

Now you can switch between the two views on the file by using &quot;:loadview&quot; with
and without the &quot;1&quot; argument.
   You can store up to ten views for the same file this way, one unnumbered
and nine numbered 1 to 9.


A VIEW WITH A NAME

The second basic way to use views is by storing the view in a file with a name
you chose.  This view can be loaded while editing another file.  Vim will then
switch to editing the file specified in the view.  Thus you can use this to
quickly switch to editing another file, with all its options set as you saved
them.
   For example, to save the view of the current file:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :mkview ~/.vim/main.vim</b><span>

You can restore it with:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :source ~/.vim/main.vim</b><span>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*21.6*</i></b><span>  Modelines

When editing a specific file, you might set options specifically for that
file.  Typing these commands each time is boring.  Using a session or view for
editing a file doesn't work when sharing the file between several people.
   The solution for this situation is adding a modeline to the file.  This is
a line of text that tells Vim the values of options, to be used in this file
only.
   A typical example is a C program where you make indents by a multiple of 4
spaces.  This requires setting the <span class="highlight"><i>'shiftwidth'</i><span> option to 4.  This modeline
will do that:

<span class="highlight"><b>        /* vim:set shiftwidth=4: */ </b><span><font color="#e5e5e5">~</font>

Put this line as one of the first or last five lines in the file.  When
editing the file, you will notice that <span class="highlight"><i>'shiftwidth'</i><span> will have been set to
four.  When editing another file, it's set back to the default value of eight.
   For some files the modeline fits well in the header, thus it can be put at
the top of the file.  For text files and other files where the modeline gets
in the way of the normal contents, put it at the end of the file.

The <span class="highlight"><i>'modelines'</i><span> option specifies how many lines at the start and end of the
file are inspected for containing a modeline.  To inspect ten lines:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set modelines=10</b><span>

The <span class="highlight"><i>'modeline'</i><span> option can be used to switch this off.  Do this when you are
working as root or don't trust the files you are editing:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set nomodeline</b><span>

Use this format for the modeline:

<span class="highlight"><b>        any-text vim:set {option}={value} ... : any-text </b><span><font color="#e5e5e5">~</font>

The &quot;any-text&quot; indicates that you can put any text before and after the part
that Vim will use.  This allows making it look like a comment, like what was
done above with /* and */.
   The &quot; vim:&quot; part is what makes Vim recognize this line.  The must be white
space before &quot;vim&quot;, or &quot;vim&quot; must be at the start of the line.  Thus using
something like &quot;gvim:&quot; will not work.
   The part between the colons is a &quot;:set&quot; command.  It works the same way as
typing the &quot;:set&quot; command, except that you need to insert a backslash before a
colon (otherwise it would be seen as the end of the modeline).

Another example:

<span class="highlight"><b>        // vim:set textwidth=72 dir=c\:\tmp:  use c:\tmp here </b><span><font color="#e5e5e5">~</font>

There is an extra backslash before the first colon, so that it's included in
the &quot;:set&quot; command.  The text after the second colon is ignored, thus a remark
can be placed there.

For more details see <span class="highlight"><i>|modeline|</i><span>.

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_22.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2001 Sep 03


                           Finding the file to edit


Files can be found everywhere.  So how do you find them?  Vim offers various
ways to browse the directory tree.  There are commands to jump to a file that
is mentioned in another.  And Vim remembers which files have been edited
before.

<span class="highlight"><i>|22.1|</i><span>  The file explorer
<span class="highlight"><i>|22.2|</i><span>  The current directory
<span class="highlight"><i>|22.3|</i><span>  Finding a file
<span class="highlight"><i>|22.4|</i><span>  The buffer list


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*22.1*</i></b><span>  The file explorer

Vim has a plugin that makes it possible to edit a directory.  Try this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :edit .</b><span>

Through the magic of autocommands and Vim scripts, the window will be filled
with the contents of the directory.  It looks like this:

<span class="highlight"><b>        &quot; Press ? for keyboard shortcuts </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        &quot; Sorted by name (.bak,~,.o,.h,.info,.swp,.obj,.orig,.rej at end of list) </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        &quot;= /home/mool/vim/vim6/runtime/doc/ </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        ../ </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        check/ </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        Makefile </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        autocmd.txt </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        change.txt </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        eval.txt~ </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        filetype.txt~ </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        help.txt.info </b><span><font color="#e5e5e5">~</font>

You can see these items:
1.  A comment about using ? to get help for the functionality of the file
    explorer.
2.  The second line mentions how the items in the directory are listed.  They
    can be sorted in several ways.
3.  The third line is the name of the current directory.
4.  The &quot;../&quot; directory item.  This is the parent directory.
5.  The directory names.
6.  The ordinary file names.  As mentioned in the second line, some are not
    here but &quot;at the end of the list&quot;.
7.  The less ordinary file names.  You are expected to use these less often,
    therefore they have been moved to the end.

If you have syntax highlighting enabled, the different parts are highlighted
to make it easier to spot them.

You can use Normal mode Vim commands to move around in the text.  For example,
move to a file and press <span class="highlight"><i>&lt;Enter&gt;</i><span>.  Now you are editing that file.  To go back
to the explorer use &quot;:edit .&quot; again.  <span class="highlight"><i>CTRL-O</i><span> also works.
   Try using <span class="highlight"><i>&lt;Enter&gt;</i><span> while the cursor is on a directory name.  The result is
that the explorer moves into that directory and displays the items found
there.  Pressing <span class="highlight"><i>&lt;Enter&gt;</i><span> on the first directory &quot;../&quot; moves you one level
higher.  Pressing &quot;-&quot; does the same thing, without the need to move to the
&quot;../&quot; item first.

You can press ? to get short help on the things you can do in the explorer.
This is what you get:

<span class="highlight"><b>        &quot; &lt;enter&gt; : open file or directory </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        &quot; o : open new window for file/directory </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        &quot; O : open file in previously visited window </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        &quot; p : preview the file </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        &quot; i : toggle size/date listing </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        &quot; s : select sort field    r : reverse sort </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        &quot; - : go up one level      c : cd to this dir </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        &quot; R : rename file          D : delete file </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        &quot; :help file-explorer for detailed help </b><span><font color="#e5e5e5">~</font>

The first few commands are for selecting a file to display.  Depending on what
command you use, the file appears somewhere:

        <span class="highlight"><i>&lt;Enter&gt;</i><span>         Uses the current window.
        o               Opens a new window.
        O               Uses the previously visited window.
        p               Uses the preview window, and moves the cursor back
                        into the explorer window. <span class="highlight"><i>|preview-window|</i><span>

The following commands are used to display other information:

        i               Display the size and date for the file.  Using i again
                        will hide the information.
        s               Use the field the cursor is in to sort on.  First
                        display the size and date with i.  Then Move the
                        cursor to the size of any file and press s.  The files
                        will now be sorted on size.  Press s wile the cursor
                        is on a date and the items will be sorted on date.
        r               reverse the sorting order (either size or date)

There are a few extra commands:

        c               Change the current directory to the displayed
                        directory.  You can then type an &quot;:edit&quot; command for
                        one of the files without prepending the path.
        R               Rename the file under the cursor.  You will be
                        prompted for the new name.
        D               Delete the file under the cursor.  You will get a
                        prompt to confirm this.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*22.2*</i></b><span>  The current directory

Just like the shell, Vim has the concept of a current directory.  Suppose you
are in your home directory and want to edit several files in a directory
&quot;VeryLongFileName&quot;.  You could do:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :edit VeryLongFileName/file1.txt</b><span>
<span class="highlight"><b>        :edit VeryLongFileName/file2.txt</b><span>
<span class="highlight"><b>        :edit VeryLongFileName/file3.txt</b><span>

To avoid much of the typing, do this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :cd VeryLongFileName</b><span>
<span class="highlight"><b>        :edit file1.txt</b><span>
<span class="highlight"><b>        :edit file2.txt</b><span>
<span class="highlight"><b>        :edit file3.txt</b><span>

The &quot;:cd&quot; command changes the current directory.  You can see what the current
directory is with the &quot;:pwd&quot; command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :pwd</b><span>
<span class="highlight"><b>        /home/Bram/VeryLongFileName</b><span>

Vim remembers the last directory that you used.  Use &quot;cd -&quot; to go back to it.
Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :pwd</b><span>
<span class="highlight"><b>        /home/Bram/VeryLongFileName</b><span>
<span class="highlight"><b>        :cd /etc</b><span>
<span class="highlight"><b>        :pwd</b><span>
<span class="highlight"><b>        /etc</b><span>
<span class="highlight"><b>        :cd -</b><span>
<span class="highlight"><b>        :pwd</b><span>
<span class="highlight"><b>        /home/Bram/VeryLongFileName</b><span>
<span class="highlight"><b>        :cd -</b><span>
<span class="highlight"><b>        :pwd</b><span>
<span class="highlight"><b>        /etc</b><span>


WINDOW LOCAL DIRECTORY

When you split a window, both windows use the same current directory.  When
you want to edit a number of files somewhere else in the new window, you can
make it use a different directory, without changing the current directory in
the other window.  This is called a local directory.<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :pwd</b><span>
<span class="highlight"><b>        /home/Bram/VeryLongFileName</b><span>
<span class="highlight"><b>        :split</b><span>
<span class="highlight"><b>        :lcd /etc</b><span>
<span class="highlight"><b>        :pwd</b><span>
<span class="highlight"><b>        /etc</b><span>
<span class="highlight"><b>        CTRL-W w</b><span>
<span class="highlight"><b>        :pwd</b><span>
<span class="highlight"><b>        /home/Bram/VeryLongFileName</b><span>

So long as no &quot;:lcd&quot; command has been used, all windows share the same current
directory.  Doing a &quot;:cd&quot; command in one window will also change the current
directory of the other window.
   For a window where &quot;:lcd&quot; has been used a different current directory is
remembered.  Using &quot;:cd&quot; or &quot;:lcd&quot; in other windows will not change it.
   When using a &quot;:cd&quot; command in a window that uses a different current
directory, it will go back to using the shared directory.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*22.3*</i></b><span>  Finding a file

You are editing a C program that contains this line:

<span class="highlight"><b>        #include &quot;inits.h&quot; </b><span><font color="#e5e5e5">~</font>

You want to see what is in that &quot;inits.h&quot; file.  Move the cursor on the name
of the file and type:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        gf</b><span>

Vim will find the file and edit it.
   What if the file is not in the current directory?  Vim will use the <span class="highlight"><i>'path'</i><span>
option to find the file.  This option is a list of directory names where to
look for your file.
   Suppose you have your include files located in &quot;c:/prog/include&quot;.  This
command will add it to the <span class="highlight"><i>'path'</i><span> option:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set path+=c:/prog/include</b><span>

This directory is an absolute path.  No matter where you are, it will be the
same place.  What if you have located files in a subdirectory, below where the
file is?  Then you can specify a relative path name.  This starts with a dot:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        :set path+=./proto</b><span>

This tells Vim to look in the directory &quot;proto&quot;, below the directory where the
file in which you use &quot;gf&quot; is.  Thus using &quot;gf&quot; on &quot;inits.h&quot; will make Vim
look for &quot;proto/inits.h&quot;, starting in the directory of the file.
   Without the &quot;./&quot;, thus &quot;proto&quot;, Vim would look in the &quot;proto&quot; directory
below the current directory.  And the current directory might not be where the
file that you are editing is located.

The <span class="highlight"><i>'path'</i><span> option allows specifying the directories where to search for files
in many more ways.  See the help on the <span class="highlight"><i>'path'</i><span> option.
   The <span class="highlight"><i>'isfname'</i><span> option is used to decide which characters are included in the
file name, and which ones are not (e.g., the &quot; character in the example
above).

When you know the file name, but it's not to be found in the file, you can
type it:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :find inits.h</b><span>

Vim will then use the <span class="highlight"><i>'path'</i><span> option to try and locate the file.  This is the
same as the &quot;:edit&quot; command, except for the use of <span class="highlight"><i>'path'</i><span>.

To open the found file in a new window use <span class="highlight"><i>CTRL-W</i><span> f instead of &quot;gf&quot;, or use
&quot;:sfind&quot; instead of &quot;:find&quot;.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*22.4*</i></b><span>  The buffer list

The Vim editor uses the term buffer to describe a file being edited.
Actually, a buffer is a copy of the file that you edit.  When you finish
changing the buffer, you write the contents of the buffer to the file.
Buffers not only contain file contents, but also all the marks, settings, and
other stuff that goes with it.


HIDDEN BUFFERS

Suppose you are editing the file one.txt and need to edit the file two.txt.
You could simply use &quot;:edit two.txt&quot;, but since you made changes to one.txt
that won't work.  You also don't want to write one.txt yet.  Vim has a
solution for you:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :hide edit two.txt</b><span>

The buffer &quot;one.txt&quot; disappears from the screen, but Vim still knows that you
are editing this buffer, so it keeps the modified text.  This is called a
hidden buffer: The buffer contains text, but you can't see it.
   The &quot;:hide&quot; command argument is another command.  It makes that command
behave like the <span class="highlight"><i>'hidden'</i><span> option was set.  You could also set this option
yourself.  The effect is that when any buffer is abandoned, it becomes hidden.
   Be careful!  When you have hidden buffers with changes, don't exit Vim
without making sure you have saved all the buffers.


INACTIVE BUFFERS

   When a buffer has been used once, Vim remembers some information about it.
When it is not displayed in a window and it is not hidden, it is still in the
buffer list.  This is called an inactive buffer.  Overview:

   Active               Appears in a window, text loaded.
   Hidden               Not in a window, text loaded.
   Inactive             Not in a window, no text loaded.

The inactive buffers are remembered, because Vim keeps information about them,
like marks.  And remembering the file name is useful too, so that you can see
which files you have edited.  And edit them again.


LISTING BUFFERS

View the buffer list with this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :buffers</b><span>

A command which does the same, is not so obvious to list buffers, but is much
shorter to type:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :ls</b><span>

The output could look like this:

<span class="highlight"><b>  1 #h  &quot;help.txt&quot;                      line 62 </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>  2 %l+ &quot;usr_21.txt&quot;                    line 1 </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>  3     &quot;usr_toc.txt&quot;                   line 1 </b><span><font color="#e5e5e5">~</font>

The first column contains the buffer number.  You can use this to edit the
buffer without having to type the name, see below.
   After the buffer number come the flags.  Then the name of the file
and the line number where the cursor was the last time.
   The flags that can appear are these (from left to right):

        u       Buffer is unlisted <span class="highlight"><i>|unlisted-buffer|</i><span>.
         %      Current buffer.
         #      Alternate buffer.
          l     Buffer is loaded and displayed.
          h     Buffer is loaded but hidden.
           =    Buffer is read-only.
           -    Buffer is not modifiable, the <span class="highlight"><i>'modifiable'</i><span> option is off.
            +   Buffer has been modified.


EDITING A BUFFER

You can edit a buffer by its number.  That avoids having to type the file
name:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :buffer 2</b><span>

But the only way to know the number is by looking in the buffer list.  You can
use the name, or part of it, instead:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :buffer help</b><span>

Vim will find a best match for the name you type.  If there is only one
buffer that matches the name, it will be used.  In this case &quot;help.txt&quot;.
   To open a buffer in a new window:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :sbuffer 3</b><span>

This works with a name as well.


USING THE BUFFER LIST

You can move around in the buffer list with these commands:

        :bnext          go to next buffer
        :bprevious      go to previous buffer
        :bfirst         go to the first buffer
        :blast          go to the last buffer

To remove a buffer from the list, use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :bdelete 3</b><span>

Again, this also works with a name.
   If you delete a buffer that was active (visible in a window), that window
will be closed.  If you delete the current buffer, the current window will be
closed.  If it was the last window, Vim will find another buffer to edit.  You
can't be editing nothing!

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        Even after removing the buffer with &quot;:bdelete&quot; Vim still remembers it.
        It's actually made &quot;unlisted&quot;, it no longer appears in the list from
        &quot;:buffers&quot;.  The &quot;:buffers!&quot; command will list unlisted buffers (yes,
        Vim can do the impossible).  To really make Vim forget about a buffer,
        use &quot;:bwipe&quot;.  Also see the <span class="highlight"><i>'buflisted'</i><span> option.

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_23.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2001 Sep 03


                             Editing other files


This chapter is about editing files that are not ordinary files.  With Vim you
can edit files that are compressed or encrypted.  Some files need to be
accessed over the internet.  With some restrictions, binary files can be
edited as well.

<span class="highlight"><i>|23.1|</i><span>  DOS, Mac and Unix files
<span class="highlight"><i>|23.2|</i><span>  Files on the internet
<span class="highlight"><i>|23.3|</i><span>  Encryption
<span class="highlight"><i>|23.4|</i><span>  Binary files
<span class="highlight"><i>|23.5|</i><span>  Compressed files


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*23.1*</i></b><span>  DOS, Mac and Unix files

Back in the early days, the old Teletype machines used two characters to
start a new line.  One to move the carriage back to the first position
(carriage return, <span class="highlight"><i>&lt;CR&gt;</i></font></span>), another to move the paper up (line feed, <span class="highlight"><i>&lt;LF&gt;</i><span>).
   When computers came out, storage was expensive.  Some people decided that
they did not need two characters for end-of-line.  The UNIX people decided
they could use &lt;Line Feed&gt; only for end-of-line.  The Apple people
standardized on <span class="highlight"><i>&lt;CR&gt;</i><span>.  The MS-DOS (and Microsoft Windows) folks decided to
keep the old <span class="highlight"><i>&lt;CR&gt;&lt;LF&gt;</i><span>.
   This means that if you try to move a file from one system to another, you
have line-break problems.  The Vim editor automatically recognizes the
different file formats and handles things properly behind your back.
   The option <span class="highlight"><i>'fileformats'</i><span> contains the various formats that will be tried
when a new file is edited.  The following command, for example, tells Vim to
try UNIX format first and MS-DOS format second:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set fileformats=unix,dos</b><span>

You will notice the format in the message you get when editing a file.  You
don't see anything if you edit a native file format.  Thus editing a Unix file
on Unix won't result in a remark.  But when you edit a dos file, Vim will
notify you of this:

<span class="highlight"><b>        &quot;/tmp/test&quot; [dos] 3L, 71C </b><span><font color="#e5e5e5">~</font>

For a Mac file you would see &quot;[mac]&quot;.
   The detected file format is stored in the <span class="highlight"><i>'fileformat'</i><span> option.  To see
which format you have, execute the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set fileformat?</b><span>

The three names that Vim uses are:

        unix            <span class="highlight"><i>&lt;LF&gt;</i><span>
        dos             <span class="highlight"><i>&lt;CR&gt;&lt;LF&gt;</i><span>
        mac             <span class="highlight"><i>&lt;CR&gt;</i><span>


USING THE MAC FORMAT

On Unix, <span class="highlight"><i>&lt;LF&gt;</i></font></span> is used to break a line.  It's not unusual to have a <span class="highlight"><i>&lt;CR&gt;</i><span>
character halfway a line.  Incidentally, this happens quite often in Vi (and
Vim) scripts.
   On the Macintosh, where <span class="highlight"><i>&lt;CR&gt;</i><span> is the line break character, it's possible to
have a <span class="highlight"><i>&lt;LF&gt;</i><span> character halfway a line.
   The result is that it's not possible to be 100% sure whether a file
containing both <span class="highlight"><i>&lt;CR&gt;</i></font></span> and <span class="highlight"><i>&lt;LF&gt;</i><span> characters is a Mac or a Unix file.  Therefore,
Vim assumes that on Unix you probably won't edit a Mac file, and doesn't check
for this type of file.  To check for this format anyway, add &quot;mac&quot; to
<span class="highlight"><i>'fileformats'</i><span>:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set fileformats+=mac</b><span>

Then Vim will take a guess at the file format.  Watch out for situations where
Vim guesses wrong.


OVERRULING THE FORMAT

If you use the good old Vi and try to edit an MS-DOS format file, you will
find that each line ends with a ^M character. (^M is <span class="highlight"><i>&lt;CR&gt;</i><span>).  The automatic
detection avoids this.  Suppose you do want to edit the file that way?  Then
you need to overrule the format:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :edit ++ff=unix file.txt</b><span>

The &quot;++&quot; string is an item that tells Vim that an option name follows, which
overrules the default for this single command.  &quot;++ff&quot; is used for
<span class="highlight"><i>'fileformat'</i><span>.  You could also use &quot;++ff=mac&quot; or &quot;++ff=dos&quot;.
   This doesn't work for any option, only &quot;++ff&quot; and &quot;++enc&quot; are currently
implemented.  The full names &quot;++fileformat&quot; and &quot;++encoding&quot; also work.


CONVERSION

You can use the <span class="highlight"><i>'fileformat'</i><span> option to convert from one file format to
another.  Suppose, for example, that you have an MS-DOS file named README.TXT
that you want to convert to UNIX format.  Start by editing the MS-DOS format
file:<font color="#e5e5e5"> &gt;</font>
<span class="highlight"><b>        vim README.TXT</b><span>

Vim will recognize this as a dos format file.  Now change the file format to
UNIX:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set fileformat=unix</b><span>
<span class="highlight"><b>        :write</b><span>

The file is written in Unix format.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*23.2*</i></b><span>  Files on the internet

Someone sends you an e-mail message, which refers to a file by its URL.  For
example:

<span class="highlight"><b>        You can find the information here: </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                ftp://ftp.vim.org/pub/vim/README </b><span><font color="#e5e5e5">~</font>

You could start a program to download the file, save it on your local disk and
then start Vim to edit it.
   There is a much simpler way.  Move the cursor to any character of the URL.
Then use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        gf</b><span>

With a bit of luck, Vim will figure out which program to use for downloading
the file, download it and edit the copy.  To open the file in a new window use
<span class="highlight"><i>CTRL-W</i><span> f.
   If something goes wrong you will get an error message.  It's possible that
the URL is wrong, you don't have permission to read it, the network connection
is down, etc.  Unfortunately, it's hard to tell the cause of the error.  You
might want to try the manual way of downloading the file.

Accessing files over the internet works with the netrw plugin.  Currently URLs
with these formats are recognized:

        ftp://          uses ftp
        rcp://          uses rcp
        scp://          uses scp
        http://         uses wget (reading only)

Vim doesn't do the communication itself, it relies on the mentioned programs
to be available on your computer.  On most Unix systems &quot;ftp&quot; and &quot;rcp&quot; will
be present.  &quot;scp&quot; and &quot;wget&quot; might need to be installed.

Vim detects these URLs for each command that starts editing a new file, also
with &quot;:edit&quot; and &quot;:split&quot;, for example.  Write commands also work, except for
http://.

For more information, also about passwords, see <span class="highlight"><i>|netrw|</i><span>.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*23.3*</i></b><span>  Encryption

Some information you prefer to keep to yourself.  For example, when writing
a test on a computer that students also use.  You don't want clever students
to figure out a way to read the questions before the exam starts.  Vim can
encrypt the file for you, which gives you some protection.
   To start editing a new file with encryption, use the &quot;-x&quot; argument to start
Vim.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        vim -x exam.txt</b><span>

Vim prompts you for a key used for encrypting and decrypting the file:

<span class="highlight"><b>        Enter encryption key: </b><span><font color="#e5e5e5">~</font>

Carefully type the secret key now.  You cannot see the characters you type,
they will be replaced by stars.  To avoid the situation that a typing mistake
will cause trouble, Vim asks you to enter the key again:

<span class="highlight"><b>        Enter same key again: </b><span><font color="#e5e5e5">~</font>

You can now edit this file normally and put in all your secrets.  When you
finish editing the file and tell Vim to exit, the file is encrypted and
written.
   When you edit the file with Vim, it will ask you to enter the same key
again.  You don't need to use the &quot;-x&quot; argument.  You can also use the normal
&quot;:edit&quot; command.  Vim adds a magic string to the file by which it recognizes
that the file was encrypted.
   If you try to view this file using another program, all you get is garbage.
Also, if you edit the file with Vim and enter the wrong key, you get garbage.
Vim does not have a mechanism to check if the key is the right one (this makes
it much harder to break the key).


SWITCHING ENCRYPTION ON AND OFF

To disable the encryption of a file, set the <span class="highlight"><i>'key'</i><span> option to an empty string:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        :set key=</b><span>

The next time you write the file this will be done without encryption.
   Setting the <span class="highlight"><i>'key'</i><span> option to enable encryption is not a good idea, because
the password appears in the clear.  Anyone shoulder-surfing can read your
password.
   To avoid this problem, the &quot;:X&quot; command was created.  It asks you for an
encryption key, just like the &quot;-x&quot; argument did:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :X</b><span>
<span class="highlight"><b>        Enter encryption key: ******</b><span>
<span class="highlight"><b>        Enter same key again: ******</b><span>


LIMITS ON ENCRYPTION

The encryption algorithm used by Vim is weak.  It is good enough to keep out
the casual prowler, but not good enough to keep out a cryptology expert with
lots of time on his hands.  Also you should be aware that the swap file is not
encrypted; so while you are editing, people with superuser privileges can read
the unencrypted text from this file.
   One way to avoid letting people read your swap file is to avoid using one.
If the -n argument is supplied on the command line, no swap file is used
(instead, Vim puts everything in memory).  For example, to edit the encrypted
file &quot;file.txt&quot; without a swap file use the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        vim -x -n file.txt</b><span>

When already editing a file, the swapfile can be disabled with:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :setlocal noswapfile</b><span>

Since there is no swapfile, recovery will be impossible.  Save the file a bit
more often to avoid the risk of losing your changes.

While the file is in memory, it is in plain text.  Anyone with privilege can
look in the editor's memory and discover the contents of the file.
   If you use a viminfo file, be aware that the contents of text registers are
written out in the clear as well.
   If you really want to secure the contents of a file, edit it only on a
portable computer not connected to a network, use good encryption tools, and
keep the computer locked up in a big safe when not in use.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*23.4*</i></b><span>  Binary files

You can edit binary files with Vim.  Vim wasn't really made for this, thus
there are a few restrictions.  But you can read a file, change a character and
write it back, with the result that only that one character was changed and
the file is identical otherwise.
   To make sure that Vim does not use its clever tricks in the wrong way, add
the &quot;-b&quot; argument when starting Vim:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        vim -b datafile</b><span>

This sets the <span class="highlight"><i>'binary'</i><span> option.  The effect of this is that unexpected side
effects are turned off.  For example, <span class="highlight"><i>'textwidth'</i><span> is set to zero, to avoid
automatic formatting of lines.  And files are always read in Unix file format.

Binary mode can be used to change a message in a program.  Be careful not to
insert or delete any characters, it would stop the program from working.  Use
&quot;R&quot; to enter replace mode.

Many characters in the file will be unprintable.  To see them in Hex format:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set display=uhex</b><span>

Otherwise, the &quot;ga&quot; command can be used to see the value of the character
under the cursor.  The output, when the cursor is on an <span class="highlight"><i>&lt;Esc&gt;</i><span>, looks like
this:

<span class="highlight"><b>        &lt;^[&gt;  27,  Hex 1b,  Octal 033 </b><span><font color="#e5e5e5">~</font>

There might not be many line breaks in the file.  To get some overview switch
the <span class="highlight"><i>'wrap'</i><span> option off:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set nowrap</b><span>


BYTE POSITION

To see on which byte you are in the file use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        g CTRL-G</b><span>

The output is verbose:

<span class="highlight"><b>    Col 9-16 of 9-16; Line 277 of 330; Word 1806 of 2058; Byte 10580 of 12206 </b><span><font color="#e5e5e5">~</font>

The last two numbers are the byte position in the file and the total number of
bytes.  This takes into account how <span class="highlight"><i>'fileformat'</i><span> changes the number of bytes
that a line break uses.
    To move to a specific byte in the file, use the &quot;go&quot; command.  For
example, to move to byte 2345:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        2345go</b><span>


USING XXD

A real binary editor shows the text in two ways: as it is and in hex format.
You can do this in Vim by first converting the file with the &quot;xxd&quot; program.
This comes with Vim.
   First edit the file in binary mode:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        vim -b datafile</b><span>

Now convert the file to a hex dump with xxd:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :%!xxd</b><span>

The text will look like this:

<span class="highlight"><b>        0000000: 1f8b 0808 39d7 173b 0203 7474 002b 4e49  ....9..;..tt.+NI </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        0000010: 4b2c 8660 eb9c ecac c462 eb94 345e 2e30  K,.`.....b..4^.0 </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        0000020: 373b 2731 0b22 0ca6 c1a2 d669 1035 39d9  7;'1.&quot;.....i.59. </b><span><font color="#e5e5e5">~</font>

You can now view and edit the text as you like.  Vim treats the information as
ordinary text.  Changing the hex does not cause the printable character to be
changed, or the other way around.
   Finally convert it back with:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        :%!xxd -r</b><span>

Only changes in the hex part are used.  Changes in the printable text part on
the right are ignored.

See the manual page of xxd for more information.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*23.5*</i></b><span>  Compressed files

This is easy: You can edit a compressed file just like any other file.  The
&quot;gzip&quot; plugin takes care of decompressing the file when you edit it.  And
compressing it again when you write it.
   These compression methods are currently supported:

        .Z      compress
        .gz     gzip
        .bz2    bzip2

Vim uses the mentioned programs to do the actual compression and
decompression.  You might need to install the programs first.

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_24.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2001 Sep 27


                             Inserting quickly


When entering text, Vim offers various ways to reduce the number of keystrokes
and avoid typing mistakes.  Use Insert mode completion to repeat previously
typed words.  Abbreviate long words to short ones.  Type characters that
aren't on your keyboard.

<span class="highlight"><i>|24.1|</i><span>  Making corrections
<span class="highlight"><i>|24.2|</i><span>  Showing matches
<span class="highlight"><i>|24.3|</i><span>  Completion
<span class="highlight"><i>|24.4|</i><span>  Repeating an insert
<span class="highlight"><i>|24.5|</i><span>  Copying from another line
<span class="highlight"><i>|24.6|</i><span>  Inserting a register
<span class="highlight"><i>|24.7|</i><span>  Abbreviations
<span class="highlight"><i>|24.8|</i><span>  Entering special characters
<span class="highlight"><i>|24.9|</i><span>  Digraphs
<span class="highlight"><i>|24.10|</i><span> Normal mode commands


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*24.1*</i></b><span>  Making corrections

The <span class="highlight"><i>&lt;BS&gt;</i><span> key was already mentioned.  It deletes the character just before the
cursor.  The <span class="highlight"><i>&lt;Del&gt;</i><span> key does the same for the character under (after) the
cursor).
   When you typed a whole word wrong, use <span class="highlight"><i>CTRL-W</i><span>:

<span class="highlight"><b>        The horse had fallen to the sky </b><span><font color="#e5e5e5">~</font>
                                       <span class="highlight"><i>CTRL-W</i><span>
<span class="highlight"><b>        The horse had fallen to the </b><span><font color="#e5e5e5">~</font>

If you really messed up a line and want to start over, use <span class="highlight"><i>CTRL-U</i><span> to delete
it.  This keeps the text after the cursor and the indent.  Only the text from
the first non-blank to the cursor is deleted.  With the cursor on the &quot;f&quot; of
&quot;fallen&quot; in the next line pressing <span class="highlight"><i>CTRL-U</i><span> does this:

<span class="highlight"><b>        The horse had fallen to the </b><span><font color="#e5e5e5">~</font>
                      <span class="highlight"><i>CTRL-U</i><span>
<span class="highlight"><b>        fallen to the </b><span><font color="#e5e5e5">~</font>

When you spot a mistake a few words back, you need to move the cursor there to
correct it.  For example, you typed this:

<span class="highlight"><b>        The horse had follen to the ground </b><span><font color="#e5e5e5">~</font>

You need to change &quot;follen&quot; to &quot;fallen&quot;.  With the cursor at the end, you
would type this to correct it:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>                                        &lt;Esc&gt;4blraA</b><span>

<font color="#e5e5e5">&lt;</font>       get out of Insert mode          <span class="highlight"><i>&lt;Esc&gt;</i><span>
        four words back                      4b
        move on top of the &quot;o&quot;                 l
        replace with &quot;a&quot;                        ra
        restart Insert mode                       A

Another way to do this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>                &lt;C-Left&gt;&lt;C-Left&gt;&lt;C-Left&gt;&lt;C-Left&gt;&lt;Right&gt;&lt;Del&gt;a&lt;End&gt;</b><span>

<font color="#e5e5e5">&lt;</font>       four words back              <span class="highlight"><i>&lt;C-Left&gt;&lt;C-Left&gt;&lt;C-Left&gt;&lt;C-Left&gt;</i><span>
        move on top of the &quot;o&quot;                  <span class="highlight"><i>&lt;Right&gt;</i><span>
        delete the &quot;o&quot;                                 <span class="highlight"><i>&lt;Del&gt;</i><span>
        insert an &quot;a&quot;                                       a
        go to end of the line                                <span class="highlight"><i>&lt;End&gt;</i><span>

This uses special keys to move around, while remaining in Insert mode.  This
resembles what you would do in a modeless editor.  It's easier to remember,
but takes more time (you have to move your hand from the letters to the cursor
keys, and the <span class="highlight"><i>&lt;End&gt;</i><span> key is hard to press without looking at the keyboard).
   These special keys are most useful when writing a mapping that doesn't
leave Insert mode.  The extra typing doesn't matter then.
   An overview of the keys you can use in Insert mode:

        <span class="highlight"><i>&lt;C-Home&gt;</i><span>        to start of the file
        <span class="highlight"><i>&lt;PageUp&gt;</i><span>        a whole screenful up
        <span class="highlight"><i>&lt;Home&gt;</i><span>          to start of line
        <span class="highlight"><i>&lt;S-Left&gt;</i><span>        one word left
        <span class="highlight"><i>&lt;C-Left&gt;</i><span>        one word left
        <span class="highlight"><i>&lt;S-Right&gt;</i><span>       one word right
        <span class="highlight"><i>&lt;C-Right&gt;</i><span>       one word right
        <span class="highlight"><i>&lt;End&gt;</i><span>           to end of the line
        <span class="highlight"><i>&lt;PageDown&gt;</i><span>      a whole screenful down
        <span class="highlight"><i>&lt;C-End&gt;</i><span>         to end of the file

There are a few more, see <span class="highlight"><i>|ins-special-special|</i><span>.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*24.2*</i></b><span>  Showing matches

When you type a ) it would be nice to see with which ( it matches.  To make
Vim do that use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set showmatch</b><span>

When you now type a text like &quot;(example)&quot;, as soon as you type the ) Vim will
briefly move the cursor to the matching (, keep it there for half a second,
and move back to where you were typing.
   In case there is not matching (, Vim will beep.  Then you know that you
might have forgotten the ( somewhere, or typed a ) too many.
   The match will also be shown for [] and {} pairs.  You don't have to wait
with typing the next character, as soon as Vim sees it the cursor will move
back and inserting continues as before.
   You can change the time Vim waits with the <span class="highlight"><i>'matchtime'</i><span> option.  For
example, to make Vim wait one and a half second:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set matchtime=15</b><span>

The time is specified in tenths of a second.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*24.3*</i></b><span>  Completion

Vim can automatically complete words on insertion.  You type the first part of
a word, press <span class="highlight"><i>CTRL-P</i><span>, and Vim guesses the rest.
   Suppose, for example, that you are creating a C program and want to type in
the following:

<span class="highlight"><b>        total = ch_array[0] + ch_array[1] + ch_array[2]; </b><span><font color="#e5e5e5">~</font>

You start by entering the following:

<span class="highlight"><b>        total = ch_array[0] + ch_ </b><span><font color="#e5e5e5">~</font>

At this point, you tell Vim to complete the word using the command <span class="highlight"><i>CTRL-P</i><span>.
Vim searches for a word that starts with what's in front of the cursor.  In
this case, it is &quot;ch_&quot;, which matches with the word ch_array.  So typing
<span class="highlight"><i>CTRL-P</i><span> gives you the following:

<span class="highlight"><b>        total = ch_array[0] + ch_array </b><span><font color="#e5e5e5">~</font>

After a little more typing, you get this (ending in a space):

<span class="highlight"><b>        total = ch_array[0] + ch_array[1] +  </b><span><font color="#e5e5e5">~</font>

If you now type <span class="highlight"><i>CTRL-P</i><span> Vim will search again for a word that completes the
word before the cursor.  Since there is nothing in front of the cursor, it
finds the first word backwards, which is &quot;ch_array&quot;.  Typing <span class="highlight"><i>CTRL-P</i><span> again
gives you the next word that matches, in this case &quot;total&quot;.  A third <span class="highlight"><i>CTRL-P</i><span>
searches further back.  If there is nothing else, it causes the editor to run
out of words, so it returns to the original text, which is nothing.  A fourth
<span class="highlight"><i>CTRL-P</i><span> causes the editor to start over again with &quot;ch_array&quot;.

To search forward, use <span class="highlight"><i>CTRL-N</i><span>.  Since the search wraps around the end of the
file, <span class="highlight"><i>CTRL-N</i></font></span> and <span class="highlight"><i>CTRL-P</i><span> will find the same matches, but in a different
sequence.  Hint: <span class="highlight"><i>CTRL-N</i></font></span> is Next-match and <span class="highlight"><i>CTRL-P</i><span> is Previous-match.

The Vim editor goes through a lot of effort to find words to complete.  By
default, it searches the following places:

        1. Current file
        2. Files in other windows
        3. Other loaded files (hidden buffers)
        4. Files which are not loaded (inactive buffers)
        5. Tag files
        6. All files #included by the current file


OPTIONS

You can customize the search order with the <span class="highlight"><i>'complete'</i><span> option.

The <span class="highlight"><i>'ignorecase'</i><span> option is used.  When it is set, case differences are ignored
when searching for matches.

A special option for completion is <span class="highlight"><i>'infercase'</i><span>.  This is useful to find
matches while ignoring case (<span class="highlight"><i>'ignorecase'</i><span> must be set) but still using the
case of the word typed so far.  Thus if you type &quot;For&quot; and Vim finds a match
&quot;fortunately&quot;, it will result in &quot;Fortunately&quot;.


COMPLETING SPECIFIC ITEMS

If you know what you are looking for, you can use these commands to complete
with a certain type of item:

        <span class="highlight"><i>CTRL-X</i></font></span> <span class="highlight"><i>CTRL-F</i><span>           file names
        <span class="highlight"><i>CTRL-X</i></font></span> <span class="highlight"><i>CTRL-L</i><span>           whole lines
        <span class="highlight"><i>CTRL-X</i></font></span> <span class="highlight"><i>CTRL-D</i><span>           macro definitions (also in included files)
        <span class="highlight"><i>CTRL-X</i></font></span> <span class="highlight"><i>CTRL-I</i><span>           current and included files
        <span class="highlight"><i>CTRL-X</i></font></span> <span class="highlight"><i>CTRL-K</i><span>           words from a dictionary
        <span class="highlight"><i>CTRL-X</i></font></span> <span class="highlight"><i>CTRL-T</i><span>           words from a thesaurus
        <span class="highlight"><i>CTRL-X</i></font></span> <span class="highlight"><i>CTRL-]</i><span>           tags
        <span class="highlight"><i>CTRL-X</i></font></span> <span class="highlight"><i>CTRL-V</i><span>           Vim command line

After each of them <span class="highlight"><i>CTRL-N</i></font></span> can be used to find the next match, <span class="highlight"><i>CTRL-P</i><span> to find
the previous match.
   More information for each of these commands here: <span class="highlight"><i>|ins-completion|</i><span>.


COMPLETING FILE NAMES

Let's take <span class="highlight"><i>CTRL-X</i></font></span> <span class="highlight"><i>CTRL-F</i><span> as an example.  This will find file names.  It scans
the current directory for files and displays each one that matches the word in
front of the cursor.
   Suppose, for example, that you have the following files in the current
directory:

        main.c  sub_count.c  sub_done.c  sub_exit.c

Now enter Insert mode and start typing:

<span class="highlight"><b>        The exit code is in the file sub </b><span><font color="#e5e5e5">~</font>

At this point, you enter the command <span class="highlight"><i>CTRL-X</i></font></span> <span class="highlight"><i>CTRL-F</i><span>.  Vim now completes the
current word &quot;sub&quot; by looking at the files in the current directory.  The
first match is sub_count.c.  This is not the one you want, so you match the
next file by typing <span class="highlight"><i>CTRL-N</i></font></span>.  This match is sub_done.c.  Typing <span class="highlight"><i>CTRL-N</i><span> again
takes you to sub_exit.c.  The results:

<span class="highlight"><b>        The exit code is in the file sub_exit.c </b><span><font color="#e5e5e5">~</font>

If the file name starts with / (Unix) or C:\ (MS-Windows) you can find all
files in the file system.  For example, type &quot;/u&quot; and <span class="highlight"><i>CTRL-X</i></font></span> <span class="highlight"><i>CTRL-F</i><span>.  This
will match &quot;/usr&quot; (this is on Unix):

<span class="highlight"><b>        the file is found in /usr/ </b><span><font color="#e5e5e5">~</font>

If you now press <span class="highlight"><i>CTRL-N</i><span> you go back to &quot;/u&quot;.  Instead, to accept the &quot;/usr/&quot;
and go one directory level deeper, use <span class="highlight"><i>CTRL-X</i></font></span> <span class="highlight"><i>CTRL-F</i><span> again:

<span class="highlight"><b>        the file is found in /usr/X11R6/ </b><span><font color="#e5e5e5">~</font>

The results depend on what is found in your file syste, of course.  The
matches are sorted alphabetically.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*24.4*</i></b><span>  Repeating an insert

If you press <span class="highlight"><i>CTRL-A</i><span>, the editor inserts the text you typed the last time you
were in insert mode.
   Assume, for example, that you have a file that begins with the following:

<span class="highlight"><b>        &quot;file.h&quot; </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        /* Main program begins */ </b><span><font color="#e5e5e5">~</font>

You edit this file by inserting &quot;#include &quot; at the beginning of the first
line:

<span class="highlight"><b>        #include &quot;file.h&quot; </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        /* Main program begins */ </b><span><font color="#e5e5e5">~</font>

You go down to the beginning of the next line using the commands &quot;j^&quot;.  You
now start to insert a new &quot;#include&quot; line.  So you type:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        i CTRL-A</b><span>

The result is as follows:

<span class="highlight"><b>        #include &quot;file.h&quot; </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        #include /* Main program begins */ </b><span><font color="#e5e5e5">~</font>

The &quot;#include &quot; was inserted because <span class="highlight"><i>CTRL-A</i><span> inserts the text of the previous
insert.  Now you type  &quot;main.h&quot;<span class="highlight"><i>&lt;Enter&gt;</i><span>  to finish the line:


<span class="highlight"><b>        #include &quot;file.h&quot; </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        #include &quot;main.h&quot; </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        /* Main program begins */ </b><span><font color="#e5e5e5">~</font>

The <span class="highlight"><i>CTRL-@</i></font></span> command does a <span class="highlight"><i>CTRL-A</i><span> and then exits Insert mode.  That's a quick
way of doing exactly the same insertion again.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*24.5*</i></b><span>  Copying from another line

The <span class="highlight"><i>CTRL-Y</i><span> command inserts the character above the cursor.  This is useful
when you are duplicating a previous line.  For example, you have this line of
C code:

<span class="highlight"><b>        b_array[i]-&gt;s_next = a_array[i]-&gt;s_next; </b><span><font color="#e5e5e5">~</font>

Now you need to type the same line, but with &quot;s_prev&quot; instead of &quot;s_next&quot;.
Start the new line, and press <span class="highlight"><i>CTRL-Y</i><span> 14 times, until you are at the &quot;n&quot; of
&quot;next&quot;:

<span class="highlight"><b>        b_array[i]-&gt;s_next = a_array[i]-&gt;s_next;</b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        b_array[i]-&gt;s_ </b><span><font color="#e5e5e5">~</font>

Now you type &quot;prev&quot;:

<span class="highlight"><b>        b_array[i]-&gt;s_next = a_array[i]-&gt;s_next; </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        b_array[i]-&gt;s_prev </b><span><font color="#e5e5e5">~</font>

Continue pressing <span class="highlight"><i>CTRL-Y</i><span> until the following &quot;next&quot;:

<span class="highlight"><b>        b_array[i]-&gt;s_next = a_array[i]-&gt;s_next;</b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        b_array[i]-&gt;s_prev = a_array[i]-&gt;s_ </b><span><font color="#e5e5e5">~</font>

Now type &quot;prev;&quot; to finish it off.

The <span class="highlight"><i>CTRL-E</i></font></span> command acts like <span class="highlight"><i>CTRL-Y</i><span> except it inserts the character below the
cursor.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*24.6*</i></b><span>  Inserting a register

The command <span class="highlight"><i>CTRL-R</i></font></span> <span class="highlight"><i>{register}</i><span> inserts the contents of the register.  This is
useful to avoid having to type a long word.  For example, you need to type
this:

<span class="highlight"><b>        r = VeryLongFunction(a) + VeryLongFunction(b) + VeryLongFunction(c) </b><span><font color="#e5e5e5">~</font>

The function name is defined in a different file.  Edit that file and move the
cursor on top of the function name there, and yank it into register v:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        &quot;vyiw</b><span>

&quot;v is the register specification, &quot;yiw&quot; is yank-inner-word.  Now edit the file
where the new line is to be inserted, and type the first letters:

<span class="highlight"><b>        r = </b><span><font color="#e5e5e5">~</font>

Now use <span class="highlight"><i>CTRL-R</i><span> v to insert the function name:

<span class="highlight"><b>        r = VeryLongFunction </b><span><font color="#e5e5e5">~</font>

You continue to type the characters in between the function name, and use
<span class="highlight"><i>CTRL-R</i><span> v two times more.
   You could have done the same with completion.  Using a register is useful
when there are many words that start with the same characters.

If the register contains characters such as <span class="highlight"><i>&lt;BS&gt;</i><span> or other special characters,
they are interpreted as if they had been typed from the keyboard.  If you do
not want this to happen (you really want the <span class="highlight"><i>&lt;BS&gt;</i><span> to be inserted in the text),
use the command <span class="highlight"><i>CTRL-R</i></font></span> <span class="highlight"><i>CTRL-R</i><span> <span class="highlight"><i>{register}</i><span>.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*24.7*</i></b><span>  Abbreviations

An abbreviation is a short word that takes the place of a long one.  For
example, &quot;ad&quot; stands for &quot;advertisement&quot;.  Vim enables you to type an
abbreviation and then will automatically expand it for you.
   To tell Vim to expand &quot;ad&quot; into &quot;advertisement&quot; every time you insert it,
use the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :iabbrev ad advertisement</b><span>

Now, when you type &quot;ad&quot;, the whole word 'advertisement&quot; will be inserted into
the text.  This is triggered by typing a character that can't be part of a
word, for example a space:

        What Is Entered         What You See
<span class="highlight"><b>        I saw the a             I saw the a </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        I saw the ad            I saw the ad </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        I saw the ad&lt;Space&gt;     I saw the advertisement&lt;Space&gt; </b><span><font color="#e5e5e5">~</font>

The expansion doesn't happen when typing just &quot;ad&quot;.  That allows you to type a
word like &quot;add&quot;, which will not get expanded.  Only whole words are checked
for abbreviations.


ABBREVIATING SEVERAL WORDS

It is possible to define an abbreviation that results in multiple words.  For
example, to define &quot;JB&quot; as &quot;Jack Benny&quot;, use the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :iabbrev JB Jack Benny</b><span>

As a programmer, I use two rather unusual abbreviations:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :iabbrev #b /****************************************</b><span>
<span class="highlight"><b>        :iabbrev #e &lt;Space&gt;****************************************/</b><span>

These are used for creating boxed comments.  The comment starts with #b, which
draws the top line.  I then type the comment text and use #e to draw the
bottom line.
   Notice that the #e abbreviation begins with a space.  In other words, the
first two characters are space-star.  Usually Vim ignores spaces between the
abbreviation and the expansion.  To avoid that problem, I spell space as seven
characters: &lt;, S, p, a, c, e, &gt;.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        &quot;:iabbrev&quot; is a long word to type.  &quot;:iab&quot; works just as well.
        That's abbreviating the abbreviate command!


FIXING TYPING MISTAKES

It's very common to make the same typing mistake every time.  For example,
typing &quot;teh&quot; instead of &quot;the&quot;.  You can fix this with an abbreviation:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :abbreviate teh the</b><span>

You can add a whole list of these.  Add one each time you discover a common
mistake.


LISTING ABBREVIATIONS

The &quot;:abbreviate&quot; command lists the abbreviations:

        :abbreviate
        i  #e             ****************************************/
        i  #b            /****************************************
        i  JB            Jack Benny
        i  ad            advertisement
        !  teh           the

The &quot;i&quot; in the first column indicates Insert mode.  These abbreviations are
only active in Insert mode.  Other possible characters are:

        c       Command-line mode                       :cabbrev
        !       both Insert and Command-line mode       :abbreviate

Since abbreviations are not often useful in Command-line mode, you will mostly
use the &quot;:iabbrev&quot; command.  That avoids, for example, that &quot;ad&quot; gets expanded
when typing a command like:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :edit ad</b><span>


DELETING ABBREVIATIONS

To get rid of an abbreviation, use the &quot;:unabbreviate&quot; command.  Suppose you
have the following abbreviation:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :abbreviate @f fresh</b><span>

You can remove it with this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :unabbreviate @f</b><span>

While you type this, you will notice that @f is expanded to &quot;fresh&quot;.  Don't
worry about this, Vim understands it anyway (except when you have an
abbreviation for &quot;fresh&quot;, but that's very unlikely).
   To remove all the abbreviations:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :abclear</b><span>

&quot;:unabbreviate&quot; and &quot;:abclear&quot; also come in the variants for Insert mode
(&quot;iunabbeviate and &quot;:iabclear&quot;) and Command-line mode (&quot;:cunabbreviate&quot; and
&quot;cabclear&quot;).


REMAPPING ABBREVIATIONS

There is one thing to watch out for when defining an abbreviation: The
resulting string should not be mapped.  For example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :abbreviate @a adder</b><span>
<span class="highlight"><b>        :imap dd disk-door</b><span>

When you now type @a, you will get &quot;adisk-doorer&quot;.  That's not what you want.
To avoid this, use the &quot;:noreabbrev&quot; command.  It does the same as
&quot;:abbreviate&quot;, but avoids that the resulting string is used for mappings:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :noreabbrev @a adder</b><span>

Fortunately, it's unlikely that the result of an abbreviation is mapped.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*24.8*</i></b><span>  Entering special characters

The <span class="highlight"><i>CTRL-V</i><span> command is used to insert the next character literally.  In other
words, any special meaning the character has, it will be ignored.  For
example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        CTRL-V &lt;Esc&gt;</b><span>

Inserts an escape character.  Thus you don't leave Insert mode.  (Don't type
the space after <span class="highlight"><i>CTRL-V</i><span>, it's only to make this easier to read).

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        On MS-Windows <span class="highlight"><i>CTRL-V</i></font></span> is used to paste text.  Use <span class="highlight"><i>CTRL-Q</i><span> instead of
        <span class="highlight"><i>CTRL-V</i></font></span>.  On Unix, on the other hand, <span class="highlight"><i>CTRL-Q</i><span> does not work on some
        terminals, because it has a special meaning.

You can also use the command <span class="highlight"><i>CTRL-V</i></font></span> <span class="highlight"><i>{digits}</i><span> to insert a character with the
decimal number <span class="highlight"><i>{digits}</i></font></span>.  For example, the character number 127 is the <span class="highlight"><i>&lt;Del&gt;</i><span>
character (but not necessarily the <span class="highlight"><i>&lt;Del&gt;</i></font></span> key!).  To insert <span class="highlight"><i>&lt;Del&gt;</i><span> type:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        CTRL-V 127</b><span>

You can enter characters up to 255 this way.  When you type fewer than two
digits, a non-digit will terminate the command.  To avoid the need of typing a
non-digit, prepend one or two zeros to make three digits.
   All the next commands insert a <span class="highlight"><i>&lt;Tab&gt;</i><span> and then a dot:

        <span class="highlight"><i>CTRL-V</i><span> 9.
        <span class="highlight"><i>CTRL-V</i><span> 09.
        <span class="highlight"><i>CTRL-V</i><span> 009.

To enter a character in hexadecimal, use an &quot;x&quot; after the <span class="highlight"><i>CTRL-V</i><span>:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        CTRL-V x7f</b><span>

This also goes up to character 255 (<span class="highlight"><i>CTRL-V</i><span> xff).  You can use &quot;o&quot; to type a
character as an octal number and two more methods allow you to type up to
a 16 bit and a 32 bit number (e.g., for a Unicode character):<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        CTRL-V o123</b><span>
<span class="highlight"><b>        CTRL-V u1234</b><span>
<span class="highlight"><b>        CTRL-V U12345678</b><span>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*24.9*</i></b><span>  Digraphs

Some characters are not on the keyboard.  For example, the copyright character
().  To type these characters in Vim, you use digraphs, where two characters
represent one.  To enter a , for example, you press three keys:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        CTRL-K Co</b><span>

To find out what digraphs are available, use the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :digraphs</b><span>

Vim will display the digraph table.  Here are three lines of it:

<span class="highlight"><b>  AC ~_ 159  NS |  160  !I   161  Ct   162  Pd   163  Cu   164  Ye   165 </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>  BB   166  SE   167  ':   168  Co   169  -a   170  &lt;&lt;   171  NO   172 </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>  --   173  Rg   174  'm   175  DG   176  +-   177  2S   178  3S   179 </b><span><font color="#e5e5e5">~</font>

This shows, for example, that the digraph you get by typing <span class="highlight"><i>CTRL-K</i><span> Pd is the
character ().  This is character number 163 (decimal).
   Pd is short for Pound.  Most digraphs are selected to give you a hint about
the character they will produce.  If you look through the list you will
understand the logic.
   You can exchange the first and second character, if there is no digraph for
that combination.  Thus <span class="highlight"><i>CTRL-K</i><span> dP also works.  Since there is no digraph for
&quot;dP&quot; Vim will also search for a &quot;Pd&quot; digraph.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        The digraphs depend on the character set that Vim assumes you are
        using.  On MS-DOS they are different from MS-Windows.  Always use
        &quot;:digraphs&quot; to find out which digraphs are currently available.

You can define your own digraphs.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :digraph a&quot; </b><span>

This defines that <span class="highlight"><i>CTRL-K</i><span> a&quot; inserts an  character.  You can also specify the
character with a decimal number.  This defines the same digraph:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :digraph a&quot; 228</b><span>

More information about digraphs here: <span class="highlight"><i>|digraphs|</i><span>
   Another way to insert special characters is with a keymap.  More about that
here: <span class="highlight"><i>|45.5|</i><span>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*24.10*</i></b><span> Normal mode commands

Insert mode offers a limited number of commands.  In Normal mode you have many
more.  When you want to use one, you usually leave Insert mode with <span class="highlight"><i>&lt;Esc&gt;</i><span>,
execute the Normal mode command, and re-enter Insert mode with &quot;i&quot; or &quot;a&quot;.
   There is a quicker way.  With <span class="highlight"><i>CTRL-O</i></font></span> <span class="highlight"><i>{command}</i><span> you can execute any Normal
mode command from Insert mode.  For example, to delete from the cursor to the
end of the line:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        CTRL-O D</b><span>

You can execute only one Normal mode command this way.  But you can specify a
register or a count.  A more complicated example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        CTRL-O &quot;g3dw</b><span>

This deletes up to the third word into register g.

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_25.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2002 Feb 24


                             Editing formatted text


Text hardly ever comes in one sentence per line.  This chapter is about
breaking sentences to make them fit on a page and other formatting.
Vim also has useful features for editing single-line paragraphs and tables.

<span class="highlight"><i>|25.1|</i><span>  Breaking lines
<span class="highlight"><i>|25.2|</i><span>  Aligning text
<span class="highlight"><i>|25.3|</i><span>  Indents and tabs
<span class="highlight"><i>|25.4|</i><span>  Dealing with long lines
<span class="highlight"><i>|25.5|</i><span>  Editing tables


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*25.1*</i></b><span>  Breaking lines

Vim has a number of functions that make dealing with text easier.  By default,
the editor does not perform automatic line breaks.  In other words, you have
to press <span class="highlight"><i>&lt;Enter&gt;</i><span> yourself.  This is useful when you are writing programs where
you want to decide where the line ends.  It is not so good when you are
creating documentation and want the text to be at most 70 character wide.
   If you set the <span class="highlight"><i>'textwidth'</i><span> option, Vim automatically inserts line breaks.
Suppose, for example, that you want a very narrow column of only 30
characters.  You need to execute the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set textwidth=30</b><span>

Now you start typing (ruler added):

                 1         2         3
        12345678901234567890123456789012345
<span class="highlight"><b>        I taught programming for a whi </b><span><font color="#e5e5e5">~</font>

If you type &quot;l&quot; next, this makes the line longer than the 30-character limit.
When Vim sees this, it inserts a line break and you get the following:

                 1         2         3
        12345678901234567890123456789012345
<span class="highlight"><b>        I taught programming for a </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        whil </b><span><font color="#e5e5e5">~</font>

Continuing on, you can type in the rest of the paragraph:

                 1         2         3
        12345678901234567890123456789012345
<span class="highlight"><b>        I taught programming for a </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        while. One time, I was stopped </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        by the Fort Worth police, </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        because my homework was too </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        hard. True story. </b><span><font color="#e5e5e5">~</font>

You do not have to type newlines; Vim puts them in automatically.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        The <span class="highlight"><i>'wrap'</i><span> option makes Vim display lines with a line break, but this
        doesn't insert a line break in the file.


REFORMATTING

The Vim editor is not a word processor.  In a word processor, if you delete
something at the beginning of the paragraph, the line breaks are reworked.  In
Vim they are not; so if you delete the word &quot;programming&quot; from the first line,
all you get is a short line:

                 1         2         3
        12345678901234567890123456789012345
<span class="highlight"><b>        I taught for a </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        while. One time, I was stopped </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        by the Fort Worth police, </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        because my homework was too </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        hard. True story. </b><span><font color="#e5e5e5">~</font>

This does not look good.  To get the paragraph into shape you use the &quot;gq&quot;
operator.
   Let's first use this with a Visual selection.  Starting from the first
line, type:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        v4jgq</b><span>

&quot;v&quot; to start Visual mode, &quot;4j' to move to the end of the paragraph and then
the &quot;gq&quot; operator.  The result is:

                 1         2         3
        12345678901234567890123456789012345
<span class="highlight"><b>        I taught for a while. One </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        time, I was stopped by the </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        Fort Worth police, because my </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        homework was too hard. True </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        story. </b><span><font color="#e5e5e5">~</font>

Since &quot;gq&quot; is an operator, you can use one of the three ways to select the
text it works on: With Visual mode, with a movement and with a text object.
   The example above could also be done with &quot;gq4j&quot;.  That's less typing, but
you have to know the line count.  A more useful motion command is &quot;}&quot;.  This
moves to the end of a paragraph.  Thus &quot;gq}&quot; formats from the cursor to the
end of the current paragraph.
   A very useful text object to use with &quot;gq&quot; is the paragraph.  Try this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        gqap</b><span>

&quot;ap&quot; stands for &quot;a-paragraph&quot;.  This formats the text of one paragraph
(separated by empty lines).  Also the part before the cursor.
   If you have your paragraphs separated by empty lines, you can format the
whole file by typing this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        gggqG</b><span>

&quot;gg&quot; to move to the first line, &quot;gqG&quot; to format until the last line.
   Warning: If your paragraphs are not properly separated, they will be joined
together.  A common mistake is to have a line with a space or Tab.  That's a
blank line, but not an empty line.

Vim is able format more than just plain text.  See <span class="highlight"><i>|fo-table|</i><span> for how to
change this.  See the <span class="highlight"><i>'joinspaces'</i><span> option to change the number of spaces used
after a full stop.
   It is possible to use an external program for formatting.  This is useful
if your text can't be properly formatted with Vim's builtin command.  See the
<span class="highlight"><i>'formatprg'</i><span> option.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*25.2*</i></b><span>  Aligning text

To center a range of lines, use the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :{range}center [width]</b><span>

<span class="highlight"><i>{range}</i></font></span> is the usual command-line range.  <span class="highlight"><i>[width]</i><span> is an optional line width to
use for centering.  If <span class="highlight"><i>[width]</i><span> is not specified, it defaults to the value of
<span class="highlight"><i>'textwidth'</i></font></span>.  (If <span class="highlight"><i>'textwidth'</i><span> is 0, the default is 80.)
   For example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :1,5center 40</b><span>

results in the following:

<span class="highlight"><b>       I taught for a while. One </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>       time, I was stopped by the </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>     Fort Worth police, because my </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>      homework was too hard. True </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                 story. </b><span><font color="#e5e5e5">~</font>


RIGHT ALIGNMENT

Similarly, the &quot;:right&quot; command right-justifies the text:

        :1,5right 30

gives this result:

<span class="highlight"><b>            I taught for a while. One </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>           time, I was stopped by the </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        Fort Worth police, because my </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>          homework was too hard. True </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                               story. </b><span><font color="#e5e5e5">~</font>

LEFT ALIGNMENT

Finally there is this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :{range}left [margin]</b><span>

Unlike &quot;:center&quot; and &quot;:right&quot;, however, the argument to &quot;:left&quot; is not the
length of the line.  Instead it is the left margin.  If it is omitted, the
text will be put against the left side of the screen (using a zero margin
would do the same).  If it is 5, the text will be indented 5 spaces.  For
example, use these commands:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :1left 5</b><span>
<span class="highlight"><b>        :2,5left</b><span>

This results in the following:

<span class="highlight"><b>             I taught for a while. One </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        time, I was stopped by the </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        Fort Worth police, because my </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        homework was too hard. True </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        story. </b><span><font color="#e5e5e5">~</font>


JUSTIFYING TEXT

Vim has no built-in way of justifying text.  However, there is a neat macro
package that does the job.  To use this package, execute the following
command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :runtime macros/justify.vim</b><span>

This Vim script file defines a new visual command &quot;_j&quot;. To justify a block of
text, highlight the text in Visual mode and then execute &quot;_j&quot;.
   Look in the file for more explanations.  To go there, do &quot;gf&quot; on this name:
$VIMRUNTIME/macros/justify.vim.

An alternative is to filter the text through an external program.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :%!fmt</b><span>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*25.3*</i></b><span>  Indents and tabs

Indents can be used to make text stand out from the rest.  The example texts
in this manual, for example, are indented by eight spaces or a tab.  You would
normally enter this by typing a tab at the start of each line.  Take this
text:
<span class="highlight"><b>        the first line </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        the second line </b><span><font color="#e5e5e5">~</font>

This is entered by typing a tab, some text, <span class="highlight"><i>&lt;Enter&gt;</i><span>, tab and more text.
   The <span class="highlight"><i>'autoindent'</i><span> option inserts indents automatically:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set autoindent</b><span>

When a new line is started it gets the same indent as the previous line.  In
the above example, the tab after the <span class="highlight"><i>&lt;Enter&gt;</i><span> is not needed anymore.


INCREASING INDENT

To increase the amount of indent in a line, use the &quot;&gt;&quot; operator.  Often this
is used as &quot;&gt;&gt;&quot;, which adds indent to the current line.
   The amount of indent added is specified with the <span class="highlight"><i>'shiftwidth'</i><span> option.  The
default value is 8.  To make &quot;&gt;&gt;&quot; insert four spaces wordth of indent, for
example, type this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set shiftwidth=4</b><span>

When used on the second line of the example text, this is what you get:

<span class="highlight"><b>        the first line </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>            the second line </b><span><font color="#e5e5e5">~</font>

&quot;4&gt;&gt;&quot; will increase the indent of four lines.


TABSTOP

If you want to make indents a multiple of 4, you set <span class="highlight"><i>'shiftwidth'</i><span> to 4.  But
when pressing a Tab you still get 8 spaces worth of indent.  To change this,
set the <span class="highlight"><i>'softtabstop'</i><span> option:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set softtabstop=4</b><span>

This will make the <span class="highlight"><i>&lt;Tab&gt;</i><span> key insert 4 spaces worth of indent.  If there are
already four spaces, a <span class="highlight"><i>&lt;Tab&gt;</i><span> character is used (saving seven characters in the
file).  (If you always want spaces and no tab characters, set the <span class="highlight"><i>'expandtab'</i><span>
option.)

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        You could set the <span class="highlight"><i>'tabstop'</i><span> option to 4.  However, if you edit the
        file another time, with <span class="highlight"><i>'tabstop'</i><span> set to the default value of 8, it
        will look wrong.  In other programs and when printing the indent will
        also be wrong.  Therefore it is recommended to keep <span class="highlight"><i>'tabstop'</i><span> at eight
        all the time.  That's the standard value everywhere.


CHANGING TABS

You edit a file which was written with a tabstop of 3.  In Vim it looks ugly,
because it uses the normal tabstop value of 8.  You can fix this by setting
<span class="highlight"><i>'tabstop'</i><span> to 3.  But you have to do this every time you edit this file.
   Vim can change the use of tabstops in your file.  First, set <span class="highlight"><i>'tabstop'</i><span> to
make the indents look good, then use the &quot;:retab&quot; command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set tabstop=3</b><span>
<span class="highlight"><b>        :retab 8</b><span>

The &quot;:retab&quot; command will change <span class="highlight"><i>'tabstop'</i><span> to 8, while changing the text such
that it looks the same.  It changes spans of white space into tabs and spaces
for this.  You can now write the file.  Next time you edit it the indents will
be right without setting an option.
   Warning: When using &quot;:retab&quot; on a program, it may change white space inside
a string constant.  Therefore it's a good habit to use &quot;\t&quot; instead of a
real tab

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*25.4*</i></b><span>  Dealing with long lines

Sometimes you will be editing a file that is wider than the number of columns
in the window.  When that occurs, Vim wraps the lines so that everything fits
on the screen.
   If you switch the <span class="highlight"><i>'wrap'</i><span> option off, each line in the file shows up as one
line on the screen.  Then the ends of the long lines disappear off the screen
to the right.
   When you move the cursor to a character that can't be seen, Vim will scroll
the text to show it.  This is like moving a viewport over the text in the
horizontal direction.
   By default, Vim does not display a horizontal scrollbar in the GUI.  If you
want to enable one, use the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set guioptions+=b</b><span>

One horizontal scrollbar will appear at the bottom of the Vim window.

If you don't have a scrollbar or don't want to use it, use these commands to
scroll the text.  The cursor will stay in the same place, but it's move back
into the visible text if necessary.

        zh              scroll right
        4zh             scroll four characters right
        zH              scroll half a window width right
        ze              scroll right to put the cursor at the end
        zl              scroll left
        4zl             scroll four characters left
        zL              scroll half a window width left
        zs              scroll left to put the cursor at the start

Let's attempt to show this with one line of text.  The cursor is on the &quot;w&quot; of
&quot;which&quot;.  The &quot;current window&quot; above the line indicates the text that is
currently visible.  The &quot;window&quot;s below the text indicate the text that is
visible after the command left of it.

                              |&lt;-- current window --&gt;|
<span class="highlight"><b>                some long text, part of which is visible in the window</b><span><font color="#e5e5e5">~</font>
        ze        |&lt;--     window     --&gt;|
        zH         |&lt;--     window     --&gt;|
        4zh               |&lt;--     window     --&gt;|
        zh                   |&lt;--     window     --&gt;|
        zl                     |&lt;--     window     --&gt;|
        4zl                       |&lt;--     window     --&gt;|
        zL                              |&lt;--     window     --&gt;|
        zs                             |&lt;--     window     --&gt;|


MOVING WITH WRAP OFF

When <span class="highlight"><i>'wrap'</i><span> is off and the text has scrolled horizontally, you can use the
following commands to move the cursor to a character you can see.  Thus text
left and right of the window is ignored.  These never cause the text to
scroll:

        g0              to first visible character in this line
        g^              to first non-blank visible character in this line
        gm              to middle of this line
        g$              to last visible character in this line

                |&lt;--     window    --&gt;|
<span class="highlight"><b>        some long    text, part of which is visible </b><span><font color="#e5e5e5">~</font>
                 g0  g^    gm        g$


BREAKING AT WORDS

When preparing text for use by another program, you might have to make
paragraphs without a line break.  A disadvantage of using <span class="highlight"><i>'nowrap'</i><span> is that you
can't see the whole sentence you are working on.  When <span class="highlight"><i>'wrap'</i><span> is on, words are
broken halfway, which makes them hard to read.
   A good solution for editing this kind of paragraph is setting the
<span class="highlight"><i>'linebreak'</i><span> option.  Vim then breaks lines at an appropriate place when
displaying the line.  The text in the file remains unchanged.
   Without <span class="highlight"><i>'linebreak'</i><span> text might look like this:

        +---------------------------------+
        |letter generation program for a b|
        |ank.  They wanted to send out a s|
        |pecial, personalized letter to th|
        |eir richest 1000 customers.  Unfo|
        |rtunately for the programmer, he |
        +---------------------------------+
After:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set linebreak</b><span>

it looks like this:

        +---------------------------------+
        |letter generation program for a  |
        |bank.  They wanted to send out a |
        |special, personalized letter to  |
        |their richest 1000 customers.    |
        |Unfortunately for the programmer,|
        +---------------------------------+

Related options:
<span class="highlight"><i>'breakat'</i><span> specifies the characters where a break can be inserted.
<span class="highlight"><i>'showbreak'</i><span> specifies a string to show at the start of broken line.
Set <span class="highlight"><i>'textwidth'</i><span> to zero to avoid a paragraph to be split.


MOVING BY VISIBLE LINES

The &quot;j&quot; and &quot;k&quot; commands move to the next and previous lines.  When used on
a long line, this means moving a lot of screen lines at once.
   To move only one screen line, use the &quot;gj&quot; and &quot;gk&quot; commands.  When a line
doesn't wrap they do the same as &quot;j&quot; and &quot;k&quot;.  When the line does wrap, they
move to a character displayed one line below or above.
   You might like to use these mappings, which bind these movement commands to
the cursor keys:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :map &lt;Up&gt; gk</b><span>
<span class="highlight"><b>        :map &lt;Down&gt; gj</b><span>


TURNING A PARAGRAPH INTO ONE LINE

If you want to import text into a program like MS-Word, each paragraph should
be a single line.  If your paragraphs are currently separated with empty
lines, this is how you turn each paragraph into a single line:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :g/./,/^$/join</b><span>

That looks complicated.  Let's break it up in pieces:

        :g/./           A &quot;:global&quot; command that finds all lines that contain
                        at least one character.
             ,/^$/      A range, starting from the current line (the non-empty
                        line) until an empty line.
                  join  The &quot;:join&quot; command joins the range of lines together
                        into one line.

Starting with this text, containing eight lines broken at column 30:

        +----------------------------------+
        |A letter generation program       |
        |for a bank.  They wanted to       |
        |send out a special,               |
        |personalized letter.              |
        |                                  |
        |To their richest 1000             |
        |customers.  Unfortunately for     |
        |the programmer,                   |
        +----------------------------------+

You end up with two lines:

        +----------------------------------+
        |A letter generation program for a |
        |bank.  They wanted to send out a s|
        |pecial, personalized letter.      |
        |To their richest 1000 customers.  |
        |Unfortunately for the programmer, |
        +----------------------------------+

<span class="highlight"><b><i><u>Note</u></i></b><span> that this doesn't work when the separating line is blank but not empty;
when it contains spaces and/or tabs.  This command does work with blank lines:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        :g/\S/,/^\s*$/join</b><span>

This still requires a blank or empty line at the end of the file for the last
paragraph to be joined.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*25.5*</i></b><span>  Editing tables

Suppose you are editing a table with four columns:

<span class="highlight"><b>        nice table        test 1        test 2      test 3 </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        input A           0.534 </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        input B           0.913 </b><span><font color="#e5e5e5">~</font>

You need to enter numbers in the third column.  You could move to the second
line, use &quot;A&quot;, enter a lot of spaces and type the text.
   For this kind of editing there is a special option:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        set virtualedit=all</b><span>

Now you can move the cursor to positions where there isn't any text.  This is
called &quot;virtual space&quot;.  Editing a table is a lot easier this way.
   Move the cursor by searching for the header of the last column:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /test 3</b><span>

Now press &quot;j&quot; and you are right where you can enter the value for &quot;input A&quot;.
Typing &quot;0.693&quot; results in:

<span class="highlight"><b>        nice table        test 1     test 2      test 3 </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        input A           0.534                  0.693 </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        input B           0.913 </b><span><font color="#e5e5e5">~</font>

Vim has automatically filled the gap in front of the new text for you.  Now,
to enter the next field in this column use &quot;Bj&quot;.  &quot;B&quot; moves back to the start
of a white space separated word.  Then &quot;j&quot; moves to the place where the next
field can be entered.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        You can move the cursor anywhere in the display, also beyond the end
        of a line.  But Vim will not insert spaces there, until you insert a
        character in that position.


COPYING A COLUMN

You want to add a column, which should be a copy of the third column and
placed before the &quot;test 1&quot; column.  Do this in seven steps:
1.  Move the cursor to the left upper corner of this column, e.g., with
    &quot;/test 3&quot;.
2.  Press <span class="highlight"><i>CTRL-V</i><span> to start blockwise Visual mode.
3.  Move the cursor down two lines with &quot;2j&quot;.  You are now in &quot;virtual space&quot;:
    the &quot;input B&quot; line of the &quot;test 3&quot; column.
4.  Move the cursor right, to include the whole column in the selection, plus
    the space that you want between the columns.  &quot;9l&quot; should do it.
5.  Yank the selected rectangle with &quot;y&quot;.
6.  Move the cursor to &quot;test 1&quot;, where the new column must be placed.
7.  Press &quot;P&quot;.

The result should be:

<span class="highlight"><b>        nice table        test 3    test 1     test 2      test 3 </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        input A           0.693     0.534                  0.693 </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        input B                     0.913 </b><span><font color="#e5e5e5">~</font>

Notice that the whole &quot;test 1&quot; column was shifted right, also the line where
the &quot;test 3&quot; column didn't have text.

Go back to non-virtual cursor movements with:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set virtualedit=</b><span>


VIRTUAL REPLACE MODE

The disadvantage of using <span class="highlight"><i>'virtualedit'</i><span> is that it &quot;feels&quot; different.  You
can't recognize tabs or spaces beyond the end of line when moving the cursor
around.  Another method can be used: Virtual replace mode.
   Suppose you have a line in a table that contains both tabs and other
characters.  Use &quot;rx&quot; on the first tab:

<span class="highlight"><b>        inp     0.693   0.534   0.693 </b><span><font color="#e5e5e5">~</font>

               |
           rx  |
               V

<span class="highlight"><b>        inpx0.693   0.534       0.693 </b><span><font color="#e5e5e5">~</font>

The layout is messed up.  To avoid that, use the &quot;gr&quot; command:

<span class="highlight"><b>        inp     0.693   0.534   0.693 </b><span><font color="#e5e5e5">~</font>

               |
          grx  |
               V

<span class="highlight"><b>        inpx    0.693   0.534   0.693 </b><span><font color="#e5e5e5">~</font>

What happens is that the &quot;gr&quot; command makes sure the new character takes the
right amount of screen space.  Extra spaces or tabs are inserted to fill the
gap.  Thus what actually happens is that a tab is replaced by &quot;x&quot; and then
blanks added to make the text after it keep it's place.  In this case a
tab is inserted.
   When you need to replace more than one character, you use the &quot;R&quot; command
to go to replace mode (see <span class="highlight"><i>|04.9|</i><span>).  This messes up the layout and replaces
the wrong characters:

<span class="highlight"><b>        inp     0       0.534   0.693 </b><span><font color="#e5e5e5">~</font>

                |
         R0.786 |
                V

<span class="highlight"><b>        inp     0.78634 0.693 </b><span><font color="#e5e5e5">~</font>

The &quot;gR&quot; command uses virtual replace mode.  This preserves the layout:

<span class="highlight"><b>        inp     0       0.534   0.693 </b><span><font color="#e5e5e5">~</font>

                |
        gR0.786 |
                V

<span class="highlight"><b>        inp     0.786   0.534   0.693 </b><span><font color="#e5e5e5">~</font>

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_26.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2001 Sep 03


                                  Repeating


An editing task is hardly ever unstructured.  A change often needs to be made
several times.  In this chapter a number of useful ways to repeat a change
will be explained.

<span class="highlight"><i>|26.1|</i><span>  Repeating with Visual mode
<span class="highlight"><i>|26.2|</i><span>  Add and subtract
<span class="highlight"><i>|26.3|</i><span>  Making a change in many files
<span class="highlight"><i>|26.4|</i><span>  Using Vim from a shell script


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*26.1*</i></b><span>  Repeating with Visual mode

Visual mode is very handy for making a change in any sequence of lines.  You
can see the highlighted text, thus you can check if the correct lines are
changed.  But making the selection takes some typing.  The &quot;gv&quot; command
selects the same area again.  This allows you to do another operation on the
same text.
   Suppose you have some lines where you want to change &quot;2001&quot; to &quot;2002&quot; and
&quot;2000&quot; to &quot;2001&quot;:

<span class="highlight"><b>        The financial results for 2001 are better </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        than for 2000.  The income increased by 50%, </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        even though 2001 had more rain than 2000. </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                        2000            2001 </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        income          45,403          66,234 </b><span><font color="#e5e5e5">~</font>

First change &quot;2001&quot; to &quot;2002&quot;.  Select the lines in Visual mode, and use:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :s/2001/2002/g</b><span>

Now use &quot;gv&quot; to reselect the same text.  It doesn't matter where the cursor
is.  Then use &quot;:s/2000/2001/g&quot; to make the second change.
   Obviously, you can repeat these changes several times.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*26.2*</i></b><span>  Add and subtract

When repeating the change of one number into another, you often have a fixed
offset.  In the example above, one was added to each year.  Instead of typing
a substitute command for each year that appears, the <span class="highlight"><i>CTRL-A</i><span> command can be
used.
   Using the same text as above, search for a year:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /19[0-9][0-9]\|20[0-9][0-9]</b><span>

Now press <span class="highlight"><i>CTRL-A</i><span>.  The year will be increased by one:

<span class="highlight"><b>        The financial results for 2002 are better </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        than for 2000.  The income increased by 50%, </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        even though 2001 had more rain than 2000. </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                        2000            2001 </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        income          45,403          66,234 </b><span><font color="#e5e5e5">~</font>

Use &quot;n&quot; to find the next year, and press &quot;.&quot; to repeat the <span class="highlight"><i>CTRL-A</i><span> (&quot;.&quot; is a
bit quicker to type).  Repeat &quot;n&quot; and &quot;.&quot; for all years that appear.
   Hint: set the <span class="highlight"><i>'hlsearch'</i><span> option to see the matches you are going to change,
then you can look ahead and do it faster.

Adding more than one can be done by prepending the number to <span class="highlight"><i>CTRL-A</i><span>.  Suppose
you have this list:

<span class="highlight"><b>        1.  item four </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        2.  item five </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        3.  item six </b><span><font color="#e5e5e5">~</font>

Move the cursor to &quot;1.&quot; and type:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        3 CTRL-A</b><span>

The &quot;1.&quot; will change to &quot;4.&quot;.  Again, you can use &quot;.&quot; to repeat this on the
other numbers.

Another example:

<span class="highlight"><b>        006     foo bar </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        007     foo bar </b><span><font color="#e5e5e5">~</font>

Using <span class="highlight"><i>CTRL-A</i><span> on these numbers results in:

<span class="highlight"><b>        007     foo bar </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        010     foo bar </b><span><font color="#e5e5e5">~</font>

7 plus one is 10?  What happened here is that Vim recognized &quot;007&quot; as an octal
number, because there is a leading zero.  This notation is often used in C
programs.  If you do not want a number with leading zeros to be handled as
octal, use this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set nrformats-=octal</b><span>

The <span class="highlight"><i>CTRL-X</i><span> command does subtraction in a similar way.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*26.3*</i></b><span>  Making a change in many files

Suppose you have a variable called &quot;x_cnt&quot; and you want to change it to
&quot;x_counter&quot;.  This variable is used in several of your C files.  You need to
change it in all files.  This is how you do it.
   Put all the relevant files in the argument list:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :args *.c</b><span>
<font color="#e5e5e5">&lt;</font>
This finds all C files and edits the first one.  Now you can perform a
substitution command on all these files:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :argdo %s/\&lt;x_cnt\&gt;/x_counter/ge | update</b><span>

The &quot;:argdo&quot; command takes an argument that is another command.  That command
will be executed on all files in the argument list.
   The &quot;%s&quot; substitute command that follows works on all lines.  It finds the
word &quot;x_cnt&quot; with &quot;\&lt;x_cnt\&gt;&quot;.  the &quot;\&lt;&quot; and &quot;\&gt;&quot; are used to match the whole
word only, and not &quot;px_cnt&quot; or &quot;x_cnt2&quot;.
   The flags for the substitute command include &quot;g&quot; to replace all occurences
of &quot;x_cnt&quot; in the same line.  The &quot;e&quot; flag is used to avoid an error message
when &quot;x_cnt&quot; does not appear in the file.  Otherwise &quot;:argdo&quot; would abort on
the first file where &quot;x_cnt&quot; was not found.
   The &quot;|&quot; separates two commands.  The following &quot;update&quot; command writes the
file only if it was changed.  If no &quot;x_cnt&quot; was changed to &quot;x_counter&quot; nothing
happens.

There is also the &quot;:windo&quot; command, which executes its argument in all
windows.  And &quot;:bufdo&quot; executes its argument on all buffers.  Be careful with
this, because you might have more files in the buffer list than you think.
Check this with the &quot;:buffers&quot; command (or &quot;:ls&quot;).

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*26.4*</i></b><span>  Using Vim from a shell script

Suppose you have a lot of files in which you need to change the string
&quot;-person-&quot; to &quot;Jones&quot; and then print it.  How do you do that?  One way is to
do a lot of typing.  The other is to write a shell script to do the work.
   The Vim editor does a superb job as a screen-oriented editor when using
Normal mode commands.  For batch processing, however, Normal mode commands do
not result in clear, commented command files; so here you will use Ex mode
instead.  This mode gives you a nice command-line interface that makes it easy
to put into a batch file.  (&quot;Ex command&quot; is just another name for a
command-line (:) command.)
   The Ex mode commands you need are as follows:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        %s/-person-/Jones/g</b><span>
<span class="highlight"><b>        write tempfile</b><span>
<span class="highlight"><b>        quit</b><span>

You put these commands in the file &quot;change.vim&quot;.  Now to run the editor in
batch mode, use this shell script:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        for file in *.txt; do</b><span>
<span class="highlight"><b>          vim -e -s $file &lt; change.vim</b><span>
<span class="highlight"><b>          lpr -r tempfile</b><span>
<span class="highlight"><b>        done</b><span>

The for-done loop is a shell construct to repeat the two lines in between,
while the $file variable is set to a different file name each time.
   The second line runs the Vim editor in Ex mode (-e argument) on the file
$file and reads commands from the file &quot;change.vim&quot;.  The -s argument tells
Vim to operate in silent mode.  In other words, do not keep outputting the
:prompt, or any other prompt for that matter.
   The &quot;lpr -r tempfile&quot; command prints the resulting &quot;tempfile&quot; and deletes
it (that's what the -r argument does).


READING FROM STDIN

Vim can read text on standard input.  Since the normal way is to read commands
there, you must tell Vim to read text instead.  This is done by passing the
&quot;-&quot; argument in place of a file.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        ls | vim -</b><span>

This allows you to edit the output of the &quot;ls&quot; command, without first saving
the text in a file.
   If you use the standard input to read text from, you can use the &quot;-S&quot;
argument to read a script:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        producer | vim -S change.vim -</b><span>


NORMAL MODE SCRIPTS

If you really want to use Normal mode commands in a script, you can use it
like this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        vim -s script file.txt ...</b><span>
<font color="#e5e5e5">&lt;</font>
        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        &quot;-s&quot; has a different meaning when it is used without &quot;-e&quot;.  Here it
        means to source the &quot;script&quot; as Normal mode commands.  When used with
        &quot;-e&quot; it means to be silent, and doesn't use the next argument as a
        file name.

The commands in &quot;script&quot; are executed like you typed them.  Don't forget that
a line break is interpreted as pressing <span class="highlight"><i>&lt;Enter&gt;</i><span>.  In Normal mode that moves
the cursor to the next line.
   To create the script you can edit the script file and type the commands.
You need to imagine what the result would be, which can be a bit difficult.
Another way is to record the commands while you perform them manually.  This
is how you do that:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        vim -w script file.txt ...</b><span>

All typed keys will be written to &quot;script&quot;.  If you make a small mistake you
can just continue and remember to edit the script later.
   The &quot;-w&quot; argument appends to an existing script.  That is good when you
want to record the script bit by bit.  If you want to start from scratch and
start all over, use the &quot;-W&quot; argument.  It overwrites any existing file.

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_27.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2001 Sep 03


                         Search commands and patterns


In chapter 3 a few simple search patterns were mentioned <span class="highlight"><i>|03.9|</i><span>.  Vim can do
much more complex searches.  This chapter explains the most often used ones.
A detailed specification can be found here: <span class="highlight"><i>|pattern|</i><span>

<span class="highlight"><i>|27.1|</i><span>  Ignoring case
<span class="highlight"><i>|27.2|</i><span>  Wrapping around the file end
<span class="highlight"><i>|27.3|</i><span>  Offsets
<span class="highlight"><i>|27.4|</i><span>  Matching multiple times
<span class="highlight"><i>|27.5|</i><span>  Alternatives
<span class="highlight"><i>|27.6|</i><span>  Character ranges
<span class="highlight"><i>|27.7|</i><span>  Character classes
<span class="highlight"><i>|27.8|</i><span>  Matching a line break
<span class="highlight"><i>|27.9|</i><span>  Examples


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*27.1*</i></b><span>  Ignoring case

By default, Vim's searches are case sensitive.  Therefore, &quot;include&quot;,
&quot;INCLUDE&quot;, and &quot;Include&quot; are three different words and a search will match
only one of them.
   Now switch on the <span class="highlight"><i>'ignorecase'</i><span> option:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set ignorecase</b><span>

Search for &quot;include&quot; again, and now it will match &quot;Include&quot;, &quot;INCLUDE&quot; and
&quot;InClUDe&quot;.  (set the <span class="highlight"><i>'hlsearch'</i><span> option to quickly see where a pattern
matches.)
   You can switch this off again with:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set noignorecase</b><span>

But lets keep it set, and search for &quot;INCLUDE&quot;.  It will match exactly the
same text as &quot;include&quot; did.  Now set the <span class="highlight"><i>'smartcase'</i><span> option:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set ignorecase smartcase</b><span>

If you have a pattern with at least one uppercase character, the search
becomes case sensitive.  The idea is that you didn't have to type that
uppercase character, so you must have done it because you wanted case to
match.  That's smart!
    With these two options set you find the following matches:

<span class="highlight"><b>        pattern                 matches </b><span><font color="#e5e5e5">~</font>
        word                    word, Word, WORD, WoRd, etc.
        Word                    Word
        WORD                    WORD
        WoRd                    WoRd


CASE IN ONE PATTERN

If you want to ignore case for one specific pattern, you can do this by
prepending the &quot;\c&quot; string.  Using &quot;\C&quot; will make the pattern to match case.
This overrules the <span class="highlight"><i>'ignorecase'</i></font></span> and <span class="highlight"><i>'smartcase'</i><span> options, when &quot;\c&quot; or &quot;\C&quot; is
used their value doesn't matter.

<span class="highlight"><b>        pattern                 matches </b><span><font color="#e5e5e5">~</font>
        \Cword                  word
        \CWord                  Word
        \cword                  word, Word, WORD, WoRd, etc.
        \cWord                  word, Word, WORD, WoRd, etc.

A big advantage of using &quot;\c&quot; and &quot;\C&quot; is that it sticks with the pattern.
Thus if you repeat a pattern from the search history, the same will happen, no
matter if <span class="highlight"><i>'ignorecase'</i></font></span> or <span class="highlight"><i>'smartcase'</i><span> was changed.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        The use of &quot;\&quot; items in search patterns depends on the <span class="highlight"><i>'magic'</i><span> option.
        In this chapters we will assume <span class="highlight"><i>'magic'</i><span> is on, because that is the
        standard and recommended setting.  If you would change it, many search
        patterns would suddenly become invalid.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        If your search takes much longer than you expected, you can interrupt
        it with <span class="highlight"><i>CTRL-C</i></font></span> on Unix and  <span class="highlight"><i>CTRL-Break</i><span> on MS-DOS and MS-Windows.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*27.2*</i></b><span>  Wrapping around the file end

By default, a forward search starts searching for the given string at the
current cursor location.  It then proceeds to the end of the file.  If it has
not found the string by that time, it starts from the beginning and searches
from the start of the file to the cursor location.
   Keep in mind that when repeating the &quot;n&quot; command to search for the next
match, you eventually get back to the first match.  If you don't notice this
you keep searching forever!  To give you a hint, Vim displays this message:

<span class="highlight"><b>        search hit BOTTOM, continuing at TOP </b><span><font color="#e5e5e5">~</font>

If you use the &quot;?&quot; command, to search in the other direction, you get this
message:

<span class="highlight"><b>        search hit TOP, continuing at BOTTOM </b><span><font color="#e5e5e5">~</font>

Still, you don't know when you are back at the first match.  One way to see
this is by switching on the <span class="highlight"><i>'ruler'</i><span> option:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set ruler</b><span>

Vim will display the cursor position in the lower righthand corner of the
window (in the status line if there is one).  It looks like this:

<span class="highlight"><b>        101,29       84% </b><span><font color="#e5e5e5">~</font>

The first number is the line number of the cursor.  Remember the line number
where you started, so that you can check if you passed this position again.


NOT WRAPPING

To turn off search wrapping, use the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set nowrapscan</b><span>

Now when the search hits the end of the file, an error message displays:

<span class="highlight"><b>        E385: search hit BOTTOM without match for: forever </b><span><font color="#e5e5e5">~</font>

Thus you can find all matches by going to the start of the file with &quot;gg&quot; and
keep searching until you see this message.
   If you search in the other direction, using &quot;?&quot;, you get:

<span class="highlight"><b>        E384: search hit TOP without match for: forever </b><span><font color="#e5e5e5">~</font>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*27.3*</i></b><span>  Offsets

By default, the search command leaves the cursor positioned on the beginning
of the pattern.  You can tell Vim to leave it some other place by specifying
an offset.  For the forward search command &quot;/&quot;, the offset is specified by
appending a slash (/) and the offset:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /default/2</b><span>

This command searches for the pattern &quot;default&quot; and then moves to the
beginning of the second line past the pattern.  Using this command on the
paragraph above, Vim finds the word &quot;default&quot; in the first line.  Then the
cursor is moved two lines down and lands on &quot;an offset&quot;.

If the offset is a simple number, the cursor will be placed at the beginning
of the line that many lines from the match.  The offset number can be positive
or negative.  If it is positive, the cursor moves down that many lines; if
negative, it moves up.


CHARACTER OFFSETS

The &quot;e&quot; offset indicates an offset from the end of the match.  It moves the
cursor onto the last character of the match.  The command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /const/e</b><span>

puts the cursor on the t of &quot;const&quot;.
   From that position, adding a number moves forward that many characters.
This command moves to the character just after the match:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /const/e+1</b><span>

A positive number moves the cursor to the right, a negative number moves it to
the left.  For example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /const/e-1</b><span>

moves the cursor to the &quot;s&quot; of &quot;const&quot;.

If the offset begins with &quot;b&quot;, the cursor moves to the beginning of the
pattern.  That's not very useful, since leaving out the &quot;b&quot; does the same
thing.  It does get useful when a number is added or subtracted.  The cursor
then goes forward or backward that many characters.  For example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /const/b+2</b><span>

Moves the cursor to the beginning of the match and then two characters to the
right.  Thus it lands on the &quot;n&quot;.


REPEATING

To repeat searching for the previously used search pattern, but with a
different offset, leave out the pattern:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /that</b><span>
<span class="highlight"><b>        //e</b><span>

Is equal to:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /that/e</b><span>

To repeat with the same offset:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /</b><span>

&quot;n&quot; does the same thing.  To remove a previously used offset:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        //</b><span>


SEARCHING BACKWARDS

The &quot;?&quot; command uses offsets in the same way, but you must use &quot;?&quot; to separate
the offset from the pattern, instead of &quot;/&quot;:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        ?const?e-2</b><span>

The &quot;b&quot; and &quot;e&quot; keep their meaning, they don't change direction with the use
of &quot;?&quot;.


START POSITION

When starting a search, it normally starts at the cursor position.  When you
specify a line offset, this can cause trouble.  For example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /const/-2</b><span>

This finds the next word &quot;const&quot; and then moves two lines up.  If you
use &quot;n&quot; to search again, Vim could start at the current position and find the same
&quot;const&quot; match.  Then using the offset again, you would be back where you started.
You would be stuck!
   It could be worse: Suppose there is another match with &quot;const&quot; in the next
line.  Then repeating the forward search would find this match and move two
lines up.  Thus you would actually move the cursor back!

When you specify a character offset, Vim will compensate for this.  Thus the
search starts a few characters forward or backward, so that the same match
isn't found again.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*27.4*</i></b><span>  Matching multiple times

The &quot;*&quot; item specifies that the item before it can match any number of times.
Thus:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /a*</b><span>

matches &quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;, etc.  But also &quot;&quot; (the empty string), because zero
times is included.
   The &quot;*&quot; only applies to the item directly before it.  Thus &quot;ab*&quot; matches
&quot;a&quot;, &quot;ab&quot;, &quot;abb&quot;, &quot;abbb&quot;, etc.  To match a whole string multiple times, it
must be grouped into one item.  This is done by putting &quot;\(&quot; before it and
&quot;\)&quot; after it.  Thus this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /\(ab\)*</b><span>

Matches: &quot;ab&quot;, &quot;abab&quot;, &quot;ababab&quot;, etc.  And also &quot;&quot;.

To avoid matching the empty string, use &quot;\+&quot;.  This makes the previous item
match one or more times.<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /ab\+</b><span>

Matches &quot;ab&quot;, &quot;abb&quot;, &quot;abbb&quot;, etc.  It does not match &quot;a&quot; when no &quot;b&quot; follows.

To match an optional item, use &quot;\=&quot;.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /folders\=</b><span>

Matches &quot;folder&quot; and &quot;folders&quot;.


SPECIFIC COUNTS

To match a specific number of items use the form &quot;\<span class="highlight"><i>{n,m}</i><span>&quot;.  &quot;n&quot; and &quot;m&quot; are
numbers.  The item before it will be matched &quot;n&quot; to &quot;m&quot; times (inclusive).
Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /ab\{3,5}</b><span>

matches &quot;abbb&quot;, &quot;abbbb&quot; and &quot;abbbbb&quot;.
  When &quot;n&quot; is omitted, it defaults to zero.  When &quot;m&quot; is omitted it defaults
to infinity.  When &quot;,m&quot; is omitted, it matches exactly &quot;n&quot; times.
Examples:

<span class="highlight"><b>        pattern         match count </b><span><font color="#e5e5e5">~</font>
        \<span class="highlight"><i>{,4}</i><span>           0, 1, 2, 3 or 4
        \<span class="highlight"><i>{3,}</i><span>           3, 4, 5, etc.
        \<span class="highlight"><i>{0,1}</i><span>          0 or 1, same as \=
        \<span class="highlight"><i>{0,}</i><span>           0 or more, same as *
        \<span class="highlight"><i>{1,}</i><span>           1 or more, same as \+
        \<span class="highlight"><i>{3}</i><span>            3


MATCHING AS LITTLE AS POSSIBLE

The items so far match as many characters as they can find.  To match as few
as possible, use &quot;\<span class="highlight"><i>{-n,m}</i></font></span>&quot;.  It works the same as &quot;\<span class="highlight"><i>{n,m}</i><span>&quot;, except that the
minimal amount possible is used.
   For example, use:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /ab\{-1,3}</b><span>

Will match &quot;ab&quot; in &quot;abbb&quot;.  Actually, it will never match more than one b,
because there is no reason to match more.  It requires something else to force
it to match more than the lower limit.
   The same rules apply to removing &quot;n&quot; and &quot;m&quot;.  It's even possible to remove
both of the, resulting in &quot;\<span class="highlight"><i>{-}</i><span>&quot;.  This matches the item before it zero or
more times, as few as possible.  The item by itself always match zero times.
It is useful when combined with something else.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /a.\{-}b</b><span>

This matches &quot;axb&quot; in &quot;axbxb&quot;.  If this pattern would be used:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /a.*b</b><span>

It would try to match as many characters as possible with &quot;.*&quot;, thus it
matches &quot;axbxb&quot; as a whole.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*27.5*</i></b><span>  Alternatives

The &quot;or&quot; operator in a pattern is &quot;\|&quot;.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /foo\|bar</b><span>

This matches &quot;foo&quot; or &quot;bar&quot;.  More alternatives can be concatenated:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /one\|two\|three</b><span>

Matches &quot;one&quot;, &quot;two&quot; and &quot;three&quot;.
   To match multiple times, the whole thing must be placed in &quot;\(&quot; and &quot;\)&quot;:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /\(foo\|bar\)\+</b><span>

This matches &quot;foo&quot;, &quot;foobar&quot;, &quot;foofoo&quot;, &quot;barfoobar&quot;, etc.
   Another example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /end\(if\|while\|for\)</b><span>

This matches &quot;endif&quot;, &quot;endwhile&quot; and &quot;endfor&quot;.

A related item is &quot;\&amp;&quot;.  This requires that both alternatives match in the
same place.  The resulting match uses the last alternative.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /forever\&amp;...</b><span>

This matches &quot;for&quot; in &quot;forever&quot;.  It will not match &quot;fortuin&quot;, for example.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*27.6*</i></b><span>  Character ranges

To match &quot;a&quot;, &quot;b&quot; or &quot;c&quot; you could use &quot;/a\|b\|c&quot;.  When you want to match all
letters from &quot;a&quot; to &quot;z&quot; this gets very long.  There is a shorter method:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /[a-z]</b><span>

The [] construct matches a single character.  Inside you specify which
characters to match.  You can include a list of characters, like this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /[0123456789abcdef]</b><span>

This will match any of the characters included.  For consecutive characters
you can specify the range.  &quot;0-3&quot; stands for &quot;0123&quot;.  &quot;w-z&quot; stands for &quot;wxyz&quot;.
Thus the same command as above can be shortened to:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /[0-9a-f]</b><span>

To match the &quot;-&quot; character itself make it the first or last one in the range.
These special characters are accepted to make it easier to use them inside a
[] range (they can actually be used anywhere in the search pattern):

        \e      <span class="highlight"><i>&lt;Esc&gt;</i><span>
        \t      <span class="highlight"><i>&lt;Tab&gt;</i><span>
        \r      <span class="highlight"><i>&lt;CR&gt;</i><span>
        \b      <span class="highlight"><i>&lt;BS&gt;</i><span>

There are a few more special cases for [] ranges, see <span class="highlight"><i>|/[]|</i><span> for the whole
story.


COMPLIMENTED RANGE

To avoid matching a specific character, use &quot;^&quot; at the start of the range.
The [] item then matches everything but the characters included.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /&quot;[^&quot;]*&quot;</b><span>
<font color="#e5e5e5">&lt;</font>
         &quot;        a double quote
          [^&quot;]    any character that is not a double quote
<span class="highlight"><b>              </b><span>*   as many as possible
               &quot;  a double quote again

This matches &quot;foo&quot; and &quot;3!x&quot;, including the double quotes.


PREDEFINED RANGES

A number of ranges are used very often.  Vim provides a shortcut for these.
For example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /\a</b><span>

Finds alphabetic characters.  This is equal to using &quot;/[a-zA-Z]&quot;.  Here are a
few more of these:

<span class="highlight"><b>        item    matches                 equivalent </b><span><font color="#e5e5e5">~</font>
        \d      digit                   <span class="highlight"><i>[0-9]</i><span>
        \D      non-digit               <span class="highlight"><i>[^0-9]</i><span>
        \x      hex digit               <span class="highlight"><i>[0-9a-fA-F]</i><span>
        \X      non-hex digit           <span class="highlight"><i>[^0-9a-fA-F]</i><span>
        \s      white space             [       ]     (<span class="highlight"><i>&lt;Tab&gt;</i></font></span> and <span class="highlight"><i>&lt;Space&gt;</i><span>)
        \S      non-white characters    [^      ]     (not <span class="highlight"><i>&lt;Tab&gt;</i></font></span> and <span class="highlight"><i>&lt;Space&gt;</i><span>)
        \l      lowercase alpha         <span class="highlight"><i>[a-z]</i><span>
        \L      non-lowercase alpha     <span class="highlight"><i>[^a-z]</i><span>
        \u      uppercase alpha         <span class="highlight"><i>[A-Z]</i><span>
        \U      non-uppercase alpha     <span class="highlight"><i>[^A-Z]</i><span>

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        Using these predefined ranges works a lot faster than the character
        range it stands for.
        These items can not be used inside [].  Thus &quot;[\d\l]&quot; does NOT work to
        match a digit or lowercase alpha.  Use &quot;\(\d\|\l\)&quot; instead.

See <span class="highlight"><i>|/\s|</i><span> for the whole list of these ranges.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*27.7*</i></b><span>  Character classes

The character range matches a fixed set of characters.  A character class is
similar, but with an essential difference: The set of characters can be
redefined without changing the search pattern.
   For example, search for this pattern:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /\f\+</b><span>

The &quot;\f&quot; items stands for file name characters.  Thus this matches a sequence
of characters that can be a file name.
   Which characters can be part of a file name depends on the system you are
using.  On MS-Windows, the backslash is included, on Unix it is not.  This is
specified with the <span class="highlight"><i>'isfname'</i><span> option.  The default value for Unix is:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set isfname</b><span>
<span class="highlight"><b>        isfname=@,48-57,/,.,-,_,+,,,#,$,%,~,=</b><span>

For other systems the default value is different.  Thus you can make a search
pattern with &quot;\f&quot; to match a file name, and it will automatically adjust to
the system you are using it on.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        Actually, Unix allows using just about any character in a file name,
        including white space.  Including these characters in <span class="highlight"><i>'isfname'</i><span> would
        be theoretically correct.  But it would make it impossible to find the
        end of a file name in text.  Thus the default value of <span class="highlight"><i>'isfname'</i><span> is a
        compromise.

The character classes are:

<span class="highlight"><b>        item    matches                         option </b><span><font color="#e5e5e5">~</font>
        \i      identifier characters           <span class="highlight"><i>'isident'</i><span>
        \I      like \i, excluding digits
        \k      keyword characters              <span class="highlight"><i>'iskeyword'</i><span>
        \K      like \k, excluding digits
        \p      printable characters            <span class="highlight"><i>'isprint'</i><span>
        \P      like \p, excluding digits
        \f      file name characters            <span class="highlight"><i>'isfname'</i><span>
        \F      like \f, excluding digits

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*27.8*</i></b><span>  Matching a line break

Vim can find a pattern that includes a line break.  You need to specify where
the line break happens, because all items mentioned so far don't match a line
break.
   To check for a line break in a specific place, use the &quot;\n&quot; item:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /the\nword</b><span>

This will match at a line that ends in &quot;the&quot; and the next line starts with
&quot;word&quot;.  To match &quot;the word&quot; as well, you need to match a space or a line
break.  The item to use for it is &quot;\_s&quot;:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /the\_sword</b><span>

To allow any amount of white space:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /the\_s\+word</b><span>

This also matches when &quot;the  &quot; is at the end of a line and &quot;   word&quot; at the
start of the next one.

&quot;\s&quot; matches white space, &quot;\_s&quot; matches white space or a line break.
Similarly, &quot;\a&quot; matches an alphabetic character, and &quot;\_a&quot; matches an
alphabetic character or a line break.  The other character classes and ranges
can be modified in the same way by inserting a &quot;_&quot;.

Many other items can be made to match a line break by prepending &quot;\_&quot;.  For
example: &quot;\_.&quot; matches any character or a line break.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        &quot;\_.*&quot; matches everything until the end of the file.  Be careful with
        this, it can make a search command very slow.

Another example is &quot;\_[]&quot;, a character range that includes a line break:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /&quot;\_[^&quot;]*&quot;</b><span>

This finds a text in double quotes that may be split up in several lines.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*27.9*</i></b><span>  Examples

Here are a few search patterns you might find useful.  This shows how the
items mentioned above can be combined.


FINDING A CALIFORNIA LICENSE PLATE

A sample license place number is &quot;1MGU103&quot;.  It has one digit, three uppercase
letters and three digits.  Directly putting this into a search pattern:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /\d\u\u\u\d\d\d</b><span>

Another way is to specify that there are three digits and letters with a
count:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /\d\u\{3}\d\{3}</b><span>

Using [] ranges instead:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /[0-9][A-Z]\{3}[0-9]\{3}</b><span>

Which one of these you should use?  Whichever one you can remember.  The
simple way you can remember is much faster than the fancy way that you can't.
If you can remember them all, then avoid the last one, because it's both more
typing and slower to execute.


FINDING AN IDENTIFIER

In C programs (and many other computer languages) an identifier starts with a
letter and further consists of letters and digits.  Underscores can be used
too.  This can be found with:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /\&lt;\h\w*\&gt;</b><span>

&quot;\&lt;&quot; and &quot;\&gt;&quot; are used to find only whole words.  &quot;\h&quot; stands for &quot;[A-Za-z_]&quot;
and &quot;\w&quot; for <span class="highlight"><i>[0-9A-Za-z_]</i><span>&quot;.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        &quot;\&lt;&quot; and &quot;\&gt;&quot; depend on the <span class="highlight"><i>'iskeyword'</i><span> option.  If it includes &quot;-&quot;,
        for example, then &quot;ident-&quot; is not matched.  In this situation use:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>                /\w\@&lt;!\h\w*\w\@!</b><span>
<font color="#e5e5e5">&lt;</font>
        This checks if &quot;\w&quot; does not match before or after the identifier.
        See <span class="highlight"><i>|/\@&lt;!|</i></font></span> and <span class="highlight"><i>|/\@!|</i><span>.

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_28.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2001 Oct 21


                                   Folding


Structured text can be separated in sections.  And sections in sub-sections.
Folding allows you to display a section as one line, providing an overview.
This chapter explains the different ways this can be done.

<span class="highlight"><i>|28.1|</i><span>  What is folding?
<span class="highlight"><i>|28.2|</i><span>  Manual folding
<span class="highlight"><i>|28.3|</i><span>  Working with folds
<span class="highlight"><i>|28.4|</i><span>  Saving and restoring folds
<span class="highlight"><i>|28.5|</i><span>  Folding by indent
<span class="highlight"><i>|28.6|</i><span>  Folding with markers
<span class="highlight"><i>|28.7|</i><span>  Folding by syntax
<span class="highlight"><i>|28.8|</i><span>  Folding by expression
<span class="highlight"><i>|28.9|</i><span>  Folding unchanged lines
<span class="highlight"><i>|28.10|</i><span> Which fold method to use?


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*28.1*</i></b><span>  What is folding?

Folding is used to show a range of lines in the buffer as a single line on the
screen.  Like a piece of paper which is folded to make it shorter:

        +------------------------+
        | line 1                 |
        | line 2                 |
        | line 3                 |
        |_______________________ |
        \                        \
         \________________________\
         / folded lines           /
        /________________________/
        | line 12                |
        | line 13                |
        | line 14                |
        +------------------------+

The text is still in the buffer, unchanged.  Only the way lines are displayed
is affected by folding.

The advantage of folding is that you can get a better overview of the
structure of text, by folding lines of a section and replacing it with a line
that indicates that there is a section.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*28.2*</i></b><span>  Manual folding

Try it out: Position the cursor in a paragraph and type:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        zfap</b><span>

You will see that the paragraph is replaced by a highlighted line.  You have
created a fold.  <span class="highlight"><i>|zf|</i></font></span> is an operator and <span class="highlight"><i>|ap|</i><span> a text object selection.  You
can use the <span class="highlight"><i>|zf|</i><span> operator with any movement command to create a fold for the
text that it moved over.  <span class="highlight"><i>|zf|</i><span> also works in Visual mode.

To view the text again, open the fold by typing:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        zo</b><span>

And you can close the fold again with:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        zc</b><span>

All the folding commands start with 'z'.  With some fantasy, this looks like a
folded piece of paper, seen from the side.  The letter after the &quot;z&quot; has a
mnemonic meaning to make it easier to remember the commands:

        zf      F-old creation
        zo      O-pen a fold
        zc      C-lose a fold

Folds can be nested: A region of text that contains folds can be folded
again.  For example, you can fold each paragraph in this section, and then
fold all the sections in this chapter.  Try it out.  You will notice that
opening the fold for the whole chapter will restore the nested folds as they
were, some may be open and some may be closed.

Suppose you have created several folds, and now want to view all the text.
You could go to each fold and type &quot;zo&quot;.  To do this faster, use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        zr</b><span>

This will R-educe the folding.  The opposite is:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        zm</b><span>

This folds M-ore.  You can repeat &quot;zr&quot; and &quot;zm&quot; to open and close nested folds
of several levels.

If you have nested several levels deep, you can open all of them with:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        zR</b><span>

This R-educes folds until there are none left.  And you can close all folds
with:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        zM</b><span>

This folds M-ore and M-ore.

You can quickly disable the folding with the <span class="highlight"><i>|zn|</i></font></span> command.  Then <span class="highlight"><i>|zN|</i><span> brings
back the folding as it was.  <span class="highlight"><i>|zi|</i><span> toggles between the two.  This is a useful
way of working:
- create folds to get overview on your file
- move around to where you want to do your work
- do <span class="highlight"><i>|zi|</i><span> to look at the text and edit it
- do <span class="highlight"><i>|zi|</i><span> again to go back to moving around

More about manual folding in the reference manual: <span class="highlight"><i>|fold-manual|</i><span>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*28.3*</i></b><span>  Working with folds

When some folds are closed, movement commands like &quot;j&quot; and &quot;k&quot; move over a
fold like it was a single, empty line.  This allows you to quickly move around
over folded text.

You can yank, delete and put folds as if it was a single line.  This is very
useful if you want to reorder functions in a program.  First make sure that
each fold contains a whole function (or a bit less) by selecting the right
<span class="highlight"><i>'foldmethod'</i><span>.  Then delete the function with &quot;dd&quot;, move the cursor and put it
with &quot;p&quot;.  If some lines of the function are above or below the fold, you can
use Visual selection:
- put the cursor on the first line to be moved
- hit &quot;V&quot; to start Visual mode
- put the cursor on the last line to be moved
- hit &quot;d&quot; to delete the selected lines.
- move the cursor to the new position and &quot;p&quot;ut the lines there.

It is sometimes difficult to see or remember where a fold is located, thus
where a <span class="highlight"><i>|zo|</i><span> command would actually work.  To see the defined folds:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set foldcolumn=4</b><span>

This will show a small column on the left of the window to indicate folds.
A &quot;+&quot; is shown for a closed fold.  A &quot;-&quot; is shown at the start of each open
fold and &quot;|&quot; at following lines of the fold.

You can use the mouse to open a fold by clicking on the &quot;+&quot; in the foldcolumn.
Clicking on the &quot;-&quot; or a &quot;|&quot; below it will close an open fold.

To open all folds at the cursor line use <span class="highlight"><i>|zO|</i><span>.
To close all folds at the cursor line use <span class="highlight"><i>|zC|</i><span>.
To delete a fold at the cursor line use <span class="highlight"><i>|zd|</i><span>.
To delete all folds at the cursor line use <span class="highlight"><i>|zD|</i><span>.

When in Insert mode, the fold at the cursor line is never closed.  That allows
you to see what you type!

Folds are opened automatically when jumping around or moving the cursor left
or right.  For example, the &quot;0&quot; command opens the fold under the cursor
(if <span class="highlight"><i>'foldopen'</i></font></span> contains &quot;hor&quot;, which is the default).  The <span class="highlight"><i>'foldopen'</i><span> option
can be changed to open folds for specific commands.  If you want the line
under the cursor always to be open, do this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set foldopen=all</b><span>

Warning: You won't be able to move onto a closed fold then.  You might want to
use this only temporarily and then set it back to the default:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set foldopen&amp;</b><span>

You can make folds close automatically when you move out of it:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set foldclose=all</b><span>

This will re-apply <span class="highlight"><i>'foldlevel'</i><span> to all folds that don't contain the cursor.
You have to try it out if you like how this feels.  Use <span class="highlight"><i>|zm|</i><span> to fold more and
<span class="highlight"><i>|zr|</i><span> to fold less (reduce folds).

The folding is local to the window.  This allows you to open two windows on
the same buffer, one with folds and one without folds.  Or one with all folds
closed and one with all folds open.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*28.4*</i></b><span>  Saving and restoring folds

When you abandon a file (starting to edit another one), the state of the folds
is lost.  If you come back to the same file later, all manually opened and
closed folds are back to their default.  When folds have been created
manually, all folds are gone!  To save the folds use the <span class="highlight"><i>|:mkview|</i><span> command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :mkview</b><span>

This will store the settings and other things that influence the view on the
file.  You can change what is stored with the <span class="highlight"><i>'viewoptions'</i><span> option.
When you come back to the same file later, you can load the view again:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :loadview</b><span>

You can store up to ten views on one file.  For example, to save the current
setup as the third view and load the second view:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :mkview 3</b><span>
<span class="highlight"><b>        :loadview 2</b><span>

<span class="highlight"><b><i><u>Note</u></i></b><span> that when you insert or delete lines the views might become invalid.
Also check out the <span class="highlight"><i>'viewdir'</i><span> option, which specifies where the views are
stored.  You might want to delete old views now and then.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*28.5*</i></b><span>  Folding by indent

Defining folds with <span class="highlight"><i>|zf|</i><span> is a lot of work.  If your text is structured by
giving lower level items a larger indent, you can use the indent folding
method.  This will create folds for every sequence of lines with the same
indent.  Lines with a larger indent will become nested folds.  This works well
with many programming languages.

Try this by setting the <span class="highlight"><i>'foldmethod'</i><span> option:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set foldmethod=indent</b><span>

Then you can use the <span class="highlight"><i>|zm|</i></font></span> and <span class="highlight"><i>|zr|</i><span> commands to fold more and reduce folding.
It's easy to see on this example text:

This line is not indented
        This line is indented once
                This line is indented twice
        This line is indented once
This line is not indented
        This line is indented once
        This line is indented once

<span class="highlight"><b><i><u>Note</u></i></b><span> that the relation between the amount of indent and the fold depth depends
on the <span class="highlight"><i>'shiftwidth'</i></font></span> option.  Each <span class="highlight"><i>'shiftwidth'</i><span> worth of indent adds one to the
depth of the fold.  This is called a fold level.

When you use the <span class="highlight"><i>|zr|</i></font></span> and <span class="highlight"><i>|zm|</i><span> commands you actually increase or decrease the
<span class="highlight"><i>'foldlevel'</i><span> option.  You could also set it directly:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set foldlevel=3</b><span>

This means that all folds with three times a <span class="highlight"><i>'shiftwidth'</i><span> indent or more will
be closed.  The lower the foldlevel, the more folds will be closed.  When
<span class="highlight"><i>'foldlevel'</i></font></span> is zero, all folds are closed.  <span class="highlight"><i>|zM|</i><span> does set <span class="highlight"><i>'foldlevel'</i><span> to zero.
The opposite command <span class="highlight"><i>|zR|</i></font></span> sets <span class="highlight"><i>'foldlevel'</i><span> to the deepest fold level that is
present in the file.

Thus there are two ways to open and close the folds:
(A) By setting the fold level.
    This gives a very quick way of &quot;zooming out&quot; to view the structure of the
    text, move the cursor, and &quot;zoom in&quot; on the text again.

(B) By using <span class="highlight"><i>|zo|</i></font></span> and <span class="highlight"><i>|zc|</i><span> commands to open or close specific folds.
    This allows opening only those folds that you want to be open, while other
    folds remain closed.

This can be combined: You can first close most folds by using <span class="highlight"><i>|zm|</i><span> a few times
and then open a specific fold with <span class="highlight"><i>|zo|</i></font></span>.  Or open all folds with <span class="highlight"><i>|zR|</i><span> and
then close specific folds with <span class="highlight"><i>|zc|</i><span>.

But you cannot manually define folds when <span class="highlight"><i>'foldmethod'</i><span> is &quot;indent&quot;, as that
would conflict with the relation between the indent and the fold level.

More about folding by indent in the reference manual: <span class="highlight"><i>|fold-indent|</i><span>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*28.6*</i></b><span>  Folding with markers

Markers in the text are used to specify the start and end of a fold region.
This gives precise control over which lines are included in a fold.  The
disadvantage is that the text needs to be modified.

Try it:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set foldmethod=marker</b><span>

Example text, as it could appear in a C program:

        /* foobar () {{{ */
        int foobar()
        {
                /* return a value {{{ */
                return 42;
                /* }}} */
        }
        /* }}} */

Notice that the folded line will display the text before the marker.  This is
very useful to tell what the fold contains.

It's quite annoying when the markers don't pair up correctly after moving some
lines around.  This can be avoided by using numbered markers.  Example:

        /* global variables {{{1 */
        int varA, varB;

        /* functions {{{1 */
        /* funcA() {{{2 */
        void funcA() {}

        /* funcB() {{{2 */
        void funcB() {}
        /* }}}1 */

At every numbered marker a fold at the specified level begins.  This will make
any fold at a higher level stop here.  You can just use numbered start markers
to define all folds.  Only when you want to explicitly stop a fold before
another starts you need to add an end marker.

More about folding with markers in the reference manual: <span class="highlight"><i>|fold-marker|</i><span>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*28.7*</i></b><span>  Folding by syntax

For each language Vim uses a different syntax file.  This defines the colors
for various items in the file.  If you are reading this in Vim, in a terminal
that supports colors, the colors you see are made with the &quot;help&quot; syntax file.
   In the syntax files it is possible to add syntax items that have the &quot;fold&quot;
argument.  These define a fold region.  This requires writing a syntax file
and adding these items in it.  That's not so easy to do.  But once it's done,
all folding happens automatically.
   Here we'll assume you are using an existing syntax file.  Then there is
nothing more to explain.  You can open and close folds as explained above.
The folds will be created and deleted automatically when you edit the file.

More about folding by syntax in the reference manual: <span class="highlight"><i>|fold-syntax|</i><span>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*28.8*</i></b><span>  Folding by expression

This is similar to folding by indent, but instead of using the indent of a
line a user function is called to compute the fold level of a line.  You can
use this for text where something in the text indicates which lines belong
together.  An example is an e-mail message where the quoted text is indicated
by a &quot;&gt;&quot; before the line.  To fold these quotes use this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set foldmethod=expr</b><span>
<span class="highlight"><b>        :set foldexpr=strlen(substitute(substitute(getline(v:lnum),'\\s','',\&quot;g\&quot;),'[^&gt;].*','',''))</b><span>

You can try it out on this text:

&gt; quoted text he wrote
&gt; quoted text he wrote
&gt; &gt; double quoted text I wrote
&gt; &gt; double quoted text I wrote

Explanation for the <span class="highlight"><i>'foldexpr'</i><span> used in the example (inside out):
   getline(v:lnum)                      gets the current line
   substitute(...,'\\s','','g')         removes all white space from the line
   substitute(...,'[^&gt;].*','',''))      removes everything after leading '&gt;'s
   strlen(...)                          counts the length of the string, which
                                        is the number of '&gt;'s found

<span class="highlight"><b><i><u>Note</u></i></b><span> that a backslash must be inserted before every space, double quote and
backslash for the &quot;:set&quot; command.  If this confuses you, do<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set foldexpr</b><span>

to check the actual resulting value.  To correct a complicated expression, use
the command-line completion:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set foldexpr=&lt;Tab&gt;</b><span>

Where <span class="highlight"><i>&lt;Tab&gt;</i><span> is a real Tab.  Vim will fill in the previous value, which you can
then edit.

More about folding by expression in the reference manual: <span class="highlight"><i>|fold-expr|</i><span>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*28.9*</i></b><span>  Folding unchanged lines

This is useful when you set the <span class="highlight"><i>'diff'</i><span> option in the same window.  The
<span class="highlight"><i>|vimdiff|</i><span> command does this for you.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        setlocal diff foldmethod=diff scrollbind nowrap foldlevel=1</b><span>

Do this in every window that shows a different version of the same file.  You
will clearly see the differences between the files, while the text that didn't
change is folded.

For more details see <span class="highlight"><i>|fold-diff|</i><span>.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*28.10*</i></b><span> Which fold method to use?

All these possibilities makes you wonder which method you should chose.
Unfortunately, there is no golden rule.  Here are some hints.

If there is a syntax file with folding for the language you are editing, that
is probably the best choice.  If there isn't one, you might try to write it.
This requires a good knowledge of search patterns.  It's not easy, but when
it's working you will not have to define folds manually.

Typing commands to manually fold regions can be used for unstructured text.
Then use the <span class="highlight"><i>|:mkview|</i><span> command to save and restore your folds.

The marker method requires you to change the file.  If you are sharing the
files with other people or you have to meet company standards, you might not
be allowed to add them.
   The main advantage of markers is that you can put them exactly where you
want them.  That avoids that a few lines are missed when you cut and paste
folds.  And you can add a comment about what is contained in the fold.

Folding by indent is something that works in many files, but not always very
well.  Use it when you can't use one of the other methods.  However, it is
very useful for outlining.  Then you specifically use one <span class="highlight"><i>'shiftwidth'</i><span> for
each nesting level.

Folding with expressions can make folds in almost any structured text.  It is
quite simple to specify, especially if the start and end of a fold can easily
be recognized.
   If you use the &quot;expr&quot; method to define folds, but they are not exactly how
you want them, you could switch to the &quot;manual&quot; method.  This will not remove
the defined folds.  Then you can delete or add folds manually.

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_29.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2001 Sep 09


                            Moving through programs


The creator of Vim is a computer programmer.  It's no surprise that Vim
contains many features to aid in writing programs.  Jump around to find where
identifiers are defined and used.  Preview declarations in a separate window.
There is more in the next chapter.

<span class="highlight"><i>|29.1|</i><span>  Using tags
<span class="highlight"><i>|29.2|</i><span>  The preview window
<span class="highlight"><i>|29.3|</i><span>  Moving through a program
<span class="highlight"><i>|29.4|</i><span>  Finding global identifiers
<span class="highlight"><i>|29.5|</i><span>  Finding local identifiers


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*29.1*</i></b><span>  Using tags

What is a tag?  It is a location where an identifier is defined.  An example
is a function definition in a C or C++ program.  A list of tags is kept in a
tags file.  This can be used by Vim to directly jump from any place to the
tag, the place where an identifier is defined.
   To generate the tags file for all C files in the current directory, use the
following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        ctags *.c</b><span>

&quot;ctags&quot; is a separate program.  Most Unix systems already have it installed.
If you do not have it yet, you can find Exuberant ctags here:

<span class="highlight"><b>        http://ctags.sf.net </b><span><font color="#e5e5e5">~</font>

Now when you are in Vim and you want to go to a function definition, you can
jump to it by using the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :tag startlist</b><span>

This command will find the function &quot;startlist&quot; even if it is in another file.
   The <span class="highlight"><i>CTRL-]</i><span> command jumps to the tag of the word that is under the cursor.
This makes it easy to explore a tangle of C code.  Suppose, for example, that
you are in the function &quot;write_block&quot;.  You can see that it calls
&quot;write_line&quot;.  But what does &quot;write_line&quot; do?  By placing the cursor on the
call to &quot;write_line&quot; and pressing <span class="highlight"><i>CTRL-]</i><span>, you jump to the definition of this
function.
   The &quot;write_line&quot; function calls &quot;write_char&quot;.  You need to figure out what
it does.  So you position the cursor over the call to &quot;write_char&quot; and press
<span class="highlight"><i>CTRL-]</i><span>.  Now you are at the definition of &quot;write_char&quot;.

        +-------------------------------------+
        |void write_block(char **s; int cnt)  |
        |{                                    |
        |   int i;                            |
        |   for (i = 0; i &lt; cnt; ++i)         |
        |      write_line(s[i);               |
        |}          |                         |
        +-----------|-------------------------+
                    |
             <span class="highlight"><i>CTRL-]</i><span> |
                    |    +----------------------------+
                    +--&gt; |void write_line(char *s)    |
                         |{                           |
                         |   while (*s != 0)          |
                         |      write_char(*s++);     |
                         |}       |                   |
                         +--------|-------------------+
                                  |
                           <span class="highlight"><i>CTRL-]</i><span> |
                                  |    +------------------------------------+
                                  +--&gt; |void write_char(char c)             |
                                       |{                                   |
                                       |    putchar((int)(unsigned char)c); |
                                       |}                                   |
                                       +------------------------------------+

The &quot;:tags&quot; command shows the list of tags that you traversed through:

        :tags
<span class="highlight"><b>          # TO tag         FROM line  in file/text </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>          1  1 write_line          8  write_block.c </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>          2  1 write_char          7  write_line.c </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        &gt; </b><span><font color="#e5e5e5">~</font>
<font color="#e5e5e5">&gt;</font>
Now to go back.  The <span class="highlight"><i>CTRL-T</i><span> command goes to the preceding tag.  In the example
above you get back to the &quot;write_line&quot; function, in the call to 'write_char&quot;.
   This command takes a count argument that indicates how many tags to jump
back.  You have gone forward, and now back.  Let's go forward again.  The
following command goes to the tag on top of the list:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :tag</b><span>

You can prefix it with a count and jump forward that many tags.  For example:
&quot;:3tag&quot;.  <span class="highlight"><i>CTRL-T</i><span> also can be preceded with a count.
   These commands thus allow you to go down a call tree with <span class="highlight"><i>CTRL-]</i><span> and back
up again with <span class="highlight"><i>CTRL-T</i><span>.  Use &quot;:tags&quot; to find out where you are.


SPLIT WINDOWS

The &quot;:tag&quot; command replaces the file in the current window with the one
containing the new function.  But suppose you want to see not only the old
function but also the new one?  You can split the window using the &quot;:split&quot;
command followed by the &quot;:tag&quot; command.  Vim has a shorthand command that does
both:<font color="#e5e5e5"> &gt;</font>
<span class="highlight"><b>        :stag tagname</b><span>

To split the current window and jump to the tag under the cursor use this
command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        CTRL-W ]</b><span>

If a count is specified, the new window will be that many lines high.


MORE TAGS FILES

When you have files in many directories, you can create a tags file in each of
them.  Vim will then only be able to jump to tags within that directory.
   To find more tags files, set the <span class="highlight"><i>'tags'</i><span> option to include all the relevant
tags files.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set tags=./tags,./../tags,./*/tags</b><span>

This finds a tags file in the same directory as the current file, one
directory level higher and in all subdirectories.
   This is quite a number of tags files, but it may still not be enough.  For
example, when editing a file in &quot;~/proj/src&quot;, you will not find the tags file
&quot;~/proj/sub/tags&quot;.  For this situation Vim offers to search a whole directory
tree for tags files.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set tags=~/proj/**/tags</b><span>


ONE TAGS FILE

When Vim has to search many places for tags files, you can hear the disk
rattling.  It may get a bit slow.  In that case it's better to spend this
time while generating one big tags file.  You might do this overnight.
   This requires the Exuberant ctags program, mentioned above.  It offers an
argument to search a whole directory tree:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        cd ~/proj</b><span>
<span class="highlight"><b>        ctags -R .</b><span>

The nice thing about this is that Exuberant ctags recognizes various file
types.  Thus this doesn't work just for C and C++ programs, also for Eiffel
and even Vim scripts.  See the ctags documentation to tune this.
   Now you only need to tell Vim where your big tags file is:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set tags=~/proj/tags</b><span>


MULTIPLE MATCHES

When a function is defined multiple times (or a method in several classes),
the &quot;:tag&quot; command will jump to the first one.  If there is a match in the
current file, that one is used first.
   You can now jump to other matches for the same tag with:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :tnext</b><span>

Repeat this to find further matches.  If there are many, you can select which
one to jump to:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :tselect tagname</b><span>

Vim will present you with a list of choices:

<span class="highlight"><b>          # pri kind tag               file </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>          1 F   f    mch_init          os_amiga.c </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                       mch_init() </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>          2 F   f    mch_init          os_mac.c </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                       mch_init() </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>          3 F   f    mch_init          os_msdos.c </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                       mch_init(void) </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>          4 F   f    mch_init          os_riscos.c </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                       mch_init() </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        Enter nr of choice (&lt;CR&gt; to abort):  </b><span><font color="#e5e5e5">~</font>

You can now enter the number (in the first column) of the match that you would
like to jump to.  The information in the other columns give you a good idea of
where the match is defined.

To move between the matching tags, these commands can be used:

        :tfirst                 go to first match
        :<span class="highlight"><i>[count]</i></font></span>tprevious       go to <span class="highlight"><i>[count]</i><span> previous match
        :<span class="highlight"><i>[count]</i></font></span>tnext           go to <span class="highlight"><i>[count]</i><span> next match
        :tlast                  go to last match

If <span class="highlight"><i>[count]</i><span> is omitted then one is used.


GUESSING TAG NAMES

Command line completion is a good way to avoid typing a long tag name.  Just
type the first bit and press <span class="highlight"><i>&lt;Tab&gt;</i><span>:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :tag write_&lt;Tab&gt;</b><span>

You will get the first match.  If it's not the one you want, press <span class="highlight"><i>&lt;Tab&gt;</i><span> until
you find the right one.
   Sometimes you only know part of the name of a function.  Or you have many
tags that start with the same string, but end differently.  Then you can tell
Vim to use a pattern to find the tag.
   Suppose you want to jump to a tag that contains &quot;block&quot;.  First type
this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :tag /block</b><span>

Now use command line completion: press <span class="highlight"><i>&lt;Tab&gt;</i><span>.  Vim will find all tags that
contain &quot;block&quot; and use the first match.
   The &quot;/&quot; before a tag name tells Vim that what follows is not a literal tag
name, but a pattern.  You can use all the items for search patterns here.  For
example, suppose you want to select a tag that starts with &quot;write_&quot;:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :tselect /^write_</b><span>

The &quot;^&quot; specifies that the tag starts with &quot;write&quot;.  Otherwise it would also
be found halfway a tag name.  Similarly &quot;$&quot; at the end makes sure the pattern
matches until the end of a tag.


A TAGS BROWSER

Since <span class="highlight"><i>CTRL-]</i><span> takes you to the definition of the identifier under the cursor,
you can use a list of identifier names as a table of contents.  Here is an
example.
   First create a list of identifiers (this requires Exuberant ctags):<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        ctags --c-types=f -f functions *.c</b><span>

Now start Vim without a file, and edit this file in Vim, in a vertically split
window:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        vim</b><span>
<span class="highlight"><b>        :vsplit functions</b><span>

The window contains a list of all the functions.  There is some more stuff,
but you can ignore that.  Do &quot;:set ts=99&quot; to clean it up a bit.
   In this window, define a mapping:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :nmap &lt;buffer&gt; &lt;CR&gt; 0ye&lt;C-W&gt;w:tag &lt;C-R&gt;&quot;&lt;CR&gt;</b><span>

Move the cursor to the line that contains the function you want to go to.
Now press <span class="highlight"><i>&lt;Enter&gt;</i><span>.  Vim will go to the other window and jump to the selected
function.


RELATED ITEMS

You can set <span class="highlight"><i>'ignorecase'</i><span> to make case in tag names be ignored.

The <span class="highlight"><i>'tagbsearch'</i><span> option tells if the tags file is sorted or not.  The default
is to assume a sorted tags file, which makes a tags search a lot faster, but
doesn't work if the tags file isn't sorted.

The <span class="highlight"><i>'taglength'</i><span> option can be used to tell Vim the number of significant
characters in a tag.

When you use the SNiFF+ program, you can use the Vim interfact to it <span class="highlight"><i>|sniff|</i><span>.
SNiFF+ is a commercial program.

Cscope is a free program.  I does not only find places where an identifier is
declared, but also where it is used.  See <span class="highlight"><i>|cscope|</i><span>.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*29.2*</i></b><span>  The preview window

When you edit code that contains a function call, you need to use the correct
arguments.  To know what values to pass you can look at how the function is
defined.  The tags mechanism works very well for this.  Preferably the
definition is displayed in another window.  For this the preview window can be
used.
   To open a preview window to display the function &quot;write_char&quot;:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :ptag write_char</b><span>

Vim will open a window, and jumps to the tag &quot;write_char&quot;.  Then it takes you
back to the original position.  Thus you can continue typing without the need
to use a <span class="highlight"><i>CTRL-W</i><span> command.
   If the name of a function appears in the text, you can get its definition
in the preview window with:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        CTRL-W }</b><span>

There is a script that automatically displays the text where the word under
the cursor was defined.  See <span class="highlight"><i>|CursorHold-example|</i><span>

To close the preview window again, use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :pclose</b><span>

To edit a specific file in the preview window, use &quot;:pedit&quot;.  This can be
useful to edit a header file, for example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :pedit defs.h</b><span>

Finally, &quot;:psearch&quot; can be used to find a word in the current file and any
included files and display the match in the preview window.  This is
especially useful when using library functions, for which you do not have a
tags file.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :psearch popen</b><span>

This will show the &quot;stdio.h&quot; file in the preview window, with the function
prototype for popen():

<span class="highlight"><b>        FILE    *popen __P((const char *, const char *)); </b><span><font color="#e5e5e5">~</font>

You can specify the height of the preview window, when it is opened, with the
<span class="highlight"><i>'previewheight'</i><span> option.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*29.3*</i></b><span>  Moving through a program

Since a program is structured, Vim can recognize items in it.  Specific
commands can be used to move around.
   C programs often contain constructs like this:

<span class="highlight"><b>        #ifdef USE_POPEN </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>            fd = popen(&quot;ls&quot;, &quot;r&quot;) </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        #else </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>            fd = fopen(&quot;tmp&quot;, &quot;w&quot;) </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        #endif </b><span><font color="#e5e5e5">~</font>

But then much longer, and possibly nested.  Position the cursor on the
&quot;#ifdef&quot; and press %.  Vim will jump to the &quot;#else&quot;.  Pressing % again takes
you to the &quot;#endif&quot;.  Another % takes you to the &quot;#ifdef&quot; again.
   When the construct is nested, Vim will find the matching items.  This is a
good way to check if you didn't forget an &quot;#endif&quot;.
   When you are somewhere inside a &quot;#if&quot; - &quot;#endif&quot;, you can jump to the start
of it with:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        [#</b><span>

If you are not after a &quot;#if&quot; or &quot;#ifdef&quot; Vim will beep.  To jump forward to
the next &quot;#else&quot; or &quot;#endif&quot; use:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        ]#</b><span>

These two commands skip any &quot;#if&quot; - &quot;#endif&quot; blocks that it encounters.
Example:

<span class="highlight"><b>        #if defined(HAS_INC_H) </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>            a = a + inc(); </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        # ifdef USE_THEME </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>            a += 3; </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        # endif </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>            set_width(a); </b><span><font color="#e5e5e5">~</font>

With the cursor in the last line, &quot;[#&quot; moves to the first line.  The &quot;#ifdef&quot;
- &quot;#endif&quot; block in the middle is skipped.


MOVING IN CODE BLOCKS

In C code blocks are enclosed in {}.  These can get pretty long.  To move to
the start of the outer block use the &quot;[[&quot; command.  Use &quot;]]&quot; to find the end.
This assumes that the &quot;{&quot; and &quot;}&quot; are in the first column.
   The &quot;[{&quot; command moves to the start of the current block.  It skips over
pairs of {} at the same level.  &quot;]}&quot; jumps to the end.
   An overview:

                        function(int a)
           +-&gt;          {
           |                if (a)
           |       +-&gt;      {
        [[ |       |            for (;;)               --+
           |       |      +-&gt;   {                        |
           |    [{ |      |         foo(32);             |     --+
           |       |   [{ |         if (bar(a))  --+     | ]}    |
           +--     |      +--           break;     | ]}  |       |
                   |            }                &lt;-+     |       | ]]
                   +--          foobar(a)                |       |
                            }                          &lt;-+       |
                        }                                      &lt;-+

When writing C++ or Java, the outer {} block is for the class.  The next level
of {} is for a method.  When somewhere inside a class use &quot;[m&quot; to find the
previous start of a method.  &quot;]m&quot; finds the next end of a method.

Additionally, &quot;[]&quot; moves backward to the end of a function and &quot;][&quot; moves
forward to the end of a function.  The end of a function is defined by a &quot;}&quot;
in the first column.

                                int func1(void)
                                {
                                        return 1;
                  +----------&gt;  }
                  |
              []  |             int func2(void)
                  |        +-&gt;  {
                  |    [[  |            if (flag)
        start     +--      +--                  return flag;
                  |    ][  |            return 2;
                  |        +-&gt;  }
              ]]  |
                  |             int func3(void)
                  +----------&gt;  {
                                        return 3;
                                }

Don't forget you can also use &quot;%&quot; to move between matching (), {} and [].
That also works when they are many lines apart.


MOVING IN BRACES

The &quot;[(&quot; and &quot;])&quot; commands work similar to &quot;[{&quot; and &quot;]}&quot;, except that they
work on () pairs instead of {} pairs.
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>                                  [(</b><span>
<font color="#e5e5e5">&lt;</font>                   &lt;--------------------------------
                              &lt;-------
<span class="highlight"><b>                if (a == b &amp;&amp; (c == d || (e &gt; f)) &amp;&amp; x &gt; y) </b><span><font color="#e5e5e5">~</font>
                                  --------------&gt;
                          --------------------------------&gt;<font color="#e5e5e5"> &gt;</font>
<span class="highlight"><b>                                       ])</b><span>

MOVING IN COMMENTS

To move back to the start of a comment use &quot;[/&quot;.  Move forward to the end of a
comment with &quot;]/&quot;.  This only works for /* - */ comments.

          +-&gt;     +-&gt; /*
          |    [/ |    * A comment about      --+
       [/ |       +--  * wonderful life.        | ]/
          |            */                     &lt;-+
          |
          +--          foo = bar * 3;         --+
                                                | ]/
                       /* a short comment */  &lt;-+

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*29.4*</i></b><span>  Finding global identifiers

You are editing a C program and wonder if a variable is declared as &quot;int&quot; or
&quot;unsigned&quot;.  A quick way to find this is with the &quot;[I&quot; command.
   Suppose the cursor is on the word &quot;column&quot;.  Type:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        [I</b><span>

Vim will list the matching lines it can find.  Not only in the current file,
but also in all included files (and files included in them, etc.).  The result
looks like this:

<span class="highlight"><b>        structs.h </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>         1:   29     unsigned     column;    /* column number */ </b><span><font color="#e5e5e5">~</font>

The advantage over using tags or the preview window is that included files are
searched.  In most cases this results in the right declaration to be found.
Also when the tags file is out of date.  Also when you don't have tags for the
included files.
   However, a few things must be right for &quot;[I&quot; to do its work.  First of all,
the <span class="highlight"><i>'include'</i><span> option must specify how a file is included.  The default value
works for C and C++.  For other languages you will have to change it.


LOCATING INCLUDED FILES

   Vim will find included files in the places specified with the <span class="highlight"><i>'path'</i><span>
option.  If a directory is missing, some include files will not be found.  You
can discover this with this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :checkpath</b><span>

It will list the include files that could not be found.  Also files included
by the files that could be found.  An example of the output:

<span class="highlight"><b>        --- Included files not found in path --- </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        &lt;io.h&gt; </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        vim.h --&gt; </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>          &lt;functions.h&gt; </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>          &lt;clib/exec_protos.h&gt; </b><span><font color="#e5e5e5">~</font>

The &quot;io.h&quot; file is included by the current file and can't be found.  &quot;vim.h&quot;
can be found, thus &quot;:checkpath&quot; goes into this file and checks what it
includes.  The &quot;functions.h&quot; and &quot;clib/exec_protos.h&quot; files, included by
&quot;vim.h&quot; are not found.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        Vim is not a compiler.  It does not recognize &quot;#ifdef&quot; statements.
        This means every &quot;#include&quot; statement is used, also when it comes
        after &quot;#if NEVER&quot;.

To fix the files that could not be found, add a directory to the <span class="highlight"><i>'path'</i><span>
option.  A good place to find out about this is the Makefile.  Look out for
lines that contain &quot;-I&quot; items, like &quot;-I/usr/local/X11&quot;.  To add this directory
use:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set path+=/usr/local/X11</b><span>

When there are many subdirectories, you an use the &quot;*&quot; wildcard.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set path+=/usr/*/include</b><span>

This would find files in &quot;/usr/local/include&quot; as well as &quot;/usr/X11/include&quot;.

When working on a project with a whole nested tree of included files, the &quot;**&quot;
items is useful.  This will search down in all subdirectories.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set path+=/projects/invent/**/include</b><span>

This will find files in the directories:

<span class="highlight"><b>        /projects/invent/include </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        /projects/invent/main/include </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        /projects/invent/main/os/include </b><span><font color="#e5e5e5">~</font>
        etc.

There are even more possibilities.  Check out the <span class="highlight"><i>'path'</i><span> option for info.
   If you want to see which included files are actually found, use this
command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :checkpath!</b><span>

You will get a (very long) list of included files, the files they include, and
so on.  To shorten the list a bit, Vim shows &quot;(Already listed)&quot; for files that
were found before and doesn't list the included files in there again.


JUMPING TO A MATCH

&quot;[I&quot; produces a list with only one line of text.  When you want to have a
closer look at the first item, you can jump to that line with the command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        [&lt;Tab&gt;</b><span>

You can also use &quot;[ <span class="highlight"><i>CTRL-I</i></font></span>&quot;, since <span class="highlight"><i>CTRL-I</i><span> is the same as pressing <span class="highlight"><i>&lt;Tab&gt;</i><span>.

The list that &quot;[I&quot; produces has a number at the start of each line.  When you
want to jump to another item than the first one, type the number first:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        3[&lt;Tab&gt;</b><span>

Will jump to the third item in the list.  Remember that you can use <span class="highlight"><i>CTRL-O</i><span> to
jump back to where you started from.


RELATED COMMANDS

        [i              only lists the first match
        ]I              only lists items below the cursor
        ]i              only lists the first item below the cursor


FINDING DEFINED IDENTIFIERS

The &quot;[I&quot; command finds any identifier.  To find only macros, defined with
&quot;#define&quot; use:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        [D</b><span>

Again, this searches in included files.  The <span class="highlight"><i>'define'</i><span> option specifies what a
line looks like that defines the items for &quot;[D&quot;.  You could change it to make
it work with other languages than C or C++.
   The commands related to &quot;[D&quot; are:

        [d              only lists the first match
        ]D              only lists items below the cursor
        ]d              only lists the first item below the cursor

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*29.5*</i></b><span>  Finding local identifiers

The &quot;[I&quot; command searches included files.  To search in the current file only,
and jump to the first place where the word under the cursor is used:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        gD</b><span>

Hint: Goto Definition.  This command is very useful to find a variable or
function that was declared locally (&quot;static&quot;, in C terms).  Example (cursor on
&quot;counter&quot;):

           +-&gt;   static int counter = 0;
           |
           |     int get_counter(void)
        gD |     {
           |         ++counter;
           +--       return counter;
                 }

To restrict the search even further, and look only in the current function,
use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        gd</b><span>

This will go back to the start of the current function and find the first
occurrence of the word under the cursor.  Actually, it searches backwards to
an empty line above the a &quot;{&quot; in the first column.  From there it searches
forward for the identifier.  Example (cursor on &quot;idx&quot;):

                int find_entry(char *name)
                {
           +-&gt;      int idx;
           |
        gd |        for (idx = 0; idx &lt; table_len; ++idx)
           |            if (strcmp(table[idx].name, name) == 0)
           +--              return idx;
                }

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_30.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2001 Oct 23


                              Editing programs


Vim has various commands that aid in writing computer programs.  Compile a
program and directly jump to reported errors.  Automatically set the indent
for many languages and format comments.

<span class="highlight"><i>|30.1|</i><span>  Compiling
<span class="highlight"><i>|30.2|</i><span>  Indenting C files
<span class="highlight"><i>|30.3|</i><span>  Automatic indenting
<span class="highlight"><i>|30.4|</i><span>  Other indenting
<span class="highlight"><i>|30.5|</i><span>  Tabs and spaces
<span class="highlight"><i>|30.6|</i><span>  Formatting comments


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*30.1*</i></b><span>  Compiling

Vim has a set of so called &quot;quickfix&quot; commands.  They enable you to compile a
program from within Vim and then go through the errors generated and fix them
(hopefully).  You can then recompile and fix any new errors that are found
until finally your program compiles without any error.

The following command runs the program &quot;make&quot; (supplying it with any argument
you give) and captures the results:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :make {arguments}</b><span>

If errors were generated, they are captured and the editor positions you where
the first error occurred.
   Take a look at an example &quot;:make&quot; session. (Typical :make sessions generate
far more errors and fewer stupid ones.)  After typing &quot;:make&quot; the screen looks
like this:

<span class="highlight"><b>        :!make | &amp;tee /tmp/vim215953.err </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        gcc -g -Wall -o prog main.c sub.c </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        main.c: In function 'main': </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        main.c:6: too many arguments to function 'do_sub' </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        main.c: At top level: </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        main.c:10: parse error before '}' </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        make: *** [prog] Error 1 </b><span><font color="#e5e5e5">~</font>

<span class="highlight"><b>        2 returned </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        &quot;main.c&quot; 11L, 111C </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        (3 of 6): too many arguments to function 'do_sub' </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        Hit ENTER or type command to continue </b><span><font color="#e5e5e5">~</font>

From this you can see that you have errors in the file &quot;main.c&quot;.  When you
press Enter, Vim displays the file &quot;main.c&quot;, with the cursor positioned on
line 6, the first line with an error.  You did not need to specify the file or
the line number, Vim knew where to go by looking in the error messages.

                +---------------------------------------------------+
                |int main()                                         |
                |{                                                  |
                |       int i=3;                                    |
      cursor -&gt; |       do_sub(&quot;foo&quot;);                              |
                |       ++i;                                        |
                |       return (0);                                 |
                |}                                                  |
                |}                                                  |
                | ~                                                 |
                |(3 of 12): too many arguments to function 'do_sub' |
                +---------------------------------------------------+

The following command goes to where the next error occurs:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :cnext</b><span>

Vim jumps to line 10, the last line in the file, where there is an extra '}'.
   When there is not enough room, Vim will shorten the error message.  To see
the whole message use:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :cc</b><span>

You can get an overview of all the error messages with the &quot;:clist&quot; command.
The output looks like this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :clist</b><span>
<font color="#e5e5e5">&lt;</font><span class="highlight"><b>       3 main.c: 6:too many arguments to function 'do_sub' </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        5 main.c: 10:parse error before '}' </b><span><font color="#e5e5e5">~</font>

Only the lines where Vim recognized a file name and line number are listed
here.  It assumes those are the interesting lines and the rest is just boring
messages.  However, sometimes unrecognized lines do contain something you want
to see.  Output from the linker, for example, about an undefined function.
To see all the messages add a &quot;!&quot; to the command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :clist!</b><span>
<font color="#e5e5e5">&lt;</font><span class="highlight"><b>       1 gcc -g -Wall -o prog main.c sub.c </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        2 main.c: In function 'main': </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        3 main.c:6: too many arguments to function 'do_sub' </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        4 main.c: At top level: </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        5 main.c:10: parse error before '}' </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        6 make: *** [prog] Error 1 </b><span><font color="#e5e5e5">~</font>

Vim will highlight the current error.  To go back to the previous error, use:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        :cprevious</b><span>

Other commands to move around in the error list:

        :cfirst         to first error
        :clast          to last error
        :cc 3           to error nr 3


USING ANOTHER COMPILER

The name of the program to run when the &quot;:make&quot; command is executed is defined
by the <span class="highlight"><i>'makeprg'</i><span> option.  Usually this is set to &quot;make&quot;, but Visual C++ users
should set this to &quot;nmake&quot; by executing the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set makeprg=nmake</b><span>

You can also include arguments in this option.  Special characters need to
be escaped with a backslash.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set makeprg=nmake\ -f\ project.mak</b><span>

You can include special Vim keywords in the command specification.  The %
character expands to the name of the current file.  So if you execute the
command:<font color="#e5e5e5"> &gt;</font>
<span class="highlight"><b>        :set makeprg=make\ %</b><span>

When you are editing main.c, then &quot;:make&quot; executes the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        make main.c</b><span>

This is not too useful, so you will refine the command a little and use the :r
(root) modifier:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set makeprg=make\ %:r.o</b><span>

Now the command executed is as follows:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        make file.o</b><span>

More about these modifiers here: <span class="highlight"><i>|filename-modifiers|</i><span>.


OLD ERROR LISTS

Suppose you &quot;:make&quot; a program.  There is an warning message in one file and an
error message in another.  You fix the error and use &quot;:make&quot; again to check if
it was really fixed.  Now you want to look at the warning message.  It doesn't
show up in the last error list, since the file with the warning wasn't
compiled again.  You can go back to the previous error list with:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :colder</b><span>

Then use &quot;:clist&quot; and &quot;cc <span class="highlight"><i>{nr}</i><span>&quot; to jump to the place with the warning.
   To go forward to the next error list:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :cnewer</b><span>

Vim remembers ten error lists.


SWITCHING COMPILERS

You have to tell Vim what format the error messages are that your compiler
produces.  This is done with the <span class="highlight"><i>'errorformat'</i><span> option.  The syntax of this
option is quite complicated and it can be made to fit almost any compiler.
You can find the explanation here: <span class="highlight"><i>|errorformat|</i><span>.

You might be using various different compilers.  Setting the <span class="highlight"><i>'makeprg'</i><span> option,
and especially the <span class="highlight"><i>'errorformat'</i><span> each time is not easy.  Vim offers a simple
method for this.  For example, to switch to using the Microsoft Visual C++
compiler:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :compiler msvc</b><span>

This will find the Vim script for the &quot;msvc&quot; compiler and set the appropriate
options.
   You can write your own compiler files.  See <span class="highlight"><i>|write-compiler-plugin|</i><span>.


OUTPUT REDIRECTION

The &quot;:make&quot; command redirects the output of the executed program to an error
file.  How this works depends on various things, such as the <span class="highlight"><i>'shell'</i><span>.  If your
&quot;:make&quot; command doesn't capture the output, check the <span class="highlight"><i>'makeef'</i><span> and
<span class="highlight"><i>'shellredir'</i></font></span> options.  The <span class="highlight"><i>'shellquote'</i><span> and <span class="highlight"><i>'shellxquote'</i><span> options might also
matter.

In case you can't get &quot;:make&quot; to redirect the file for you, an alternative is
to compile the program in another window and redirect the output into a file.
Then have Vim read this file with:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :cfile {filename}</b><span>

Jumping to errors will work like with the &quot;:make&quot; command.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*30.2*</i></b><span>  Indenting C files

A program is much easier to understand when the lines have been properly
indented.  Vim offers various ways to make this less work.
   For C programs set the <span class="highlight"><i>'cindent'</i><span> option.  Vim knows a lot about C programs
and will try very hard to automatically set the indent for you.  Set the
<span class="highlight"><i>'shiftwidth'</i><span> option to the amount of spaces you want for a deeper level.  Four
spaces will work fine.  One &quot;:set&quot; command will do it:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set cindent shiftwidth=4</b><span>

With this option enabled, when you type something such as &quot;if (x)&quot;, the next
line will automatically be indented an additional level.

                                    if (flag)
        Automatic indent   ---&gt;         do_the_work();
        Automatic unindent &lt;--      if (other_flag) {
        Automatic indent   ---&gt;         do_file();
        keep indent                     do_some_more();
        Automatic unindent &lt;--      }

When you type something in curly braces ({}), the text will be indented at the
start and unindented at the end.  The unindenting will happen after typing the
'}', since Vim can't guess what you are going to type.

One side effect of automatic indentation is that it helps you catch errors in
your code early.  When you type a } to finish a function, only to find that
the automatic indentation gives it more indent than what you expected, there
is probably a } missing.  Use the &quot;%&quot; command to find out which { matches the
} you typed.
   A missing ) and ; also cause extra indent.  Thus if you get more white
space than you would expect, check the preceding lines.

When you have code that is badly formatted, or you inserted and deleted lines,
you need to re-indent the lines.  The &quot;=&quot; operator does this.  The simplest
form is:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        ==</b><span>

This indents the current line.  Like with all operators, there are three ways
to use it.  In Visual mode &quot;=&quot; indents the selected lines.  A useful text
object is &quot;a{&quot;  This selects the current {} block.  Thus, to re-indent the
code code block the cursor is in:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        =a{</b><span>

I you have really badly indented code, you can re-indent the whole file with:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        gg=G</b><span>

However, don't do this in files that have been carefully indented manually.
The automatic indenting does a good job, but in some situations you might want
to overrule it.


SETTING INDENT STYLE

Different people have different styles of indentation.  By default Vim does a
pretty good job of indenting in a way that 90% of programmers do.  There are
different styles, however; so if you want to, you can customize the
indentation style with the <span class="highlight"><i>'cinoptions'</i><span> option.
   By default <span class="highlight"><i>'cinoptions'</i><span> is empty and Vim uses the default style.  You can
add various items where you want something different.  For example, to make
curly braces be placed like this:

<span class="highlight"><b>        if (flag) </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>          { </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>            i = 8; </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>            j = 0; </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>          } </b><span><font color="#e5e5e5">~</font>

Use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set cinoptions+={2</b><span>

There are many of these items.  See <span class="highlight"><i>|cinoptions-values|</i><span>.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*30.3*</i></b><span>  Automatic indenting

You don't want to switch on the <span class="highlight"><i>'cindent'</i><span> option manually every time you edit
a C file.  This is how you make it work automatically:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :filetype indent on</b><span>

Actually, this does a lot more than switching on <span class="highlight"><i>'cindent'</i><span> for C files.  First
of all, it enables detecting the type of a file.  That's the same as what is
used for syntax highlighting.
   When the filetype is known, Vim will search for an indent file for this
type of file.  The Vim distribution includes a number of these for various
programming languages.  This indent file will then prepare for automatic
indenting specifically for this file.

If you don't like the automatic indenting, you can switch it off again:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :filetype indent off</b><span>

If you don't like the indenting for one specific type of file, this is how you
avoid it.  Create a file with just this one line:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :let b:did_indent = 1</b><span>

Now you need to write this in a file with a specific name:

        <span class="highlight"><i>{directory}</i></font></span>/indent/<span class="highlight"><i>{filetype}</i><span>.vim

The <span class="highlight"><i>{filetype}</i><span> is the name of the file type, such as &quot;cpp&quot; or &quot;java&quot;.  You can
see the exact name that Vim detected with this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set filetype</b><span>

In this file the output is:

<span class="highlight"><b>        filetype=help </b><span><font color="#e5e5e5">~</font>

This you would use &quot;help&quot; for <span class="highlight"><i>{filetype}</i><span>.
   For the <span class="highlight"><i>{directory}</i><span> part you need to use your runtime directory.  Look at
the output of this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        set runtimepath</b><span>

Now use the first item, the name before the first comma.  Thus if the output
looks like this:

<span class="highlight"><b>        runtimepath=~/.vim,/usr/local/share/vim/vim60/runtime,~/.vim/after </b><span><font color="#e5e5e5">~</font>

You use &quot;~/.vim&quot; for <span class="highlight"><i>{directory}</i><span>.  Then the resulting file name is:

<span class="highlight"><b>        ~/.vim/indent/help.vim </b><span><font color="#e5e5e5">~</font>

Instead of switching the indenting off, you could write your own indent file.
How to do that is explained here: <span class="highlight"><i>|indent-expression|</i><span>.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*30.4*</i></b><span>  Other indenting

The most simple form of automatic indenting is with the <span class="highlight"><i>'autoindent'</i><span> option.
It uses the indent from the previous line.  A bit smarter is the <span class="highlight"><i>'smartindent'</i><span>
option.  This is useful for languages where no indent file is available.
<span class="highlight"><i>'smartindent'</i></font></span>is not as smart as <span class="highlight"><i>'cindent'</i><span>, but smarter than <span class="highlight"><i>'autoindent'</i><span>.
   With <span class="highlight"><i>'smartindent'</i><span> set, an extra level of indentation is added for each {
and removed for each }.  An extra level of indentation will also be added for
any of the words in the <span class="highlight"><i>'cinwords'</i><span> option.  Lines that begin with # are
treated specially: all indentation is removed.  This is done so that
preprocessor directives will all start in column 1.  The indentation is
restored for the next line.


CORRECTING INDENTS

When you are using <span class="highlight"><i>'autoindent'</i></font></span> or <span class="highlight"><i>'smartindent'</i><span> to get the indent of the
previous line, there will be many times when you need to add or remove one
<span class="highlight"><i>'shiftwidth'</i></font></span> worth of indent.  A quick way to do this is using the <span class="highlight"><i>CTRL-D</i><span> and
<span class="highlight"><i>CTRL-T</i><span> commands in Insert mode.
   For example, you are typing a shell script that is supposed to look like
this:

<span class="highlight"><b>        if test -n a; then </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>           echo a </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>           echo &quot;-------&quot; </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        fi </b><span><font color="#e5e5e5">~</font>

Start off by setting these option:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set autoindent shiftwidth=3</b><span>

You start by typing the first line, <span class="highlight"><i>&lt;Enter&gt;</i><span> and the start of the second line:

<span class="highlight"><b>        if test -n a; then </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        echo </b><span><font color="#e5e5e5">~</font>

Now you see that you need an extra indent.  Type <span class="highlight"><i>CTRL-T</i><span>.  The result:

<span class="highlight"><b>        if test -n a; then </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>           echo </b><span><font color="#e5e5e5">~</font>

The <span class="highlight"><i>CTRL-T</i></font></span> command, in Insert mode, adds one <span class="highlight"><i>'shiftwidth'</i><span> to the indent, no
matter where in the line you are.
   You continue typing the second line, <span class="highlight"><i>&lt;Enter&gt;</i><span> and the third line.  This time
the indent is OK.  Then <span class="highlight"><i>&lt;Enter&gt;</i><span> and the last line.  Now you have this:

<span class="highlight"><b>        if test -n a; then </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>           echo a </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>           echo &quot;-------&quot; </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>           fi </b><span><font color="#e5e5e5">~</font>

To remove the superfluous indent in the last line press <span class="highlight"><i>CTRL-D</i><span>.  This deletes
one <span class="highlight"><i>'shiftwidth'</i><span> worth of indent, no matter where you are in the line.
   When you are in Normal mode, you can use the &quot;&gt;&gt;&quot; and &quot;&lt;&lt;&quot; commands to
shift lines.  &quot;&gt;&quot; and &quot;&lt;&quot; are operators, thus you have the usual three ways to
specify the lines you want to indent.  A useful combination is:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        &gt;i{</b><span>

This adds one indent to the current block of lines, inside {}.  The { and }
lines themselves are left unmodified.  &quot;&gt;a{&quot; includes them.  In this example
the cursor is on &quot;printf&quot;:

        original text           after &quot;&gt;i{&quot;             after &quot;&gt;a{&quot;

<span class="highlight"><b>        if (flag)               if (flag)               if (flag) </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        {                       {                           { </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        printf(&quot;yes&quot;);              printf(&quot;yes&quot;);          printf(&quot;yes&quot;); </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        flag = 0;                   flag = 0;               flag = 0;  </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        }                       }                           } </b><span><font color="#e5e5e5">~</font>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*30.5*</i></b><span>  Tabs and spaces

<span class="highlight"><i>'tabstop'</i><span> is set to eight by default.  Although you can change it, you quickly
run into trouble later.  Other programs won't know what tabstop value you
used.  They probably use the default value of eight, and your text suddenly
looks very different.  Also, most printers use a fixed tabstop value of eight.
Thus it's best to keep <span class="highlight"><i>'tabstop'</i><span> alone.  (If you edit a file which was written
with a different tabstop setting, see <span class="highlight"><i>|25.3|</i><span> for how to fix that.)
   For indenting lines in a program, using a multiple of eight spaces makes
you quickly run into the right border of the window.  Using a single space
doesn't provide enough visual difference.  Many people prefer to use four
spaces, a good compromise.
   Since a <span class="highlight"><i>&lt;Tab&gt;</i><span> is eight spaces and you want to use an indent of four spaces,
you can't use a <span class="highlight"><i>&lt;Tab&gt;</i><span> character to make your indent.  There are two ways to
handle this:

1.  Use a mix of <span class="highlight"><i>&lt;Tab&gt;</i></font></span> and space characters.  Since a <span class="highlight"><i>&lt;Tab&gt;</i><span> takes the place of
    eight spaces, you have fewer characters in your file.  Inserting a <span class="highlight"><i>&lt;Tab&gt;</i><span>
    is quicker than eight spaces.  Backspacing works faster as well.

2.  Use spaces only.  This avoids the trouble with programs that use a
    different tabstop value.

Fortunately, Vim supports both methods quite well.


SPACES AND TABS

If you are using a combination of tabs and spaces, you just edit normally.
The Vim defaults do a fine job of handling things.
   You can make life a little easier by setting the <span class="highlight"><i>'softtabstop'</i><span> option.
This option tells Vim to make the Tab key look and feel as if tabs were set at
the value of <span class="highlight"><i>'softtabstop'</i><span>, but actually use a combination of tabs and spaces.
   After you execute the following command, every time you press the Tab key
the cursor moves to the next 4-column boundary:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set softtabstop=4</b><span>

When you start in the first column and press <span class="highlight"><i>&lt;Tab&gt;</i><span>, you get 4 spaces inserted
in your text.  The second time, Vim takes out the 4 spaces and puts in a <span class="highlight"><i>&lt;Tab&gt;</i><span>
(thus taking you to column 8).  Thus Vim uses as many <span class="highlight"><i>&lt;Tab&gt;</i><span>s as possible, and
then fills up with spaces.
   When backspacing it works the other way around.  A <span class="highlight"><i>&lt;BS&gt;</i><span> will always delete
the amount specified with <span class="highlight"><i>'softtabstop'</i></font></span>.  Then <span class="highlight"><i>&lt;Tabs&gtgt;</i><span> are used as many as
possible and spaces to fill the gap.
   The following shows what happens pressing <span class="highlight"><i>&lt;Tab&gt;</i><span> a few times, and then using
<span class="highlight"><i>&lt;BS&gt;</i></font></span>.  A &quot;.&quot; stands for a space and &quot;-------&gt;&quot; for a <span class="highlight"><i>&lt;Tab&gt;</i><span>.

<span class="highlight"><b>        type                      result </b><span><font color="#e5e5e5">~</font>
        <span class="highlight"><i>&lt;Tab&gt;</i><span>                     ....
        <span class="highlight"><i>&lt;Tab&gt;&lt;Tab&gt;</i><span>                -------&gt;
        <span class="highlight"><i>&lt;Tab&gt;&lt;Tab&gt;&lt;Tab&gt;</i><span>           -------&gt;....
        <span class="highlight"><i>&lt;Tab&gt;&lt;Tab&gt;&lt;Tab&gt;&lt;BS&gt;</i><span>       -------&gt;
        <span class="highlight"><i>&lt;Tab&gt;&lt;Tab&gt;&lt;Tab&gt;&lt;BS&gt;&lt;BS&gt;</i><span>   ....

An alternative is to use the <span class="highlight"><i>'smarttab'</i><span> option.  When it's set, Vim uses
<span class="highlight"><i>'shiftwidth'</i></font></span> for a <span class="highlight"><i>&lt;Tab&gt;</i><span> typed in the indent of a line, and a real <span class="highlight"><i>&lt;Tab&gt;</i><span> when
typed after the first non-blank character.  However, <span class="highlight"><i>&lt;BS&gt;</i><span> doesn't work like
with <span class="highlight"><i>'softtabstop'</i><span>.


JUST SPACES

If you want absolutely no tabs in your file, you can set the <span class="highlight"><i>'expandtab'</i><span>
option:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set expandtab</b><span>

When this option is set, the <span class="highlight"><i>&lt;Tab&gt;</i><span> key inserts a series of spaces.  Thus you
get the same amount of white space as if a <span class="highlight"><i>&lt;Tab&gt;</i><span> character was inserted, but
there isn't a real <span class="highlight"><i>&lt;Tab&gt;</i><span> character in your file.
   The backspace key will delete each space by itself.  Thus after typing one
<span class="highlight"><i>&lt;Tab&gt;</i></font></span> you have to press the <span class="highlight"><i>&lt;BS&gt;</i><span> key up to eight times to undo it.  If you are
in the indent, pressing <span class="highlight"><i>CTRL-D</i><span> will be a lot quicker.


CHANGING TABS IN SPACES (AND BACK)

Setting <span class="highlight"><i>'expandtab'</i><span> does not affect any existing tabs.  In other words, any
tabs in the document remain tabs.  If you want to convert tabs to spaces, use
the &quot;:retab&quot; command.  Use these commands:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set expandtab</b><span>
<span class="highlight"><b>        :%retab</b><span>

Now Vim will have changed all indents to use spaces instead of tabs.  However,
all tabs that come after a non-blank character are kept.  If you want these to
be converted as well, add a !:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :%retab!</b><span>

This is a little bit dangerous, because it can also change tabs inside a
string.  To check if these exist, you could use this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        /&quot;[^&quot;\t]*\t[^&quot;]*&quot;</b><span>

It's recommended not to use hard tabs inside a string.  Replace them with
&quot;\t&quot; to avoid trouble.

The other way around works just as well:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set noexpandtab</b><span>
<span class="highlight"><b>        :%retab!</b><span>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*30.6*</i></b><span>  Formatting comments

One of the great things about Vim is that it understands comments.  You can
ask Vim to format a comment and it will do the right thing.
   Suppose, for example, that you have the following comment:

<span class="highlight"><b>        /* </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>         * This is a test </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>         * of the text formatting. </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>         */ </b><span><font color="#e5e5e5">~</font>

You then ask Vim to format it by positioning the cursor at the start of the
comment and type:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        gq]/</b><span>

&quot;gq&quot; is the operator to format text.  &quot;]/&quot; is the motion that takes you to the
end of a comment.  The result is:

<span class="highlight"><b>        /* </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>         * This is a test of the text formatting. </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>         */ </b><span><font color="#e5e5e5">~</font>

Notice that Vim properly handled the beginning of each line.
  An alternative is to select the text that is to be formatted in Visual mode
and type &quot;gq&quot;.

To add a new line to the comment, position the cursor on the middle line and
press &quot;o&quot;.  The result looks like this:

<span class="highlight"><b>        /* </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>         * This is a test of the text formatting. </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>         * </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>         */ </b><span><font color="#e5e5e5">~</font>

Vim has automatically inserted a star and a space for you.  Now you can type
the comment text.  When it gets longer than <span class="highlight"><i>'textwidth'</i><span>, Vim will break the
line.  Again, the star is inserted automatically:

<span class="highlight"><b>        /* </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>         * This is a test of the text formatting. </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>         * Typing a lot of text here will make Vim </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>         * break </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>         */ </b><span><font color="#e5e5e5">~</font>

For this to work some flags must be present in <span class="highlight"><i>'formatoptions'</i><span>:

        r       insert the star when typing <span class="highlight"><i>&lt;Enter&gt;</i><span> in Insert mode
        o       insert the star when using &quot;o&quot; or &quot;O&quot; in Normal mode
        c       break comment text according to <span class="highlight"><i>'textwidth'</i><span>

See <span class="highlight"><i>|fo-table|</i><span> for more flags.


DEFINING A COMMENT

The <span class="highlight"><i>'comments'</i><span> option defines what a comment looks like.  Vim distinguishes
between a single-line comment and a comment that has a different start, end
and middle part.
   Many single-line comments start with a specific character.  In C++ // is
used, in Makefiles #, in Vim scripts &quot;.  For example, to make Vim understand
C++ comments:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set comments=://</b><span>

The colon separates the flags of an item from the text by which the comment is
recognized.  The general form of an item in <span class="highlight"><i>'comments'</i><span> is:

        <span class="highlight"><i>{flags}</i></font></span>:<span class="highlight"><i>{text}</i><span>

The <span class="highlight"><i>{flags}</i><span> part can be empty, as in this case.
   Several of these items can be concatenated, separated by commas.  This
allows recognizing different types of comments at the same time.  For example,
let's edit an e-mail message.  When replying, the text that others wrote is
preceded with &quot;&gt;&quot; and &quot;!&quot; characters.  This command would work:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set comments=n:&gt;,n:!</b><span>

There are two items, one for comments starting with &quot;&gt;&quot; and one for comments
that start with &quot;!&quot;.  Both use the flag &quot;n&quot;.  This means that these comments
nest.  Thus a line starting with &quot;&gt;&quot; may have another comment after the &quot;&gt;&quot;.
This allows formatting a message like this:

<span class="highlight"><b>        &gt; ! Did you see that site? </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        &gt; ! It looks really great. </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        &gt; I don't like it.  The </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        &gt; colors are terrible. </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        What is the URL of that </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        site? </b><span><font color="#e5e5e5">~</font>

Try setting <span class="highlight"><i>'textwidth'</i><span> to a different value, e.g., 80, and format the text by
Visually selecting it and typing &quot;gq&quot;.  The result is:

<span class="highlight"><b>        &gt; ! Did you see that site? It looks really great. </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        &gt; I don't like it.  The colors are terrible. </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        What is the URL of that site? </b><span><font color="#e5e5e5">~</font>

You will notice that Vim did not move text from one type of comment to
another.  The &quot;I&quot; in the second line would have fit at the end of the first
line, but since that line starts with &quot;&gt; !&quot; and the second line with &quot;&gt;&quot;, Vim
knows that this is a different kind of comment.


A THREE PART COMMENT

A C comment starts with &quot;/*&quot;, has &quot;*&quot; in the middle and &quot;*/&quot; at the end.  The
entry in <span class="highlight"><i>'comments'</i><span> for this looks like this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set comments=s1:/*,mb:*,ex:*/</b><span>

The start is defined with &quot;s1:/*&quot;.  The &quot;s&quot; indicates the start of a
three-piece comment.  The colon separates the flags from the text by which the
comment is recognized: &quot;/*&quot;.  There is one flag: &quot;1&quot;.  This tells Vim that the
middle part has an offset of one space.
   The middle part &quot;mb:*&quot; starts with &quot;m&quot;, which indicates it is a middle
part.  The &quot;b&quot; flag means that a blank must follow the text.  Otherwise Vim
would consider text like &quot;*pointer&quot; also to be the middle of a comment.
   The end part &quot;ex:*/&quot; has the &quot;e&quot; for indentification.  The &quot;x&quot; flag has a
special meaning.  It means that after Vim automatically inserted a star,
typing / will remove the extra space.

For more details see <span class="highlight"><i>|format-comments|</i><span>.

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_31.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2001 Nov 02


                              Exploiting the GUI


Vim works well in a terminal, but the GUI has a few extra items.  A file
browser can be used for commands that use a file.  A dialog to make a choice
between alternatives.  Use keyboard shortcuts to access menu items quickly.

<span class="highlight"><i>|31.1|</i><span>  The file browser
<span class="highlight"><i>|31.2|</i><span>  Confirmation
<span class="highlight"><i>|31.3|</i><span>  Menu shortcuts
<span class="highlight"><i>|31.4|</i><span>  Vim window position and size
<span class="highlight"><i>|31.5|</i><span>  Various


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*31.1*</i></b><span>  The file browser

When using the File/Open... menu you get a file browser.  This makes it easier
to find the file you want to edit.  But what if you want to split a window to
edit another file?  There is no menu entry for this.  You could first use
Window/Split and then File/Open..., but that's more work.
   Since you are typing most commands in Vim, opening the file browser with a
typed command is possible as well.  To make the split command use the file
browser, prepend &quot;browse&quot;:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :browse split</b><span>

Select a file and then the &quot;:split&quot; command will be executed with it.  If you
cancel the file dialog nothing happens, the window isn't split.
   You can also specify a file name argument.  This is used to tell the file
browser where to start.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :browse split /etc</b><span>

The file browser will pop up, starting in the directory &quot;/etc&quot;.

The &quot;:browse&quot; command can be prepended to just about any command that opens a
file.
   If no directory is specified, Vim will decide where to start the file
browser.  By default it uses the same directory as the last time.  Thus when
you used &quot;:browse split&quot; and selected a file in &quot;/usr/local/share&quot;, the next
time you use a &quot;:browse&quot; it will start in &quot;/usr/local/share&quot; again.
   This can be changed with the <span class="highlight"><i>'browsedir'</i><span> option.  It can have one of three
values:

        last            Use the last directory browsed (default)
        buffer          Use the same directory as the current buffer
        current         use the current directory

For example, when you are in the directory &quot;/usr&quot;, editing the file
&quot;/usr/local/share/readme&quot;, then the command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set browsedir=buffer</b><span>
<span class="highlight"><b>        :browse edit</b><span>

Will start the browser in &quot;/usr/local/share&quot;.  Alternatively:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set browsedir=current</b><span>
<span class="highlight"><b>        :browse edit</b><span>

Will start the browser in &quot;/usr&quot;.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        To avoid using the mouse, most file browsers offer using key presses
        to navigate.  Since this is different for every system, it is not
        explained here.  Vim uses a standard browser when possible, your
        system documentation should contain an explanation on the keyboard
        shortcuts somewhere.

When you are not using the GUI version, you could use the file explorer window
to select files like in a file browser.  However, this doesn't work for the
&quot;:browse&quot; command.  See <span class="highlight"><i>|file-explorer|</i><span>.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*31.2*</i></b><span>  Confirmation

Vim protects you from accidentally overwriting a file and other ways to lose
changes.  If you do something that might be a bad thing to do, Vim produces an
error message and suggests appending ! if you really want to do it.
   To avoid retyping the command with the !, you can make Vim give you a
dialog.  You can then press &quot;OK&quot; or &quot;Cancel&quot; to tell Vim what you want.
   For example, you are editing a file and made changes to it.  You start
editing another file with:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :confirm edit foo.txt</b><span>

Vim will pop up a dialog that looks something like this:

        +-----------------------------------+
        |                                   |
        |   ?   Save changes to &quot;bar.txt&quot;?  |
        |                                   |
        |   YES   NO             CANCEL     |
        +-----------------------------------+

Now make your choice.  If you do want to save the changes, select &quot;YES&quot;.  If
you want to lose the changes for ever: &quot;NO&quot;.  If you forgot what you were
doing and want to check what really changed use &quot;CANCEL&quot;.  You will be back in
the same file, with the changes still there.

Just like &quot;:browse&quot;, the &quot;:confirm&quot; command can be prepended to most commands
that edit another file.  They can also be combined:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :confirm browse edit</b><span>

This will produce a dialog when the current buffer was changed.  Then it will
pop up a file browser to select the file to edit.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        In the dialog you can use the keyboard to select the choice.
        Typically the <span class="highlight"><i>&lt;Tab&gt;</i><span> key and the cursor keys change the choice.
        Pressing <span class="highlight"><i>&lt;Enter&gt;</i><span> selects the choice.  This depends on the system
        though.

When you are not using the GUI, the &quot;:confirm&quot; command works as well.  Instead
of popping up a dialog, Vim will print the message at the bottom of the Vim
window and ask you to press a key to make a choice.<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :confirm edit main.c</b><span>
<font color="#e5e5e5">&lt;</font><span class="highlight"><b>       Save changes to &quot;Untitled&quot;? </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        [Y]es, (N)o, (C)ancel:  </b><span><font color="#e5e5e5">~</font>

You can now press the single key for the choice.  You don't have to press
<span class="highlight"><i>&lt;Enter&gt;</i><span>, unlike other typing on the command line.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*31.3*</i></b><span>  Menu shortcuts

The keyboard is used for all Vim commands.  The menus provide a simple way to
select commands, without knowing what they are called.  But you have to move
your hand from the keyboard and grab the mouse.
   Menus can often be selected with keys as well.  This depends on your
system, but most often it works this way.  Use the <span class="highlight"><i>&lt;Alt&gt;</i><span> key in combination
with the underlined letter of a menu.  For example, <span class="highlight"><i>&lt;A-w&gt;</i></font></span> (<span class="highlight"><i>&lt;Alt&gt;</i><span> and w) pops
up the Window menu.
   In the Window menu, the &quot;split&quot; item has the p underlined.  To select it,
let go of the <span class="highlight"><i>&lt;Alt&gt;</i><span> key and press p.

After the first selection of a menu with the <span class="highlight"><i>&lt;Alt&gt;</i><span> key, you can use the cursor
keys to move through the menus.  <span class="highlight"><i>&lt;Left&gt;</i></font></span> selects a submenu and <span class="highlight"><i>&lt;Right&gt;</i><span> closes
it.  <span class="highlight"><i>&lt;Esc&gt;</i></font></span> also closes a menu.  <span class="highlight"><i>&lt;Enter&gt;</i><span> selects a menu item.

There is a conflict between using the <span class="highlight"><i>&lt;Alt&gt;</i><span> key to select menu items, and
using <span class="highlight"><i>&lt;Alt&gt;</i></font></span> key combinations for mappings.  The <span class="highlight"><i>'winaltkeys'</i><span> option tells Vim
what it should do with the <span class="highlight"><i>&lt;Alt&gt;</i><span> key.
   The default value &quot;menu&quot; is the smart choice: If the key combination is a
menu shortcut it can't be mapped.  All other keys are available for mapping.
   The value &quot;no&quot; doesn't use any <span class="highlight"><i>&lt;Alt&gt;</i><span> keys for the menus.  Thus you must use
the mouse for the menus, and all <span class="highlight"><i>&lt;Alt&gt;</i><span> keys can be mapped.
   The value &quot;yes&quot; means that Vim will use any <span class="highlight"><i>&lt;Alt&gt;</i><span> keys for the menus.  Some
<span class="highlight"><i>&lt;Alt&gt;</i><span> key combinations may also do other things than selecting a menu.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*31.4*</i></b><span>  Vim window position and size

To see the current Vim window position on the screen use:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :winpos</b><span>

This will only work in the GUI.  The output may look like this:

<span class="highlight"><b>        Window position: X 272, Y 103 </b><span><font color="#e5e5e5">~</font>

The position is given in screen pixels.  Now you can use the numbers to move
Vim somewhere else.  For example, to move it to the left a hundred pixels:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :winpos 172 103</b><span>
<font color="#e5e5e5">&lt;</font>
        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        There may be a small offset between the reported position and where
        the window moves.  This is because of the border around the window.
        This is added by the window manager.

You can use this command in your startup script to position the window at a
specific position.

The size of the Vim window is computed in characters.  Thus this depends on
the size of the font being used.  You can see the current size with this
command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set lines columns</b><span>

To change the size set the <span class="highlight"><i>'lines'</i></font></span> and/or <span class="highlight"><i>'columns'</i><span> options to a new value:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set lines=50</b><span>
<span class="highlight"><b>        :set columns=80</b><span>

Obtaining the size works in a terminal just like in the GUI.  Setting the size
is not possible in most terminals.

You can start the X-Windows version of gvim with an argument to specify the
size and position of the window:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        gvim -geometry {width}x{height}+{x_offset}+{y_offset}</b><span>

<span class="highlight"><i>{width}</i></font></span> and <span class="highlight"><i>{height}</i><span> are in characters, {x_offset} and {y_offset} are in
pixels.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        gvim -geometry 80x25+100+300</b><span>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*31.5*</i></b><span>  Various

You can use gvim to edit an e-mail message.  In your e-mail program you must
select gvim to be the editor for messages.  When you try that, you will
see that it doesn't work: The mail program thinks that editing is finished,
while gvim is still running!
   What happens is that gvim disconnects from the shell it was started in.
That is fine when you start gvim in a terminal, so that you can do other work
in that terminal.  But when you really want to wait for gvim to finish, you
must prevent it from disconnecting.  The &quot;-f&quot; argument does this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        gvim -f file.txt</b><span>

The &quot;-f&quot; stands for foreground.  Now Vim will block the shell it was started
in until you finish editing and exit.


DELAYED START OF THE GUI

On Unix it's possible to first start Vim in a terminal.  That's useful if you
do various tasks in the same shell.  If you are editing a file and decide you
want to use the GUI after all, you can start it with:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :gui</b><span>

Vim will open the GUI window and no longer use the terminal.  You can continue
using the terminal for something else.  The &quot;-f&quot; argument is used here to run
the GUI in the foreground.  You can also use &quot;:gui -f&quot;.


THE GVIM STARTUP FILE

When gvim starts, it reads the gvimrc file.  That's similar to the vimrc file
used when starting Vim.  The gvimrc file can be used for settings and commands
that are only to be used when the GUI is going to be started.  For example,
you can set the <span class="highlight"><i>'lines'</i><span> variable to set a different window size:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set lines=55</b><span>

You don't want to do this in a terminal, since it's size is fixed (except for
an xterm that supports resizing).
   The gvimrc file is searched for in the same locations as the vimrc file.
Normally it's name is &quot;~/.gvimrc&quot; for Unix and &quot;$VIM/_gvimrc&quot; for MS-Windows.
   If for some reason you don't want to use the normal gvimrc file, you can
specify another one with the &quot;-U&quot; argument:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        gvim -U thisrc ...</b><span>

That allows starting gvim for different kinds of editing.  You could set
another font size, for example.
   To completely skip reading a gvimrc file:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        gvim -U NONE ...</b><span>

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_40.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2001 Sep 03


                              Make new commands


Vim is an extensible editor.  You can take a sequence of commands you use
often and turn it into a new command.  Or redefine an existing command.
Autocommands make it possible to execute commands automatically.

<span class="highlight"><i>|40.1|</i><span>  Key mapping
<span class="highlight"><i>|40.2|</i><span>  Defining command-line commands
<span class="highlight"><i>|40.3|</i><span>  Autocommands


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*40.1*</i></b><span>  Key mapping

A simple mapping was explained in section <span class="highlight"><i>|05.3|</i><span>.  The principle is that one
sequence of key strokes is translated into another sequence of key strokes.
This is a simple, yet powerful mechanism.
   The simplest form is that one key is mapped to a sequence of keys.  Since
the function keys, except <span class="highlight"><i>&lt;F1&gt;</i><span>, have no predefined meaning in Vim, these are a
good choice to map.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :map &lt;F2&gt; GoDate: &lt;Esc&gt;:read !date&lt;CR&gt;kJ</b><span>

This shows how three modes are used.  After going to the last line with &quot;G&quot;,
the &quot;o&quot; command opens a new line and starts Insert mode.  The text &quot;Date: &quot; is
inserted and <span class="highlight"><i>&lt;Esc&gt;</i><span> takes you out of insert mode.
   Notice the use of special keys inside &lt;&gt;.  This is called angle bracket
notation.  You type these as separate characters, not by pressing the key
itself.  This makes the mappings better readable and you can copy and paste
the text without problems.
   The &quot;:&quot; character takes Vim to the command line.  The &quot;:read !date&quot; command
reads the output from the &quot;date&quot; command and appends it below the current
line.  The <span class="highlight"><i>&lt;CR&gt;</i><span> is required to execute the &quot;:read&quot; command.
   At this point of execution the text looks like this:

<span class="highlight"><b>        Date:  </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        Fri Jun 15 12:54:34 CEST 2001 </b><span><font color="#e5e5e5">~</font>

Now &quot;kJ&quot; moves the cursor up and joins the lines together.
   To decide which key or keys you use for mapping, see <span class="highlight"><i>|map-which-keys|</i><span>.


MAPPING AND MODES

The &quot;:map&quot; command defines remapping for keys in Normal mode.  You can also
define mappings for other modes.  For example, &quot;:imap&quot; applies to Insert mode.
You can use it to insert a date below the cursor:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :imap &lt;F2&gt; &lt;CR&gt;Date: &lt;Esc&gt;:read !date&lt;CR&gt;kJ</b><span>

It looks a lot like the mapping for <span class="highlight"><i>&lt;F2&gt;</i><span> in Normal mode, only the start is
different.  The <span class="highlight"><i>&lt;F2&gt;</i><span> mapping for Normal mode is still there.  Thus you can map
the same key differently for each mode.
   Notice that, although this mapping starts in Insert mode, it ends in Normal
mode.  If you want it to continue in Insert mode, append a &quot;a&quot; to the mapping.

Here is an overview of map commands and in which mode they work:

        :map            Normal, Visual and Operator-pending
        :vmap           Visual
        :nmap           Normal
        :omap           Operator-pending
        :map!           Insert and Command-line
        :imap           Insert
        :cmap           Command-line

Operator-pending mode is when you typed an operator character, such as &quot;d&quot; or
&quot;y&quot;, and you are expected to type the motion command or a text object.  Thus
when you type &quot;dw&quot;, the &quot;w&quot; is entered in operator-pending mode.

Suppose that you want to define <span class="highlight"><i>&lt;F7&gt;</i></font></span> so that the command d<span class="highlight"><i>&lt;F7&gt;</i><span> deletes a C
program block (text enclosed in curly braces, {}).  Similarly y<span class="highlight"><i>&lt;F7&gt;</i><span> would yank
the program block into the unnamed register.  Therefore, what you need to do
is to define <span class="highlight"><i>&lt;F7&gt;</i><span> to select the current program block.  You can do this with
the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :omap &lt;F7&gt; a{</b><span>

This causes <span class="highlight"><i>&lt;F7&gt;</i><span> to perform a select block &quot;a{&quot; in operator-pending mode, just
like you typed it.  This mapping is useful if typing a { on your keyboard is a
bit difficult.


LISTING MAPPINGS

To see the currently defined mappings, use &quot;:map&quot; without arguments.  Or one
of the variants that include the mode in which they work.  The output could
look like this:

<span class="highlight"><b>           _g            :call MyGrep(1)&lt;CR&gt; </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        v  &lt;F2&gt;          :s/^/&gt; /&lt;CR&gt;:noh&lt;CR&gt;`` </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        n  &lt;F2&gt;          :.,$s/^/&gt; /&lt;CR&gt;:noh&lt;CR&gt;`` </b><span><font color="#e5e5e5">~</font>
           <span class="highlight"><i>&lt;xHome&gt;</i></font></span>       <span class="highlight"><i>&lt;Home&gt;</i><span>
           <span class="highlight"><i>&lt;xEnd&gt;</i></font></span>        <span class="highlight"><i>&lt;End&gt;</i><span>


The first column of the list shows in which mode the mapping is effective.
This is &quot;n&quot; for Normal mode, &quot;i&quot; for Insert mode, etc.  A blank is used for a
mapping defined with &quot;:map&quot;, thus effective in both Normal and Visual mode.
   One useful purpose of listing the mapping is to check if special keys in &lt;&gt;
form have been recognized (this only works when color is supported).  For
example, when <span class="highlight"><i>&lt;Esc&gt;</i><span> is displayed in color, it stands for the escape character.
When it has the same color as the other text, it is five characters.


REMAPPING

The result of a mapping is inspected for other mappings in it.  For example,
the mappings for <span class="highlight"><i>&lt;F2&gt;</i><span> above could be shortened to:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :map &lt;F2&gt; G&lt;F3&gt;</b><span>
<span class="highlight"><b>        :imap &lt;F2&gt; &lt;Esc&gt;&lt;F3&gt;</b><span>
<span class="highlight"><b>        :map &lt;F3&gt;  oDate: &lt;Esc&gt;:read !date&lt;CR&gt;kJ</b><span>

For Normal mode <span class="highlight"><i>&lt;F2&gt;</i><span> is mapped to go to the last line, and then behave like
<span class="highlight"><i>&lt;F3&gt;</i></font></span> was pressed.  In Insert mode <span class="highlight"><i>&lt;F2&gt;</i><span> stops Insert mode with <span class="highlight"><i>&lt;Esc&gt;</i><span> and then
also uses <span class="highlight"><i>&lt;F3&gt;</i></font></span>.  Then <span class="highlight"><i>&lt;F3&gt;</i><span> is mapped to do the actual work.

Suppose you hardly ever use Ex mode, and want to use the &quot;Q&quot; command to format
text (this was so in old versions of Vim).  This mapping will do it:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :map Q gq</b><span>

But, in rare cases you need to use Ex mode anyway.  Let's map &quot;gQ&quot; to Q, so
that you can still go to Ex mode:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :map gQ Q</b><span>

What happens now is that when you type &quot;gQ&quot; it is mapped to &quot;Q&quot;.  So far so
good.  But then &quot;Q&quot; is mapped to &quot;gq&quot;, thus typing &quot;gQ&quot; results in &quot;gq&quot;, and
you don't get to Ex mode at all.
   To avoid keys to be mapped again, use the &quot;:noremap&quot; command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :noremap gQ Q</b><span>

Now Vim knows that the &quot;Q&quot; is not to be inspected for mappings that apply to
it.  There is a similar command for every mode:

        :noremap        Normal, Visual and Operator-pending
        :vnoremap       Visual
        :nnoremap       Normal
        :onoremap       Operator-pending
        :noremap!       Insert and Command-line
        :inoremap       Insert
        :cnoremap       Command-line


RECURSIVE MAPPING

When a mapping triggers itself, it will run forever.  This can be used to
repeat an action an unlimited number of times.
   For example, you have a list of files that contain a version number in the
first line.  You edit these files with &quot;vim *.txt&quot;.  You are now editing the
first file.  Define this mapping:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :map ,, :s/5.1/5.2/&lt;CR&gt;:wnext&lt;CR&gt;,,</b><span>

Now you type &quot;,,&quot;.  This triggers the mapping.  It replaces &quot;5.1&quot; with &quot;5.2&quot;
in the first line.  Then it does a &quot;:wnext&quot; to write the file and edit the
next one.  The mapping ends in &quot;,,&quot;.  This triggers the same mapping again,
thus doing the substitution, etc.
   This continues until there is an error.  In this case it could be a file
where the substitute command doesn't find a match for &quot;5.1&quot;.  You can then
make a change to insert &quot;5.1&quot; and continue by typing &quot;,,&quot; again.  Or the
&quot;:wnext&quot; fails, because you are in the last file in the list.
   When a mapping runs into an error halfway, the rest of the mapping is
discarded.  <span class="highlight"><i>CTRL-C</i></font></span> interrupts the mapping (<span class="highlight"><i>CTRL-Break</i><span> on MS-Windows).


DELETE A MAPPING

To remove a mapping use the &quot;:unmap&quot; command.  Again, the mode the unmapping
applies to depends on the command used:

        :unmap          Normal, Visual and Operator-pending
        :vunmap         Visual
        :nunmap         Normal
        :ounmap         Operator-pending
        :unmap!         Insert and Command-line
        :iunmap         Insert
        :cunmap         Command-line

There is a trick to define a mapping that works in Normal and Operator-pending
mode, but not in Visual mode.  First define it for all three modes, then
delete it for Visual mode:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :map &lt;C-A&gt; /---&gt;&lt;CR&gt;</b><span>
<span class="highlight"><b>        :vunmap &lt;C-A&gt;</b><span>

Notice that the five characters &quot;<span class="highlight"><i>&lt;C-A&gt;</i></font></span>&quot; stand for the single key <span class="highlight"><i>CTRL-A</i><span>.

To remove all mappings use the <span class="highlight"><i>|:mapclear|</i><span> command.  You can guess the
variations for different modes by now.  Be careful with this command, it can't
be undone.


SPECIAL CHARACTERS

The &quot;:map&quot; command can be followed by another command.  A | character
separates the two commands.  This also means that a | character can't be used
inside a map command.  To include one, use <span class="highlight"><i>&lt;Bar&gt;</i><span> (five characters).  Example:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        :map &lt;F8&gt; :write &lt;Bar&gt; !checkin %&lt;CR&gt;</b><span>

The same problem applies to the &quot;:unmap&quot; command, with the addition that you
have to watch out for trailing white space.  These two commands are different:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        :unmap a | unmap b</b><span>
<span class="highlight"><b>        :unmap a| unmap b</b><span>

The first command tries to unmap &quot;a &quot;, with a trailing space.

When using a space inside a mapping, use <span class="highlight"><i>&lt;Space&gt;</i><span> (seven characters):<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :map &lt;Space&gt; W</b><span>

This makes the spacebar move a blank-separated word forward.

It is not possible to put a comment after a mapping, because the &quot; character
is considered to be part of the mapping.


MAPPINGS AND ABBREVIATIONS

Abbreviations are a lot like Insert mode mappings.  The arguments are handled
in the same way.  The main difference is the way they are triggered.  An
abbreviation is triggered by typing a non-word character after the word.  A
mapping is triggered when typing the last character.
   Another difference is that the characters you type for an abbreviation are
inserted in the text while you type them.  When the abbreviation is triggered
these characters are deleted and replaced by what the abbreviation produces.
When typing the characters for a mapping, nothing is inserted until you type
the last character that triggers it.  If the <span class="highlight"><i>'showcmd'</i><span> option is set, the
typed characters are displayed in the last line of the Vim window.
   An exception is when a mapping is ambiguous.  Suppose you have done two
mappings:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :imap aa foo</b><span>
<span class="highlight"><b>        :imap aaa bar</b><span>

Now, when you type &quot;aa&quot;, Vim doesn't know if it should apply the first or the
second mapping.  It waits for another character to be typed.  If it is an &quot;a&quot;,
the second mapping is applied and results in &quot;bar&quot;.  If it is a space, for
example, the first mapping is applied, resulting in &quot;foo&quot;, and then the space
is inserted.


ADDITIONALLY...

The <span class="highlight"><i>&lt;script&gt;</i><span> keyword can be used to make a mapping local to a script.  See
<span class="highlight"><i>|:map-&lt;script&gt;|</i><span>.

The <span class="highlight"><i>&lt;buffer&gt;</i><span> keyword can be used to make a mapping local to a specific buffer.
See <span class="highlight"><i>|:map-&lt;buffer&gt;|</i><span>

The <span class="highlight"><i>&lt;unique&gt;</i><span> keyword can be used to make defining a new mapping fail when it
already exists.  Otherwise a new mapping simply overwrites the old one.  See
<span class="highlight"><i>|:map-&lt;unique&gt;|</i><span>.

To make a key do nothing, map it to <span class="highlight"><i>&lt;Nop&gt;</i><span> (five characters).  This will make
the <span class="highlight"><i>&lt;F7&gt;</i><span> key do nothing at all:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :map &lt;F7&gt; &lt;Nop&gt;| map! &lt;F7&gt; &lt;Nop&gt;</b><span>

There must be no space after <span class="highlight"><i>&lt;Nop&gt;</i><span>.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*40.2*</i></b><span>  Defining command-line commands

The Vim editor enables you to define your own commands.  You execute these
commands just like any other Command-line mode command.
   To define a command, use the &quot;:command&quot; command, as follows:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :command DeleteFirst 1delete</b><span>

Now when you execute the command &quot;:DeleteFirst&quot; Vim excutes &quot;:1delete&quot;, which
deletes the first line.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        User-defined commands must start with a capital letter.  You cannot
        use &quot;:X&quot;, &quot;:Next&quot; and &quot;:Print&quot;.  The underscore cannot be used!  You
        can use digits, but this is discouraged.

To list the user-defined commands, execute the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :command</b><span>

Just like with the builtin commands, the user defined commands can be
abbreviated.  You need to type just enough to distinguish the command from
another.  Command line completion can be used to get the full name.


NUMBER OF ARGUMENTS

User-defined commands can take a series of arguments.  The number of arguments
must be specified by the -nargs option.  For instance, the example
:DeleteFirst command takes no arguments, so you could have defined it as
follows:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :command -nargs=0 DeleteFirst 1delete</b><span>

However, because zero arguments is the default, you do not need to add
&quot;-nargs=0&quot;.  The other values of -nargs are as follows:

        -nargs=0        No arguments
        -nargs=1        One argument
        -nargs=*        Any number of arguments
        -nargs=?        Zero or one argument
        -nargs=+        One or more arguments


USING THE ARGUMENTS

Inside the command definition, the arguments are represented by the
<span class="highlight"><i>&lt;args&gt;</i><span> keyword.  For example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :command -nargs=+ Say :echo &quot;&lt;args&gt;&quot;</b><span>

Now when you type<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :Say Hello World</b><span>

Vim echoes &quot;Hello World&quot;.  However, if you add a double quote, it won't work.
For example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :Say he said &quot;hello&quot;</b><span>

To get special characters turned into a string, properly escaped to use as an
expression, use &quot;<span class="highlight"><i>&lt;q-args&gt;</i><span>&quot;:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :command -nargs=+ Say :echo &lt;q-args&gt;</b><span>

Now the above &quot;:Say&quot; command will result in this to be executed:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :echo &quot;he said \&quot;hello\&quot;&quot;</b><span>

The <span class="highlight"><i>&lt;f-args&gt;</i></font></span> keyword contains the same information as the <span class="highlight"><i>&lt;args&gt;</i><span> keyword,
except in a format suitable for use as function call arguments.  For example:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        :command -nargs=* DoIt :call AFunction(&lt;f-args&gt;)</b><span>
<span class="highlight"><b>        :DoIt a b c</b><span>

Execute the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :call AFunction(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</b><span>


LINE RANGE

Some commands take a range as their argument.  To tell Vim that you are
defining such a command, you need to specify a -range option.  The values for
this option are as follows:

        -range          Range is allowed; default is the current line.
        -range=%        Range is allowed; default is the whole file.
        -range=<span class="highlight"><i>{count}</i><span>  Range is allowed; the last number in it is used as a
                        single number whose default is <span class="highlight"><i>{count}</i><span>.

When a range is specified, the keywords <span class="highlight"><i>&lt;line1&gt;</i></font></span> and <span class="highlight"><i>&lt;line2&gt;</i><span> get the values of
the first and last line in the range.  For example, the following command
defines the SaveIt command, which writes out the specified range to the file
&quot;save_file&quot;:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :command -range=% SaveIt :&lt;line1&gt;,&lt;line2&gt;write! save_file</b><span>


OTHER OPTIONS

Some of the other options and keywords are as follows:

        -count=<span class="highlight"><i>{number}</i><span>         The command can take a count whose default is
                                <span class="highlight"><i>{number}</i><span>.  The resulting count can be used
                                through the <span class="highlight"><i>&lt;count&gt;</i><span> keyword.
        -bang                   You can use a !. If present, using <span class="highlight"><i>&lt;bang&gt;</i><span> will
                                result in a !.
        -register               You can specify a register. (The default is
                                the unnamed register.)
                                The register specification is available as
                                <span class="highlight"><i>&lt;reg&gt;</i></font></span> (a.k.a. <span class="highlight"><i>&lt;register&gt;</i><span>).
        -complete=<span class="highlight"><i>{type}</i><span>        Type of command-line completion used.  See
                                <span class="highlight"><i>|:command-completion|</i><span> for the list of possible
                                values.
        -bar                    The command can be followed by | and another
                                command, or &quot; and a comment.
        -buffer                 The command is only available for the current
                                buffer.

Finally, you have the <span class="highlight"><i>&lt;lt&gt;</i><span> keyword.  It stands for the character &lt;.  Use this
to escape the special meaning of the &lt;&gt; items mentioned.


REDEFINING AND DELETING

To redefine the same command use the ! argument:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :command -nargs=+ Say :echo &quot;&lt;args&gt;&quot;</b><span>
<span class="highlight"><b>        :command! -nargs=+ Say :echo &lt;q-args&gt;</b><span>

To delete a user command use &quot;:delcommand&quot;.  It takes a single argument, which
is the name of the command.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :delcommand SaveIt</b><span>

To delete all the user commands:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :comclear</b><span>

Careful, this can't be undone!

More details about all this in the reference manual: <span class="highlight"><i>|user-commands|</i><span>.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*40.3*</i></b><span>  Autocommands

An autocommand is a command that is executed automatically in response to some
event, such as a file being read or written or a buffer change. Through the
use of autocommands you can train Vim to edit compressed files, for example.
That is used in the <span class="highlight"><i>|gzip|</i><span> plugin.
   Autocommands are very powerful.  Use them with care and they will help you
avoid typing many commands.  Use them carelessly and they will cause a lot of
trouble.

Suppose you want to replace a date stamp on the end of a file every time it is
written.  First you define a function:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :function DateInsert()</b><span>
<span class="highlight"><b>        :  $delete</b><span>
<span class="highlight"><b>        :  read !date</b><span>
<span class="highlight"><b>        :endfunction</b><span>

You want this function to be called each time, just before a file is written.
This will make that happen:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :autocmd FileWritePre *  call DateInsert()</b><span>

&quot;FileWritePre&quot; is the event for which this autocommand is triggered: Just
before (pre) writing a file.  The &quot;*&quot; is a pattern to match with the file
name.  In this case it matches all files.
   With this command enabled, when you do a &quot;:write&quot;, Vim checks for any
matching FileWritePre autocommands and executes them, and then it
performs the &quot;:write&quot;.
   The general form of the :autocmd command is as follows:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :autocmd [group] {events} {file_pattern} [nested] {command}</b><span>

The <span class="highlight"><i>[group]</i><span> name is optional.  It is used in managing and calling the commands
(more on this later).  The <span class="highlight"><i>{events}</i><span> parameter is a list of events (comma
separated) that trigger the command.
   {file_pattern} is a filename, usually with wildcards.  For example, using
&quot;*.txt&quot; makes the autocommand be used for all files whose name end in &quot;.txt&quot;.
The optional <span class="highlight"><i>[nested]</i><span> flag allows for nesting of autocommands (see below), and
finally, <span class="highlight"><i>{command}</i><span> is the command to be executed.


EVENTS

One of the most useful events is BufReadPost.  It is triggered after a new
file is being edited.  It is commonly used to set option values.  For example,
you know that &quot;*.gsm&quot; files are GNU assembly language.  To get the syntax file
right, define this autocommand:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :autocmd BufReadPost *.gsm  set filetype=asm</b><span>

If Vim is able to detect the type of file, it will set the <span class="highlight"><i>'filetype'</i><span> option
for you.  This triggers the Filetype event.  Use this to do something when a
certain type of file is edited.  For example, to load a list of abbreviations
for text files:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :autocmd Filetype text  source ~/.vim/abbrevs.vim</b><span>

When starting to edit a new file, you could make Vim insert a skeleton:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :autocmd BufNewFile *.[ch]  0read ~/skeletons/skel.c</b><span>

See <span class="highlight"><i>|autocmd-events|</i><span> for a complete list of events.


PATTERNS

The {file_pattern} argument can actually be a comma-separated list of file
patterns.  For example: &quot;*.c,*.h&quot; matches files ending in &quot;.c&quot; and &quot;.h&quot;.
   The usual file wildcards can be used.  Here is a summary of the most often
used ones:

<span class="highlight"><b>        </b><span>*               Match any character any number of times
        ?               Match any character once
        <span class="highlight"><i>[abc]</i><span>           Match the character a, b or c
        .               Matches a dot
        a<span class="highlight"><i>{b,c}</i><span>          Matches &quot;ab&quot; and &quot;ac&quot;

When the pattern includes a slash (/) Vim will compare directory names.
Without the slash only the last part of a file name is used.  For example,
&quot;*.txt&quot; matches &quot;/home/biep/readme.txt&quot;.  The pattern &quot;/home/biep/*&quot; would
also match it.  But &quot;home/foo/*.txt&quot; wouldn't.
   When including a slash, Vim matches the pattern against both the full path
of the file (&quot;/home/biep/readme.txt&quot;) and the relative path (e.g.,
&quot;biep/readme.txt&quot;).

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        When working on a system that uses a backslash as file separater, such
        as MS-Windows, you still use forward slashes in autocommands.  This
        makes it easier to write the pattern, since a backslash has a special
        meaning.  It also makes the autocommands portable.


DELETING

To delete an autocommand, use the same command as what it was defined with,
but leave out the <span class="highlight"><i>{command}</i><span> at the end and use a !.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :autocmd! FileWritePre *</b><span>

This will delete all autocommands for the &quot;FileWritePre&quot; event that use the
&quot;*&quot; pattern.


LISTING

To list all the currently defined autocommands, use this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :autocmd</b><span>

The list can be very long, especially when filetype detection is used.  To
list only part of the commands, specify the group, event and/or pattern.  For
example, to list all BufNewFile autocommands:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :autocmd BufNewFile</b><span>

To list all autocommands for the pattern &quot;*.c&quot;:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :autocmd * *.c</b><span>

Using &quot;*&quot; for the event will list all the events.  To list all autocommands
for the cprograms group:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :autocmd cprograms</b><span>


GROUPS

The <span class="highlight"><i>{group}</i><span> item, used when defining an autocommand, groups related autocommands
together.  This can be used to delete all the autocommands in a certain group,
for example.
   When defining several autocommands for a certain group, use the &quot;:augroup&quot;
command.  For example, let's define autocommands for C programs:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :augroup cprograms</b><span>
<span class="highlight"><b>        :  autocmd BufReadPost *.c,*.h :set sw=4 sts=4</b><span>
<span class="highlight"><b>        :  autocmd BufReadPost *.cpp   :set sw=3 sts=3</b><span>
<span class="highlight"><b>        :augroup END</b><span>

This will do the same as:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :autocmd cprograms BufReadPost *.c,*.h :set sw=4 sts=4</b><span>
<span class="highlight"><b>        :autocmd cprograms BufReadPost *.cpp   :set sw=3 sts=3</b><span>

To delete all autocommands in the &quot;cprograms&quot; group:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :autocmd! cprograms</b><span>


NESTING

Generally, commands executed as the result of an autocommand event will not
trigger any new events.  If you read a file in response to a FileChangedShell
event, it will not trigger the autocommands that would set the syntax, for
example.  To make the events triggered, add the &quot;nested&quot; argument:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :autocmd FileChangedShell * nested  edit</b><span>


EXECUTING AUTOCOMMANDS

It is possible to trigger an autocommand by pretending an event has occurred.
This is useful to have one autocommand trigger another one.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :autocmd BufReadPost *.new  execute &quot;doautocmd BufReadPost &quot; . expand(&quot;&lt;afile&gt;:r&quot;)</b><span>

This defines an autocommand that is triggered when a new file has been edited.
The file name must end in &quot;.new&quot;.  The &quot;:execute&quot; command uses expression
evaluation to form a new command and execute it.  When editing the file
&quot;tryout.c.new&quot; the executed command will be:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :doautocmd BufReadPost tryout.c</b><span>

The expand() function takes the &quot;<span class="highlight"><i>&lt;afile&gt;</i><span>&quot; argument, which stands for the file
name the autocommand was executed for, and takes the root of the file name
with &quot;:r&quot;.

&quot;:doautocmd&quot; executes on the current buffer.  The &quot;:doautoall&quot; command works
like &quot;doautocmd&quot; except it executes on all the buffers.


USING NORMAL MODE COMMANDS

The commands executed by an autocommand are Command-line command.  If you want
to use a Normal mode command, the &quot;:normal&quot; command can be used.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :autocmd BufReadPost *.log normal G</b><span>

This will make the cursor jump to the last line of *.log files when you start
to edit it.
   Using the &quot;:normal&quot; command is a bit tricky.  First of all, make sure its
argument is a complete command, including all the arguments.  When you use &quot;i&quot;
to go to Insert mode, there must also be a <span class="highlight"><i>&lt;Esc&gt;</i><span> to leave Insert mode again.
If you use a &quot;/&quot; to start a search pattern, there must be a <span class="highlight"><i>&lt;CR&gt;</i><span> to execute
it.
   The &quot;:normal&quot; command uses all the text after it as commands.  Thus there
can be no | and another command following.  To work around this, put the
&quot;:normal&quot; command inside an &quot;:execute&quot; command.  This also makes it possible
to pass unprintable characters in a convenient way.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :autocmd BufReadPost *.chg execute &quot;normal ONew entry:\&lt;Esc&gt;&quot; |</b><span>
<span class="highlight"><b>                \ 1read !date</b><span>

This also shows the use of a backslash to break a long command into more
lines.  This can be used in Vim scripts (not at the command line).

When you want the autocommand do something complicated, which involves jumping
around in the file and then returning to the original position, you may want
to restore the view on the file.  See <span class="highlight"><i>|restore-position|</i><span> for an example.


IGNORING EVENTS

At times, you will not want to trigger an autocommand.  The <span class="highlight"><i>'eventignore'</i><span>
option contains a list of events that will be totally ignored.  For example,
the following causes events for entering and leaving a window to be ignored:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set eventignore=WinEnter,WinLeave</b><span>

To ignore all events, use the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set eventignore=all</b><span>

To set it back to the normal behavior, make <span class="highlight"><i>'eventignore'</i><span> empty:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set eventignore=</b><span>

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_41.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2001 Oct 26


                              Write a Vim script


The Vim script language is used for the startup vimrc file, syntax files, and
many other things.  This chapter explains the items that can be used in a Vim
script.  There are a lot of them, thus this is a long chapter.

<span class="highlight"><i>|41.1|</i><span>  Introduction
<span class="highlight"><i>|41.2|</i><span>  Variables
<span class="highlight"><i>|41.3|</i><span>  Expressions
<span class="highlight"><i>|41.4|</i><span>  Conditionals
<span class="highlight"><i>|41.5|</i><span>  Executing an expression
<span class="highlight"><i>|41.6|</i><span>  Using functions
<span class="highlight"><i>|41.7|</i><span>  Defining a function
<span class="highlight"><i>|41.8|</i><span>  Various remarks
<span class="highlight"><i>|41.9|</i><span>  Writing a plugin
<span class="highlight"><i>|41.10|</i><span> Writing a filetype plugin
<span class="highlight"><i>|41.11|</i><span> Writing a compiler plugin


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*41.1*</i></b></font></span>  Introduction                    <span class="highlight"><b><i>*vimrc-intro*</i></b><span> <span class="highlight"><b><i>*vim-script-intro*</i></b><span>

Your first experience with Vim scripts is the vimrc file.  Vim reads it when
it starts up and executes the commands.  You can set options to values you
prefer.  And you can use any colon command in it (commands that start with a
&quot;:&quot;; these are sometimes referred to as Ex commands or command-line commands).
   Syntax files are also Vim scripts.  As are files that set options for a
specific file type.  A complicated macro can be defined by a separate Vim
script file.  You can think of other uses yourself.

Let's start with a simple example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :let i = 1</b><span>
<span class="highlight"><b>        :while i &lt; 5</b><span>
<span class="highlight"><b>        :  echo &quot;count is&quot; i</b><span>
<span class="highlight"><b>        :  let i = i + 1</b><span>
<span class="highlight"><b>        :endwhile</b><span>
<font color="#e5e5e5">&lt;</font>
        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        The &quot;:&quot; characters are not really needed here.  You only need to use
        them when you type a command.  In a Vim script file they can be left
        out.  We will use them here anyway to make clear these are colon
        commands and make them stand out from Normal mode commands.

The &quot;:let&quot; command assigns a value to a variable.  The generic form is:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :let {variable} = {expression}</b><span>

In this case the variable name is &quot;i&quot; and the expression is a simple value,
the number one.
   The &quot;:while&quot; command starts a loop.  The generic form is:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :while {condition}</b><span>
<span class="highlight"><b>        :  {statements}</b><span>
<span class="highlight"><b>        :endwhile</b><span>

The statements until the matching &quot;:endwhile&quot; are executed for as long as the
condition is true.  The condition used here is the expression &quot;i &lt; 5&quot;.  This
is true when the variable i is smaller than five.
   The &quot;:echo&quot; command prints its arguments.  In this case the string &quot;count
is&quot; and the value of the variable i.  Since i is one, this will print:

<span class="highlight"><b>        count is 1 </b><span><font color="#e5e5e5">~</font>

Then there is another &quot;:let i =&quot; command.  The value used is the expression &quot;i
+ 1&quot;.  This adds one to the variable i and assigns the new value to the same
variable.
   The output of the example code is:

<span class="highlight"><b>        count is 1 </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        count is 2 </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        count is 3 </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        count is 4 </b><span><font color="#e5e5e5">~</font>

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        If you happen to write a while loop that keeps on running, you can
        interrupt it by pressing <span class="highlight"><i>CTRL-C</i></font></span> (<span class="highlight"><i>CTRL-Break</i><span> on MS-Windows).


THREE KINDS OF NUMBERS

Numbers can be decimal, hexadecimal or octal.  A hexadecimal number starts
with &quot;0x&quot; or &quot;0X&quot;.  For example &quot;0x1f&quot; is 31.  An octal number starts with a
zero.  &quot;017&quot; is 15.  Careful: don't put a zero before a decimal number, it
will be intepreted as an octal number!
   The &quot;:echo&quot; command always prints decimal numbers.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :echo 0x7f 036</b><span>
<font color="#e5e5e5">&lt;</font><span class="highlight"><b>       127 30 </b><span><font color="#e5e5e5">~</font>

A number is made negative with a minus sign.  This also works for hexadecimal
and octal numbers.   A minus sign is also for substraction.  Compare this with
the previous example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :echo 0x7f -036</b><span>
<font color="#e5e5e5">&lt;</font><span class="highlight"><b>       97 </b><span><font color="#e5e5e5">~</font>

White space in an expression is ignored.  However, it's recommended to use it
for separating items, to make the expression easier to read.  For example, to
avoid the confusion with a negative number, put a space between the minus sign
and the following number:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :echo 0x7f - 036</b><span>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*41.2*</i></b><span>  Variables

A variable name consists of ASCII letters, digits and the underscore.  It
cannot start with a digit.  Valid variable names are:

        counter
        _aap3
        very_long_variable_name_with_dashes
        FuncLength
        LENGTH

Invalid names are &quot;foo+bar&quot; and &quot;6var&quot;.
   These variables are global.  To see a list of currently defined variables
use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :let</b><span>

You can use global variables everywhere.  This also means that when the
variable &quot;count&quot; is used in one script file, it might also be used in another
file.  This leads to confusion at least, and real problems at worst.  To avoid
this, you can use a variable local to a script file by prepending &quot;s:&quot;.  For
example, one script contains this code:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :let s:count = 1</b><span>
<span class="highlight"><b>        :while s:count &lt; 5</b><span>
<span class="highlight"><b>        :  source other.vim</b><span>
<span class="highlight"><b>        :  let s:count = s:count + 1</b><span>
<span class="highlight"><b>        :endwhile</b><span>

Since &quot;s:count&quot; is local to this script, you can be sure that sourcing the
&quot;other.vim&quot; script will not change this variable.  If &quot;other.vim&quot; also uses an
&quot;s:count&quot; variable, it will be a different copy, local to that script.  More
about script-local variables here: <span class="highlight"><i>|script-variable|</i><span>.

There are more kinds of variables, see <span class="highlight"><i>|internal-variables|</i><span>.  The most often
used ones are:

        b:name          variable local to a buffer
        w:name          variable local to a window
        g:name          global variable (also in a function)
        v:name          variable predefined by Vim


DELETING VARIABLES

Variables take up memory and show up in the output of the &quot;:let&quot; command.  To
delete a variable use the &quot;:unlet&quot; command.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :unlet s:count</b><span>

This deletes the script-local variable &quot;s:count&quot; to free up the memory it
uses.  If you are not sure if the variable exists, and don't want an error
message when it doesn't, append !:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :unlet! s:count</b><span>

When a script finishes, the local variables used there will not be
automatically freed.  The next time the script executes, it can still use the
old value.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :if !exists(&quot;s:call_count&quot;)</b><span>
<span class="highlight"><b>        :  let s:call_count = 0</b><span>
<span class="highlight"><b>        :endif</b><span>
<span class="highlight"><b>        :let s:call_count = s:call_count + 1</b><span>
<span class="highlight"><b>        :echo &quot;called&quot; s:call_count &quot;times&quot;</b><span>

The &quot;exists()&quot; function checks if a variable has already been defined.  Its
argument is the name of the variable you want to check.  Not the variable
itself!  If you would do this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :if !exists(s:call_count)</b><span>

Then the value of s:call_count will be used as the name of the variable that
exists() checks.  That's not what you want.
   The exclamation mark ! negates a value.  When the value was true, it
becomes false.  When it was false, it becomes true.  You can read it as &quot;not&quot;.
Thus &quot;if !exists()&quot; can be read as &quot;if not exists()&quot;.
   What Vim calls true is anything that is not zero.  Only zero is false.


STRING VARIABLES AND CONSTANTS

So far only numbers were used for the variable value.  Strings can be used as
well.  Numbers and strings are the only two types of variables that Vim
supports.  The type is dynamic, it is set each time when assigning a value to
the variable with &quot;:let&quot;.
   To assign a string value to a variable, you need to use a string constant.
There are two types of these.  First the string in double quotes:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :let name = &quot;peter&quot;</b><span>
<span class="highlight"><b>        :echo name</b><span>
<font color="#e5e5e5">&lt;</font><span class="highlight"><b>       peter </b><span><font color="#e5e5e5">~</font>

If you want to include a double quote inside the string, put a backslash in
front of it:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :let name = &quot;\&quot;peter\&quot;&quot;</b><span>
<span class="highlight"><b>        :echo name</b><span>
<font color="#e5e5e5">&lt;</font><span class="highlight"><b>       &quot;peter&quot; </b><span><font color="#e5e5e5">~</font>

To avoid the need for a backslash, you can use a string in single quotes:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :let name = '&quot;peter&quot;'</b><span>
<span class="highlight"><b>        :echo name</b><span>
<font color="#e5e5e5">&lt;</font><span class="highlight"><b>       &quot;peter&quot; </b><span><font color="#e5e5e5">~</font>

Inside a single-quote string all the characters are taken literally.  The
drawback is that it's impossible to include a single quote.  A backslash is
taken literally as well, thus you can't use it to change the meaning of the
character after it.
   In double-quote strings it is possible to use special characters.  Here are
a few useful ones:

        \t              <span class="highlight"><i>&lt;Tab&gt;</i><span>
        \n              <span class="highlight"><i>&lt;NL&gt;</i><span>, line break
        \r              <span class="highlight"><i>&lt;CR&gt;</i></font></span>, <span class="highlight"><i>&lt;Enter&gt;</i><span>
        \e              <span class="highlight"><i>&lt;Esc&gt;</i><span>
        \b              <span class="highlight"><i>&lt;BS&gt;</i><span>, backspace
        \&quot;              &quot;
        \\              \, backslash
        \<span class="highlight"><i>&lt;Esc&gt;</i></font></span>          <span class="highlight"><i>&lt;Esc&gt;</i><span>
        \<span class="highlight"><i>&lt;C-W&gt;</i></font></span>          <span class="highlight"><i>CTRL-W</i><span>

The last two are just examples.  The  &quot;\<span class="highlight"><i>&lt;name&gt;</i><span>&quot; form can be used to include
the special key &quot;name&quot;.
   See <span class="highlight"><i>|expr-quote|</i><span> for the full list of special items in a string.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*41.3*</i></b><span>  Expressions

Vim has a rich, yet simple way to handle expressions.  You can read the
definition here: <span class="highlight"><i>|expression-syntax|</i><span>.  Here we will show the most common
items.
   The numbers, strings and variables mentioned above are expressions by
themselves.  Thus everywhere an expression is expected, you can use a number,
string or variable.  Other basic items in an expression are:

        $NAME           environment variable
        &amp;name           option
        @r              register

Examples:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :echo &quot;The value of 'tabstop' is&quot; &amp;ts</b><span>
<span class="highlight"><b>        :echo &quot;Your home directory is&quot; $HOME</b><span>
<span class="highlight"><b>        :if @a &gt; 5</b><span>

The &amp;option form can be used to save an option value, set it to a new value,
do something and restore the old value.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :let save_ic = &amp;ic</b><span>
<span class="highlight"><b>        :set noic</b><span>
<span class="highlight"><b>        :/The Start/,$delete</b><span>
<span class="highlight"><b>        :let &amp;ic = save_ic</b><span>

This makes sure the &quot;The Start&quot; pattern is used with the <span class="highlight"><i>'ignorecase'</i><span> option
off.  Still, it keeps the value that the user had set.


MATHEMATICS

It becomes more interesting if we combine these basic items.  Let's start with
mathematics on numbers:

        a + b           add
        a - b           subtract
        a * b           multiply
        a / b           divide
        a % b           modulo

The usual precedence is used.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :echo 10 + 5 * 2</b><span>
<font color="#e5e5e5">&lt;</font><span class="highlight"><b>       20 </b><span><font color="#e5e5e5">~</font>

Grouping is done with braces.  No suprises here.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :echo (10 + 5) * 2</b><span>
<font color="#e5e5e5">&lt;</font><span class="highlight"><b>       30 </b><span><font color="#e5e5e5">~</font>

Strings can be concatenated with &quot;.&quot;.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :echo &quot;foo&quot; . &quot;bar&quot;</b><span>
<font color="#e5e5e5">&lt;</font><span class="highlight"><b>       foobar </b><span><font color="#e5e5e5">~</font>

When the &quot;:echo&quot; command gets multiple arguments, it separates them with a
space.  In the example the argument is a single expression, thus no space is
inserted.

Borrowed from the C language is the conditional expression:

        a ? b : c

If &quot;a&quot; evaluates to true &quot;b&quot; is used, otherwise &quot;c&quot; is used.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :let i = 4</b><span>
<span class="highlight"><b>        :echo i &gt; 5 ? &quot;i is big&quot; : &quot;i is small&quot;</b><span>
<font color="#e5e5e5">&lt;</font><span class="highlight"><b>       i is small </b><span><font color="#e5e5e5">~</font>

The three parts of the constructs are always evaluated first, thus you could
see it work as:

        (a) ? (b) : (c)

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*41.4*</i></b><span>  Conditionals

The &quot;:if&quot; commands executes the following statements, until the matching
&quot;:endif&quot;, only when a condition is met.  The generic form is:

        :if <span class="highlight"><i>{condition}</i><span>
           <span class="highlight"><i>{statements}</i><span>
        :endif

Only when the expression <span class="highlight"><i>{condition}</i><span> evaluates to true (non-zero) will the
<span class="highlight"><i>{statements}</i><span> be executed.  These must still be valid commands.  If they
contain garbage, Vim won't be able to find the &quot;:endif&quot;.
   You can also use &quot;:else&quot;.  The generic form for this is:

        :if <span class="highlight"><i>{condition}</i><span>
           <span class="highlight"><i>{statements}</i><span>
        :else
           <span class="highlight"><i>{statements}</i><span>
        :endif

The second <span class="highlight"><i>{statements}</i><span> is only executed if the first one isn't.
   Finally, there is &quot;:elseif&quot;:

        :if <span class="highlight"><i>{condition}</i><span>
           <span class="highlight"><i>{statements}</i><span>
        :elseif <span class="highlight"><i>{condition}</i><span>
           <span class="highlight"><i>{statements}</i><span>
        :endif

This works just like using &quot;:else&quot; and then &quot;if&quot;, but without the need for an
extra &quot;:endif&quot;.
   A useful example for your vimrc file is checking the <span class="highlight"><i>'term'</i><span> option and
doing something depending upon its value:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :if &amp;term == &quot;xterm&quot;</b><span>
<span class="highlight"><b>        :  &quot; Do stuff for xterm</b><span>
<span class="highlight"><b>        :elseif &amp;term == &quot;vt100&quot;</b><span>
<span class="highlight"><b>        :  &quot; Do stuff for a vt100 terminal</b><span>
<span class="highlight"><b>        :else</b><span>
<span class="highlight"><b>        :  &quot; Do something for other terminals</b><span>
<span class="highlight"><b>        :endif</b><span>


LOGIC OPERATIONS

We already used some of them in the examples.  These are the most often used
ones:

        a == b          equal to
        a != b          not equal to
        a &gt;  b          greater than
        a &gt;= b          greater than or equal to
        a &lt;  b          less than
        a &lt;= b          less than or equal to

The result is one if the condition is met and zero otherwise.  An example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :if v:version &gt;= 600</b><span>
<span class="highlight"><b>        :  echo &quot;congratulations&quot;</b><span>
<span class="highlight"><b>        :else</b><span>
<span class="highlight"><b>        :  echo &quot;you are using an old version, upgrade!&quot;</b><span>
<span class="highlight"><b>        :endif</b><span>

Here &quot;v:version&quot; is a variable defined by Vim, which has the value of the Vim
version.  600 is for version 6.0.  Version 6.1 will have the value 601.
This is very useful to write a script that works with multiple versions of
Vim.  <span class="highlight"><i>|v:version|</i><span>

The logic operators work both for numbers and strings.  When comparing two
strings, the mathematical difference is used.  This compares byte values,
which may not be right for some languages.
   When comparing a string with a number, the string is first converted to a
number.  This is a bit tricky, because when a string doesn't look like a
number, the number zero is used.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :if 0 == &quot;one&quot;</b><span>
<span class="highlight"><b>        :  echo &quot;yes&quot;</b><span>
<span class="highlight"><b>        :endif</b><span>

This will echo &quot;yes&quot;, because &quot;one&quot; doesn't look like a number, thus it is
converted to the number zero.

For strings there are two more items:

        a =~ b          matches with
        a !~ b          does not match with

The left item &quot;a&quot; is used as a string.  The right item &quot;b&quot; is used as a
pattern, like what's used for searching.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :if str =~ &quot; &quot;</b><span>
<span class="highlight"><b>        :  echo &quot;str contains a space&quot;</b><span>
<span class="highlight"><b>        :elseif str !~ '\.$'</b><span>
<span class="highlight"><b>        :  echo &quot;str ends in a full stop&quot;</b><span>
<span class="highlight"><b>        :endif</b><span>

Notice the use of a single-quote string for the pattern.  This is useful,
because backslashes need to be doubled in a double-quote string and patterns
tend to contain many backslashes.

The <span class="highlight"><i>'ignorecase'</i><span> option is used when comparing strings.  When you don't want
that, append &quot;#&quot; to match case and &quot;?&quot; to ignore case.  Thus &quot;==?&quot; compares
two strings to be equal while ignoring case.  And &quot;!~#&quot; checks if a pattern
doesn't match, also checking the case of letters.  For the full table see
<span class="highlight"><i>|expr-==|</i><span>.


MORE LOOPING

The &quot;:while&quot; command was already mentioned.  Two more statements can be used
in between the &quot;:while&quot; and the &quot;:endwhile&quot;:

        :continue               Jump back to the start of the while loop; the
                                loop continues.
        :break                  Jump forward to the &quot;:endwhile&quot;; the loop is
                                discontinued.

Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :while counter &lt; 40</b><span>
<span class="highlight"><b>        :  call do_something()</b><span>
<span class="highlight"><b>        :  if skip_flag</b><span>
<span class="highlight"><b>        :    continue</b><span>
<span class="highlight"><b>        :  endif</b><span>
<span class="highlight"><b>        :  if finished_flag</b><span>
<span class="highlight"><b>        :    break</b><span>
<span class="highlight"><b>        :  endif</b><span>
<span class="highlight"><b>        :  sleep 50m</b><span>
<span class="highlight"><b>        :endwhile</b><span>

The &quot;:sleep&quot; command makes Vim take a nap.  The &quot;50m&quot; specifies fifty
milliseconds.  Another example is &quot;:sleep 4&quot;, which sleeps for four seconds.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*41.5*</i></b><span>  Executing an expression

So far the commands in the script were executed by Vim directly.  The
&quot;:execute&quot; command allows executing the result of an expression.  This is a
very powerful way to build commands and execute them.
   An example is to jump to a tag, which is contained in a variable:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :execute &quot;tag &quot; . tag_name</b><span>

The &quot;.&quot; is used to concatenate the string &quot;tag &quot; with the value of variable
&quot;tag_name&quot;.  Suppose &quot;tag_name&quot; has the value &quot;get_cmd&quot;, then the command that
will be executed is:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :tag get_cmd</b><span>

The &quot;:execute&quot; command can only execute colon commands.  The &quot;:normal&quot; command
executes Normal mode commands.  However, its argument is not an expression but
the literal command characters.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :normal gg=G</b><span>

This jumps to the first line and formats all lines with the &quot;=&quot; operator.
   To make &quot;:normal&quot; work with an expression, combine &quot;:execute&quot; with it.
Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :execute &quot;normal &quot; . normal_commands</b><span>

The variable &quot;normal_commands&quot; must contain the Normal mode commands.
   Make sure that the argument for &quot;:normal&quot; is a complete command.  Otherwise
Vim will run into the end of the argument and abort the command.  For example,
if you start Insert mode, you must leave Insert mode as well.  This works:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :execute &quot;normal Inew text \&lt;Esc&gt;&quot;</b><span>

This inserts &quot;new text &quot; in the current line.  Notice the use of the special
key &quot;\<span class="highlight"><i>&lt;Esc&gt;</i></font></span>&quot;.  This avoids having to enter a real <span class="highlight"><i>&lt;Esc&gt;</i><span> character in your
script.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*41.6*</i></b><span>  Using functions

Vim defines many functions and provides a large amount of functionality that
way.  A few examples will be given in this section.  You can find the whole
list here: <span class="highlight"><i>|functions|</i><span>.

A function is called with the &quot;:call&quot; command.  The parameters are passed in
between braces, separated by commas.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :call search(&quot;Date: &quot;, &quot;W&quot;)</b><span>

This calls the search() function, with arguments &quot;Date: &quot; and &quot;W&quot;.  The
search() function uses its first argument as a search pattern and the second
one as flags.  The &quot;W&quot; flag means the search doesn't wrap around the end of
the file.

A function can be called in an expression.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :let line = getline(&quot;.&quot;)</b><span>
<span class="highlight"><b>        :let repl = substitute(line, '\a', &quot;*&quot;, &quot;g&quot;)</b><span>
<span class="highlight"><b>        :call setline(&quot;.&quot;, repl)</b><span>

The getline() function obtains a line from the current file.  Its argument is
a specification of the line number.  In this case &quot;.&quot; is used, which means the
line where the cursor.
   The substitute() function does something similar to the &quot;:substitute&quot;
command.  The first argument is the string on which to perform the
substitution.  The second argument is the pattern, the third the replacement
string.  Finally, the last arguments are the flags.
   The setline() function sets the line, specified by the first argument, to a
new string, the second argument.  In this example the line under the cursor is
replaced with the result of the substitute().  Thus the effect of the three
statements is equal to:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :substitute/\a/*/g</b><span>

Using the functions becomes more interesting when you do more work before and
after the substitute() call.


<span class="highlight"><b>FUNCTIONS                                               </b></font></span><span class="highlight"><b><i>*function-list*</i></b><span>

There are many functions.  We will mention them here, grouped by what they are
used for.  You can find an alphabetical list here: <span class="highlight"><i>|functions|</i></font></span>.  Use <span class="highlight"><i>CTRL-]</i><span> on
the function name to jump to detailed help on it.

String manipulation:
        char2nr()               get ASCII value of a character
        nr2char()               get a character by its ASCII value
        escape()                escape characters in a string with a '\'
        strtrans()              translate a string to make it printable
        tolower()               turn a string to lowercase
        toupper()               turn a string to uppercase
        match()                 position where a pattern matches in a string
        matchend()              position where a pattern match ends in a string
        matchstr()              match of a pattern in a string
        stridx()                first index of a short string in a long string
        strridx()               last index of a short string in a long string
        strlen()                length of a string
        substitute()            substitute a pattern match with a string
        submatch()              get a specific match in a &quot;:substitute&quot;
        strpart()               get part of a string
        expand()                expand special keywords
        type()                  type of a variable

Working with text in the current buffer:
        byte2line()             get line number at a specific byte count
        line2byte()             byte count at a specific line
        col()                   column number of the cursor or a mark
        virtcol()               screen column of the cursor or a mark
        line()                  line number of the cursor or mark
        wincol()                window column number of the cursor
        winline()               window line number of the cursor
        getline()               get a line from the buffer
        setline()               replace a line in the buffer
        append()                append <span class="highlight"><i>{string}</i></font></span> below line <span class="highlight"><i>{lnum}</i><span>
        indent()                indent of a specific line
        cindent()               indent according to C indenting
        lispindent()            indent according to Lisp indenting
        nextnonblank()          find next non-blank line
        prevnonblank()          find previous non-blank line
        search()                find a match for a pattern
        searchpair()            find the other end of a start/skip/end

System functions and manipulation of files:
        browse()                put up a file requester
        glob()                  expand wildcards
        globpath()              expand wildcards in a number of directories
        resolve()               find out where a shortcut points to
        fnamemodify()           modify a file name
        executable()            check if an executable program exists
        filereadable()          check if a file can be read
        isdirectory()           check if a directory exists
        getcwd()                get the current working directory
        getfsize()              get the size of a file
        getftime()              get last modification time of a file
        localtime()             get current time
        strftime()              convert time to a string
        tempname()              get the name of a temporary file
        delete()                delete a file
        rename()                rename a file
        system()                get the result of a shell command
        hostname()              name of the system

Buffers, windows and the argument list:
        argc()                  number of entries in the argument list
        argidx()                current position in the argument list
        argv()                  get one entry from the argument list
        bufexists()             check if a buffer exists
        buflisted()             check if a buffer exists and is listed
        bufloaded()             check if a buffer exists and is loaded
        bufname()               get the name of a specific buffer
        bufnr()                 get the buffer number of a specific buffer
        winnr()                 get the window number for the current window
        bufwinnr()              get the window number of a specific buffer
        winbufnr()              get the buffer number of a specific window
        getbufvar()             get a variable value from a specific buffer
        setbufvar()             set a variable in a specific buffer
        getwinvar()             get a variable value from a specific window
        setwinvar()             set a variable in a specific buffer

Folding:
        foldclosed()            check for a closed fold at a specific line
        foldlevel()             check for the fold level at a specific line
        foldtext()              generate the line displayed for a closed fold

Syntax highlighting:
        hlexists()              check if a highlight group exists
        hlID()                  get ID of a highlight group
        synID()                 get syntax ID at a specific position
        synIDattr()             get a specific attribute of a syntax ID
        synIDtrans()            get translated syntax ID

History:
        histadd()               add an item to a history
        histdel()               delete an item from a history
        histget()               get an item from a history
        histnr()                get highest index of a history list

Interactive:
        confirm()               let the user make a choice
        getchar()               get a character from the user
        getcharmod()            get modifiers for the last typed character
        input()                 get a line from the user
        inputsecret()           get a line from the user without showing it
        inputdialog()           get a line from the user in a dialog

Vim server:
        serverlist()            return the list of server names
        remote_send()           send command characters to a Vim server
        remote_expr()           evaluate an expression in a Vim server
        server2client()         send a reply to a client of a Vim server
        remote_peek()           check if there is a reply from a Vim server
        remote_read()           read a reply from a Vim server
        foreground()            move the Vim window to the foreground
        remote_foreground()     move the Vim server window to the foreground

Various:
        mode()                  get current editing mode
        visualmode()            last visual mode used
        hasmapto()              check if a mapping exists
        mapcheck()              check if a matching mapping exists
        maparg()                get rhs of a mapping
        exists()                check if a variable, function, etc. exists
        has()                   check if a feature is supported in Vim
        cscope_connection()     check if a cscope connection exists
        did_filetype()          check if a FileType autocommand was used
        eventhandler()          check if invoked by an event handler
        getwinposx()            X position of the GUI Vim window
        getwinposy()            Y position of the GUI Vim window
        winheight()             get height of a specific window
        winwidth()              get width of a specific window
        libcall()               call a function in an external library
        libcallnr()             idem, returning a number

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*41.7*</i></b><span>  Defining a function

Vim enables you to define your own functions.  The basic function declaration
begins as follows:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :function {name}({var1}, {var2}, ...)</b><span>
<span class="highlight"><b>        :  {body}</b><span>
<span class="highlight"><b>        :endfunction</b><span>
<font color="#e5e5e5">&lt;</font>
        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        Function names must begin with a capital letter.

Let's define a short function to return the smaller of two numbers.  It starts
with this line:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :function Min(num1, num2)</b><span>

This tells Vim that the function is named &quot;Min&quot; and it takes two arguments:
&quot;num1&quot; and &quot;num2&quot;.
   The first thing you need to do is to check to see which number is smaller:
  <font color="#e5e5e5"> &gt;</font>
<span class="highlight"><b>        :  if a:num1 &lt; a:num2</b><span>

The special prefix &quot;a:&quot; tells Vim that the variable is a function argument.
Let's assign the variable smaller the value of the smallest number:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :  if a:num1 &lt; a:num2</b><span>
<span class="highlight"><b>        :    let smaller = a:num1</b><span>
<span class="highlight"><b>        :  else</b><span>
<span class="highlight"><b>        :    let smaller = a:num2</b><span>
<span class="highlight"><b>        :  endif</b><span>

The variable &quot;smaller&quot; is a local variable.  Variables used inside a function
are local unless prefixed by something like &quot;g:&quot;, &quot;a:&quot;, or &quot;s:&quot;.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        To access a global variable from inside a function you must prepend
        &quot;g:&quot; to it.  Thus &quot;g:count&quot; inside a function is used for the global
        variable &quot;count&quot;, and &quot;count&quot; is another variable, local to the
        function.

You now use the &quot;:return&quot; statement to return the smallest number to the user.
Finally, you end the function:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :  return smaller</b><span>
<span class="highlight"><b>        :endfunction</b><span>

The complete function definition is as follows:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :function Min(num1, num2)</b><span>
<span class="highlight"><b>        :  if a:num1 &lt; a:num2</b><span>
<span class="highlight"><b>        :    let smaller = a:num1</b><span>
<span class="highlight"><b>        :  else</b><span>
<span class="highlight"><b>        :    let smaller = a:num2</b><span>
<span class="highlight"><b>        :  endif</b><span>
<span class="highlight"><b>        :  return smaller</b><span>
<span class="highlight"><b>        :endfunction</b><span>

A user defined function is called in exactly the same way as a builtin
function.  Only the name is different.  The Min function can be used like
this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :echo Min(5, 8)</b><span>

Only now will the function be executed and the lines be interpreted by Vim.
If there are mistakes, like using an undefined variable or function, you will
now get an error message.  When defining the function these errors are not
detected.

When a function reaches &quot;:endfunction&quot; or &quot;:return&quot; is used without an
argument, the function returns zero.

To redefine a function that already exists, use the ! for the &quot;:function&quot;
command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :function!  Min(num1, num2, num3)</b><span>


USING A RANGE

The &quot;:call&quot; command can be given a line range.  This can have one of two
meanings.  When a function has been defined with the &quot;range&quot; keyword, it will
take care of the line range itself.
  The function will be passed the variables &quot;a:firstline&quot; and &quot;a:lastline&quot;.
These will have the line numbers from the range the function was called with.
Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :function Count_words() range</b><span>
<span class="highlight"><b>        :  let n = a:firstline</b><span>
<span class="highlight"><b>        :  let count = 0</b><span>
<span class="highlight"><b>        :  while n &lt;= a:lastline</b><span>
<span class="highlight"><b>        :    let count = count + Wordcount(getline(n))</b><span>
<span class="highlight"><b>        :  endwhile</b><span>
<span class="highlight"><b>        :  echo &quot;found &quot; . count . &quot; words&quot;</b><span>
<span class="highlight"><b>        :endfunction</b><span>

You can call this function with:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :10,30call Count_words()</b><span>

It will be executed once and echo the number of words.
   The other way to use a line range is by defining a function without the
&quot;range&quot; keyword.  The function will be called once for every line in the
range, with the cursor in that line.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :function  Number()</b><span>
<span class="highlight"><b>        :  echo &quot;line &quot; . line(&quot;.&quot;) . &quot; contains: &quot; . getline(&quot;.&quot;)</b><span>
<span class="highlight"><b>        :endfunction</b><span>

If you call this function with:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :10,15call Number()</b><span>

The function will be called six times.


VARIABLE NUMBER OF ARGUMENTS

Vim enables you to define functions that have a variable number of arguments.
The following command, for instance, defines a function that must have 1
argument (start) and can have up to 20 additional arguments:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :function Show(start, ...)</b><span>

The variable &quot;a:1&quot; contains the first optional argument, &quot;a:2&quot; the second, and
so on.  The variable &quot;a:0&quot; contains the number of extra arguments.
   For example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :function Show(start, ...)</b><span>
<span class="highlight"><b>        :  echohl Title</b><span>
<span class="highlight"><b>        :  echo &quot;Show is &quot; . a:start</b><span>
<span class="highlight"><b>        :  echohl None</b><span>
<span class="highlight"><b>        :  let index = 1</b><span>
<span class="highlight"><b>        :  while index &lt;= a:0</b><span>
<span class="highlight"><b>        :    execute 'echon &quot;  Arg &quot; . index . &quot; is &quot; . a:' . index</b><span>
<span class="highlight"><b>        :    let index = index + 1</b><span>
<span class="highlight"><b>        :  endwhile</b><span>
<span class="highlight"><b>        :  echo &quot;&quot;</b><span>
<span class="highlight"><b>        :endfunction</b><span>

This uses the &quot;:echohl&quot; command to specify the highlighting used for the
following &quot;:echo&quot; command.  &quot;:echohl None&quot; stops it again.  The &quot;:echon&quot;
command works like &quot;:echo&quot;, but doesn't output a line break.


LISTING FUNCTIONS

The &quot;:function&quot; command lists the names and arguments of all user-defined
functions:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :function</b><span>
<font color="#e5e5e5">&lt;</font><span class="highlight"><b>       function Show(start, ...) </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        function GetVimIndent()</b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        function SetSyn(name) </b><span><font color="#e5e5e5">~</font>

To see what a function does, use its name as an argument for &quot;:function&quot;:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :function Show</b><span>
<font color="#e5e5e5">&lt;</font><span class="highlight"><b>       1          :  echo &quot;Show is &quot; . a:start </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        2          :  let index = 1 </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        3          :  while index &lt;= a:0 </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        4          :    execute 'echo &quot;Arg &quot; . index . &quot; is &quot; . a:' . index </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        5          :    let index = index + 1 </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        6          :  endwhile </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>           endfunction </b><span><font color="#e5e5e5">~</font>


DEBUGGING

The line number is useful for when you get an error message or when debugging.
See <span class="highlight"><i>|debug-scripts|</i><span> about debugging mode.
   You can also set the <span class="highlight"><i>'verbose'</i><span> option to 12 or higher to see all function
calls.  Set it to 15 or higher to see every executed line.


DELETING A FUNCTION

To delete the Show() function:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :delfunction Show</b><span>

You get an error when the function doesn't exist.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*41.8*</i></b><span>  Various remarks

Here is a summary of items that apply to Vim scripts.  They are also mentioned
elsewhere, but form a nice checklist.

The end-of-line character depends on the system.  For Unix a single <span class="highlight"><i>&lt;NL&gt;</i><span>
character is used.  For MS-DOS, Windows, OS/2 and the like, <span class="highlight"><i>&lt;CR&gt;&lt;LF&gt;</i><span> is used.
This is important when using mappings that end in a <span class="highlight"><i>&lt;CR&gt;</i></font></span>.  See <span class="highlight"><i>|:source_crnl|</i><span>.


WHITE SPACE

Blank lines are allowed and ignored.

Leading whitespace characters (blanks and TABs) are always ignored.  The
whitespaces between parameters (e.g. between the <span class="highlight"><i>'set'</i></font></span> and the <span class="highlight"><i>'cpoptions'</i><span> in the
example below) are reduced to one blank character and plays the role of a
separator, the whitespaces after the last (visible) character may or may not
be ignored depending on the situation, see below.

For a &quot;:set&quot; command involving the &quot;=&quot; (equal) sign, such as in:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set cpoptions    =aABceFst</b><span>

The whitespace immediately before the &quot;=&quot; sign is ignored.  But there can be
no whitespace after the &quot;=&quot; sign!

To include a whitespace character in the value of an option, it must be
escaped by a &quot;\&quot; (backslash)  as in the following example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set tags=my\ nice\ file</b><span>

The same example written as<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set tags=my nice file</b><span>

will issue an error, because it is interpreted as:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set tags=my</b><span>
<span class="highlight"><b>        :set nice</b><span>
<span class="highlight"><b>        :set file</b><span>


COMMENTS

The character &quot; (the double quote mark) starts a comment.  Everything after
and including this character until the end-of-line is considered a comment and
is ignored, except for commands that don't consider comments, as shown in
examples below.  A comment can start on any character position on the line.

There is a little &quot;catch&quot; with comments for some commands.  Examples:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :abbrev dev development         &quot; shorthand</b><span>
<span class="highlight"><b>        :map &lt;F3&gt; o#include             &quot; insert include</b><span>
<span class="highlight"><b>        :execute cmd                    &quot; do it</b><span>
<span class="highlight"><b>        :!ls *.c                        &quot; list C files</b><span>

The abbreviation <span class="highlight"><i>'dev'</i><span> will be expanded to 'development     &quot; shorthand'.  The
mapping of <span class="highlight"><i>&lt;F3&gt;</i><span> will actually be the whole line after the 'o# ....' including
the '&quot; insert include'.  The &quot;execute&quot; command will give an error.  The &quot;!&quot;
command will send everything after it to the shell, causing an error for an
unmatched '&quot;' character.
   There can be no comment after &quot;:map&quot;, &quot;:abbreviate&quot;, &quot;:execute&quot; and &quot;!&quot;
commands (there are a few more commands with this restriction).  For the
&quot;map&quot;, &quot;:abbreviate&quot; and &quot;execute&quot; commands there is a trick:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :abbrev dev development|&quot; shorthand</b><span>
<span class="highlight"><b>        :map &lt;F3&gt; o#include|&quot; insert include</b><span>
<span class="highlight"><b>        :execute cmd                    |&quot; do it</b><span>

With the '|' character the command is separated from the next one.  And that
next command is only a comment.

Notice that there is no white space before the '|' in the abbreviation and
mapping.  For these commands, any character until the end-of-line or '|' is
included.  As a consequence of this behavior, you don't always see that
trailing whitespace is included:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :map &lt;F4&gt; o#include  </b><span>

To avoid these problems, you can set the <span class="highlight"><i>'list'</i><span> option when editing vimrc
files.


PITFALLS

Even bigger problem arises in the following example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :map ,ab o#include</b><span>
<span class="highlight"><b>        :unmap ,ab </b><span>

Here the unmap command will not work, because it tries to unmap &quot;,ab &quot;.  This
does not exist as a mapped sequence.  An error will be issued, which is very
hard to identify, because the ending whitespace character on the 'unmap ,ab '
is not visible.

And this is the same as what happens when one uses a comment after an <span class="highlight"><i>'unmap'</i><span>
command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :unmap ,ab     &quot; comment</b><span>

Here the comment part will be ignored.  However, Vim will try to unmap
',ab     ', which does not exist.  Rewreite it as:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :unmap ,ab|&quot; comment</b><span>


RESTORING THE VIEW

Sometimes you want to make a change and go back to where cursor was.
Restoring the relative position would also be nice, so that the same line
appears at the top of the window.
   This example yanks the current line, puts it above the first line in the
file and then restores the view:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        map ,p ma&quot;aYHmbgg&quot;aP`bzt`a</b><span>

What this does:<font color="#e5e5e5"> &gt;</font>
<span class="highlight"><b>        ma&quot;aYHmbgg&quot;aP`bzt`a</b><span>
<font color="#e5e5e5">&lt;</font>       ma                      set mark a at cursor position
          &quot;aY                   yank current line into register a
             Hmb                go to top line in window and set mark b there
                gg              go to first line in file
                  &quot;aP           put the yanked line above it
                     `b         go back to top line in display
                       zt       position the text in the window as before
                         `a     go back to saved cursor position


PACKAGING

To avoid your function names to interfere with functions that you get from
others, use this scheme:
- Prepend a unique string before each function name.  I often use an
  abbreviation.  For example, &quot;OW_&quot; is used for the option window functions.
- Put the definition of your functions together in a file.  Set a global
  variable to indicate that the functions have been loaded.  When sourcing the
  file again, first unload the functions.
Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        &quot; This is the XXX package</b><span>

<span class="highlight"><b>        if exists(&quot;XXX_loaded&quot;)</b><span>
<span class="highlight"><b>          delfun XXX_one</b><span>
<span class="highlight"><b>          delfun XXX_two</b><span>
<span class="highlight"><b>        endif</b><span>

<span class="highlight"><b>        function XXX_one(a)</b><span>
<span class="highlight"><b>                ... body of function ...</b><span>
<span class="highlight"><b>        endfun</b><span>

<span class="highlight"><b>        function XXX_two(b)</b><span>
<span class="highlight"><b>                ... body of function ...</b><span>
<span class="highlight"><b>        endfun</b><span>

<span class="highlight"><b>        let XXX_loaded = 1</b><span>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*41.9*</i></b></font></span>  Writing a plugin                                <span class="highlight"><b><i>*write-plugin*</i></b><span>

You can write a Vim script in such a way that many people can use it.  This is
called a plugin.  Vim users can drop your script in their plugin directory and
use its features right away <span class="highlight"><i>|add-plugin|</i><span>.

There are actually two types of plugins:

  global plugins: For all types of files.
filetype plugins: Only for files of a specific type.

In this section the first type is explained.  Most items are also relevant for
writing filetype plugins.  The specifics for filetype plugins are in the next
section <span class="highlight"><i>|write-filetype-plugin|</i><span>.


NAME

First of all you must choose a name for your plugin.  The features provided
by the plugin should be clear from its name.  And it should be unlikely that
someone else writes a plugin with the same name but which does something
different.  And please limit the name to 8 characters, to avoid problems on
old Windows systems.

A script that corrects typing mistakes could be called &quot;typecorr.vim&quot;.  We
will use it here as an example.

For the plugin to work for everybody, it should follow a few guidelines.  This
will be explained step-by-step.  The complete example plugin is at the end.


BODY

Let's start with the body of the plugin, the lines that do the actual work:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b> 13     iabbrev teh the</b><span>
<span class="highlight"><b> 14     iabbrev otehr other</b><span>
<span class="highlight"><b> 15     iabbrev wnat want</b><span>
<span class="highlight"><b> 16     iabbrev synchronisation</b><span>
<span class="highlight"><b> 17             \ synchronization</b><span>
<span class="highlight"><b> 18     let s:count = 4</b><span>

The actual list should be much longer, of course.

The line numbers have only been added to explain a few things, don't put them
in your plugin file!


HEADER

You will probably add new corrections to the plugin and soon have several
versions laying around.  And when distributing this file, people will want to
know who wrote this wonderful plugin and where they can send remarks.
Therefore, put a header at the top of your plugin:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>  1     &quot; Vim global plugin for correcting typing mistakes</b><span>
<span class="highlight"><b>  2     &quot; Last Change: 2000 Oct 15</b><span>
<span class="highlight"><b>  3     &quot; Maintainer: Bram Moolenaar &lt;Bram@vim.org&gt;</b><span>


LINE CONTINUATION, AVOIDING SIDE EFFECTS

In line 17 above, the line-continuation mechanism is used <span class="highlight"><i>|line-continuation|</i><span>.
Users with <span class="highlight"><i>'compatible'</i><span> set will run into trouble here, they will get an error
message.  We can't just reset <span class="highlight"><i>'compatible'</i><span>, because that has a lot of side
effects.  To avoid this, we will set the <span class="highlight"><i>'cpoptions'</i><span> option to its Vim default
value and restore it later.  That will allow the use of line-continuation and
make the script work for most people.  It is done like this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b> 10     let s:save_cpo = &amp;cpo</b><span>
<span class="highlight"><b> 11     set cpo&amp;vim</b><span>
<span class="highlight"><b> ..</b><span>
<span class="highlight"><b> 41     let &amp;cpo = s:save_cpo</b><span>

We first store the old value of <span class="highlight"><i>'cpoptions'</i><span> in the s:save_cpo variable.  At
the end of the plugin this value is restored.

Notice that a script-local variable is used <span class="highlight"><i>|s:var|</i><span>.  A global variable could
already be in use for something else.  Always use script-local variables for
things that are only used in the script.


NOT LOADING

It's possible that a user doesn't always want to load this plugin.  Or the
system administrator has dropped it in the system-wide plugin directory, but a
user has his own plugin he wants to use.  Then the user must have a chance to
disable loading this specific plugin.  This will make it possible:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>  5     if exists(&quot;loaded_typecorr&quot;)</b><span>
<span class="highlight"><b>  6       finish</b><span>
<span class="highlight"><b>  7     endif</b><span>
<span class="highlight"><b>  8     let loaded_typecorr = 1</b><span>

This also avoids that when the script is loaded twice it would cause error
messages for redefining functions and cause trouble for autocommands that are
added twice.


MAPPING

Now let's make the plugin more interesting: We will add a mapping that adds a
correction for the word under the cursor.  We could just pick a key sequence
for this mapping, but the user might already use it for something else.  To
allow the user to define which keys a mapping in a plugin uses, the <span class="highlight"><i>&lt;Leader&gt;</i><span>
item can be used:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b> 21       map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;TypecorrAdd</b><span>

The &quot;<span class="highlight"><i>&lt;Plug&gt;</i><span>TypecorrAdd&quot; thing will do the work, more about that further on.

The user can set the &quot;mapleader&quot; variable to the key sequence that he wants
this mapping to start with.  Thus if the user has done:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        let mapleader = &quot;_&quot;</b><span>

the mapping will define &quot;_a&quot;.  If the user didn't do this, the default value
will be used, which is a backslash.  Then a map for &quot;\a&quot; will be defined.

<span class="highlight"><b><i><u>Note</u></i></b></font></span> that <span class="highlight"><i>&lt;unique&gt;</i><span> is used, this will cause an error message if the mapping
already happened to exist. <span class="highlight"><i>|:map-&lt;unique&gt;|</i><span>

But what if the user wants to define his own key sequence?  We can allow that
with this mechanism:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b> 20     if !hasmapto('&lt;Plug&gt;TypecorrAdd')</b><span>
<span class="highlight"><b> 21       map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;TypecorrAdd</b><span>
<span class="highlight"><b> 22     endif</b><span>

This checks if a mapping to &quot;<span class="highlight"><i>&lt;Plug&gt;</i><span>TypecorrAdd&quot; already exists, and only
defines the mapping from &quot;<span class="highlight"><i>&lt;Leader&gt;</i><span>a&quot; if it doesn't.  The user then has a
chance of putting this in his vimrc file:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        map ,c  &lt;Plug&gt;TypecorrAdd</b><span>

Then the mapped key sequence will be &quot;,c&quot; instead of &quot;_a&quot; or &quot;\a&quot;.


PIECES

If a script gets longer, you often want to break up the work in pieces.  You
can use functions or mappings for this.  But you don't want these functions
and mappings to interfere with the ones from other scripts.  For example, you
could define a function Add(), but another script could try to define the same
function.  To avoid this, we define the function local to the script by
prepending it with &quot;s:&quot;.

We will define a function that adds a new typing correction:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b> 29     function s:Add(from, correct)</b><span>
<span class="highlight"><b> 30       let to = input(&quot;type the correction for &quot; . a:from . &quot;: &quot;)</b><span>
<span class="highlight"><b> 31       exe &quot;:iabbrev &quot; . a:from . &quot; &quot; . to</b><span>
<span class="highlight"><b> ..</b><span>
<span class="highlight"><b> 35     endfunction</b><span>

Now we can call the function s:Add() from within this script.  If another
script also defines s:Add(), it will be local to that script and can only
be called from the script it was defined in.  There can also be a global Add()
function (without the &quot;s:&quot;), which is again another function.

<span class="highlight"><i>&lt;SID&gt;</i><span> can be used with mappings.  It generates a script ID, which identifies
the current script.  In our typing correction plugin we use it like this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b> 23     noremap &lt;unique&gt; &lt;script&gt; &lt;Plug&gt;TypecorrAdd  &lt;SID&gt;Add</b><span>
<span class="highlight"><b> ..</b><span>
<span class="highlight"><b> 27     noremap &lt;SID&gt;Add  :call &lt;SID&gt;Add(expand(&quot;&lt;cword&gt;&quot;), 1)&lt;CR&gt;</b><span>

Thus when a user types &quot;\a&quot;, this sequence is invoked:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        \a  -&gt;  &lt;Plug&gt;TypecorrAdd  -&gt;  &lt;SID&gt;Add  -&gt;  :call &lt;SID&gt;Add()</b><span>

If another script would also map <span class="highlight"><i>&lt;SID&gt;</i><span>Add, it would get another script ID and
thus define another mapping.

<span class="highlight"><b><i><u>Note</u></i></b></font></span> that instead of s:Add() we use <span class="highlight"><i>&lt;SID&gt;</i><span>Add() here.  That is because the
mapping is typed by the user, thus outside of the script.  The <span class="highlight"><i>&lt;SID&gt;</i><span> is
translated to the script ID, so that Vim knows in which script to look for
the Add() function.

This is a bit complicated, but it's required for the plugin to work together
with other plugins.  The basic rule is that you use <span class="highlight"><i>&lt;SID&gt;</i><span>Add() in mappings and
s:Add() in other places (the script itself, autocommands, user commands).

We can also add a menu entry to do the same as the mapping:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b> 25     noremenu &lt;script&gt; Plugin.Add\ Correction      &lt;SID&gt;Add</b><span>

The &quot;Plugin&quot; menu is recommended for adding menu items for plugins.  In this
case only one item is used.  When adding more items, creating a submenu is
recommended.  For example, &quot;Plugin.CVS&quot; could be used for a plugin that offers
CVS operations &quot;Plugin.CVS.checkin&quot;, &quot;Plugin.CVS.checkout&quot;, etc.

<span class="highlight"><b><i><u>Note</u></i></b><span> that in line 27 &quot;:noremap&quot; is used to avoid that any other mappings cause
trouble.  Someone may have remapped &quot;:call&quot;, for example.  In line 23 we also
use &quot;:noremap&quot;, but we do want &quot;<span class="highlight"><i>&lt;SID&gt;</i><span>Add&quot; to be remapped.  This is why
&quot;<span class="highlight"><i>&lt;script&gt;</i><span>&quot; is used here.  This only allows mappings which are local to the
script. <span class="highlight"><i>|:map-&lt;script&gt;|</i><span>  The same is done in line 25 for &quot;:noremenu&quot;.
<span class="highlight"><i>|:menu-&lt;script&gt;|</i><span>


<span class="highlight"><i>&lt;SID&gt;</i></font></span> AND <span class="highlight"><i>&lt;Plug&gt;</i><span>

Both <span class="highlight"><i>&lt;SID&gt;</i></font></span> and <span class="highlight"><i>&lt;Plug&gt;</i><span> are used to avoid that mappings of typed keys interfere
with mappings that are only to be used from other mappings.  <span class="highlight"><b><i><u>Note</u></i></b><span> the
difference between using <span class="highlight"><i>&lt;SID&gt;</i></font></span> and <span class="highlight"><i>&lt;Plug&gt;</i><span>:

<span class="highlight"><i>&lt;Plug&gt;</i><span>  is visible outside of the script.  It is used for mappings which the
        user might want to map a key sequence to.  <span class="highlight"><i>&lt;Plug&gt;</i><span> is a special code
        that a typed key will never produce.
        To make it very unlikely that other plugins use the same sequence of
        characters, use this structure: <span class="highlight"><i>&lt;Plug&gt;</i><span> scriptname mapname
        In our example the scriptname is &quot;Typecorr&quot; and the mapname is &quot;Add&quot;.
        This results in &quot;<span class="highlight"><i>&lt;Plug&gt;</i><span>TypecorrAdd&quot;.  Only the first character of
        scriptname and mapname is uppercase, so that we can see where mapname
        starts.

<span class="highlight"><i>&lt;SID&gt;</i><span>   is the script ID, a unique identifier for a script.
        Internally Vim translates <span class="highlight"><i>&lt;SID&gt;</i></font></span> to &quot;<span class="highlight"><i>&lt;SNR&gt;</i><span>123_&quot;, where &quot;123&quot; can be any
        number.  Thus a function &quot;<span class="highlight"><i>&lt;SID&gt;</i></font></span>Add()&quot; will have a name &quot;<span class="highlight"><i>&lt;SNR&gt;</i><span>11_Add()&quot;
        in one script, and &quot;<span class="highlight"><i>&lt;SNR&gt;</i><span>22_Add()&quot; in another.  You can see this if
        you use the &quot;:function&quot; command to get a list of functions.  The
        translation of <span class="highlight"><i>&lt;SID&gt;</i><span> in mappings is exactly the same, that's how you
        can call a script-local function from a mapping.


USER COMMAND

Now let's add a user command to add a correction:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b> 37     if !exists(&quot;:Correct&quot;)</b><span>
<span class="highlight"><b> 38       command -nargs=1  Correct  :call s:Add(&lt;q-args&gt;, 0)</b><span>
<span class="highlight"><b> 39     endif</b><span>

The user command is defined only if no command with the same name already
exists.  Otherwise we would get an error here.  Overriding the existing user
command with &quot;:command!&quot; is not a good idea, this would probably make the user
wonder why the command he defined himself doesn't work.  <span class="highlight"><i>|:command|</i><span>


SCRIPT VARIABLES

When a variable starts with &quot;s:&quot; it is a script variable.  It can only be used
inside a script.  Outside the script it's not visible  This avoids trouble
with using the same variable name in different scripts.  The variables will be
kept as long as Vim is running.  And the same variables are used when sourcing
the same script again. <span class="highlight"><i>|s:var|</i><span>

The fun is that these variables can also be used in functions, autocommands
and user commands that are defined in the script.  In our example we can add
a few lines to count the number of corrections:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b> 18     let s:count = 4</b><span>
<span class="highlight"><b> ..</b><span>
<span class="highlight"><b> 29     function s:Add(from, correct)</b><span>
<span class="highlight"><b> ..</b><span>
<span class="highlight"><b> 33       let s:count = s:count + 1</b><span>
<span class="highlight"><b> 34       echo s:count . &quot; corrections now&quot;</b><span>
<span class="highlight"><b> 35     endfunction</b><span>

First s:count is initialized to 4 in the script itself.  When later the
s:Add() function is called, it increments s:count.  It doesn't matter from
where the function was called, since it has been defined in the script, it
will use the local variables from this script.


THE RESULT

Here is the resulting complete example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>  1     &quot; Vim global plugin for correcting typing mistakes</b><span>
<span class="highlight"><b>  2     &quot; Last Change: 2000 Oct 15</b><span>
<span class="highlight"><b>  3     &quot; Maintainer: Bram Moolenaar &lt;Bram@vim.org&gt;</b><span>
<span class="highlight"><b>  4</b><span>
<span class="highlight"><b>  5     if exists(&quot;loaded_typecorr&quot;)</b><span>
<span class="highlight"><b>  6       finish</b><span>
<span class="highlight"><b>  7     endif</b><span>
<span class="highlight"><b>  8     let loaded_typecorr = 1</b><span>
<span class="highlight"><b>  9</b><span>
<span class="highlight"><b> 10     let s:save_cpo = &amp;cpo</b><span>
<span class="highlight"><b> 11     set cpo&amp;vim</b><span>
<span class="highlight"><b> 12</b><span>
<span class="highlight"><b> 13     iabbrev teh the</b><span>
<span class="highlight"><b> 14     iabbrev otehr other</b><span>
<span class="highlight"><b> 15     iabbrev wnat want</b><span>
<span class="highlight"><b> 16     iabbrev synchronisation</b><span>
<span class="highlight"><b> 17             \ synchronization</b><span>
<span class="highlight"><b> 18     let s:count = 4</b><span>
<span class="highlight"><b> 19</b><span>
<span class="highlight"><b> 20     if !hasmapto('&lt;Plug&gt;TypecorrAdd')</b><span>
<span class="highlight"><b> 21       map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;TypecorrAdd</b><span>
<span class="highlight"><b> 22     endif</b><span>
<span class="highlight"><b> 23     noremap &lt;unique&gt; &lt;script&gt; &lt;Plug&gt;TypecorrAdd  &lt;SID&gt;Add</b><span>
<span class="highlight"><b> 24</b><span>
<span class="highlight"><b> 25     noremenu &lt;script&gt; Plugin.Add\ Correction      &lt;SID&gt;Add</b><span>
<span class="highlight"><b> 26</b><span>
<span class="highlight"><b> 27     noremap &lt;SID&gt;Add  :call &lt;SID&gt;Add(expand(&quot;&lt;cword&gt;&quot;), 1)&lt;CR&gt;</b><span>
<span class="highlight"><b> 28</b><span>
<span class="highlight"><b> 29     function s:Add(from, correct)</b><span>
<span class="highlight"><b> 30       let to = input(&quot;type the correction for &quot; . a:from . &quot;: &quot;)</b><span>
<span class="highlight"><b> 31       exe &quot;:iabbrev &quot; . a:from . &quot; &quot; . to</b><span>
<span class="highlight"><b> 32       if a:correct | exe &quot;normal viws\&lt;C-R&gt;\&quot; \b\e&quot; | endif</b><span>
<span class="highlight"><b> 33       let s:count = s:count + 1</b><span>
<span class="highlight"><b> 34       echo s:count . &quot; corrections now&quot;</b><span>
<span class="highlight"><b> 35     endfunction</b><span>
<span class="highlight"><b> 36</b><span>
<span class="highlight"><b> 37     if !exists(&quot;:Correct&quot;)</b><span>
<span class="highlight"><b> 38       command -nargs=1  Correct  :call s:Add(&lt;q-args&gt;, 0)</b><span>
<span class="highlight"><b> 39     endif</b><span>
<span class="highlight"><b> 40</b><span>
<span class="highlight"><b> 41     let &amp;cpo = s:save_cpo</b><span>

Line 32 wasn't explained yet.  It applies the new correction to the word under
the cursor.  The <span class="highlight"><i>|:normal|</i></font></span> command is used to use the new abbreviation.  <span class="highlight"><b><i><u>Note</u></i></b><span>
that mappings and abbreviations are expanded here, even though the function
was called from a mapping defined with &quot;:noremap&quot;.


DOCUMENTATION
<span class="highlight"><b>                                                        </b></font></span><span class="highlight"><b><i>*write-local-help*</i></b><span>
It's a good idea to also write some documentation for your plugin.  Especially
when its behavior can be changed by the user.  See <span class="highlight"><i>|add-local-help|</i><span> for how
they are installed.

Here is a simple example for a plugin help file, called &quot;typecorr.txt&quot;:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>  1     *typecorr.txt*  Plugin for correcting typing mistakes</b><span>
<span class="highlight"><b>  2</b><span>
<span class="highlight"><b>  3     If you make typing mistakes, this plugin will have them corrected</b><span>
<span class="highlight"><b>  4     automatically.</b><span>
<span class="highlight"><b>  5</b><span>
<span class="highlight"><b>  6     There are currently only a few corrections.  Add your own if you like.</b><span>
<span class="highlight"><b>  7</b><span>
<span class="highlight"><b>  8     Mappings:</b><span>
<span class="highlight"><b>  9     &lt;Leader&gt;a   or   &lt;Plug&gt;TypecorrAdd</b><span>
<span class="highlight"><b> 10             Add a correction for the word under the cursor.</b><span>
<span class="highlight"><b> 11</b><span>
<span class="highlight"><b> 12     Commands:</b><span>
<span class="highlight"><b> 13     :Correct {word}</b><span>
<span class="highlight"><b> 14             Add a correction for {word}.</b><span>
<span class="highlight"><b> 15</b><span>
<span class="highlight"><b> 16                                                     *typecorr-settings*</b><span>
<span class="highlight"><b> 17     This plugin doesn't have any settings.</b><span>

The first line is actually the only one for which the format matters.  It will
be extracted from the help file to be put in the &quot;LOCAL ADDITIONS:&quot; section of
help.txt.  The first &quot;*&quot; must be in the first column of the first line.

You can add more tags inside ** in your help file.  But be careful not to use
existing help tags.  You would probably use the name of your plugin in most of
them, like &quot;typecorr-settings&quot; in the example.

Using references to other parts of the help in || is recommended.  This makes
it easy for the user to find associated help.


<span class="highlight"><b>SUMMARY                                                 </b></font></span><span class="highlight"><b><i>*plugin-special*</i></b><span>

Summary of special things to use in a plugin:

s:name                  Variables local to the script.

<span class="highlight"><i>&lt;SID&gt;</i><span>                   Script-ID, used for mappings and functions local to
                        the script.

hasmapto()              Function to test if the user already defined a mapping
                        for functionality the script offers.

<span class="highlight"><i>&lt;Leader&gt;</i><span>                Value of &quot;mapleader&quot;, which the user defines as the
                        keys that plugin mappings start with.

:map <span class="highlight"><i>&lt;unique&gt;</i><span>           Give a warning if a mapping already exists.

:noremap <span class="highlight"><i>&lt;script&gt;</i><span>       Use only mappings local to the script, not global
                        mappings.

exists(&quot;:Cmd&quot;)          Check if a user command already exists.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*41.10*</i></b></font></span> Writing a filetype plugin       <span class="highlight"><b><i>*write-filetype-plugin*</i></b><span> <span class="highlight"><b><i>*ftplugin*</i></b><span>

A filetype plugin is like a global plugin, except that it sets options and
defines mappings for the current buffer only.  See <span class="highlight"><i>|add-filetype-plugin|</i><span> for
how this type of plugin is used.

First read the section on global plugins above <span class="highlight"><i>|41.9|</i><span>.  All that is said there
also applies to filetype plugins.  There are a few extras, which are explained
here.  The essential thing is that a filetype plugin should only have an
effect on the current buffer.


DISABLING

If you are writing a filetype plugin to be used by many people, they need a
chance to disable loading it.  Put this at the top of the plugin:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        &quot; Only do this when not done yet for this buffer</b><span>
<span class="highlight"><b>        if exists(&quot;b:did_ftplugin&quot;)</b><span>
<span class="highlight"><b>          finish</b><span>
<span class="highlight"><b>        endif</b><span>
<span class="highlight"><b>        let b:did_ftplugin = 1</b><span>

This also needs to be used to avoid that the same plugin is executed twice for
the same buffer (happens when using an &quot;:edit&quot; command without arguments).

Now users can disable loading the default plugin completely by making a filetype
plugin with only this line:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        let b:did_ftplugin = 1</b><span>

This does require that the filetype plugin directory comes before $VIMRUNTIME
in <span class="highlight"><i>'runtimepath'</i><span>!

If you do want to use the default plugin, but overrule one of the settings,
you can make a filetype plugin like this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        source $VIMRUNTIME/ftplugin/vim.vim</b><span>
<span class="highlight"><b>        set textwidth=70</b><span>

This first loads the default filetype plugin to get all its settings.  Then
the value for the <span class="highlight"><i>'textwidth'</i></font></span> option is changed to &quot;70&quot;.  <span class="highlight"><b><i><u>Note</u></i></b><span> that the
default plugin will have set &quot;b:did_ftplugin&quot;, thus when it's sourced later,
it won't do anything.


OPTIONS

To make sure the filetype plugin only affects the current buffer use the<font color="#e5e5e5"> &gt;</font>
<span class="highlight"><b>        :setlocal</b><span>
command to set options.  And only set options which are local to a buffer (see
the help for the option to check that).  When using <span class="highlight"><i>|:setlocal|</i><span> for global
options or options local to a window, the value will change for many buffers,
and that is not what a filetype plugin should do.

When an option has a value that is a list of flags or items, consider using
&quot;+=&quot; and &quot;-=&quot; to keep the existing value.  Be aware that the user may have
changed an option value already.  First resetting to the default value and
then changing it often a good idea.  Example:<font color="#e5e5e5"> &gt;</font>
<span class="highlight"><b>        :setlocal formatoptions&amp; formatoptions+=ro</b><span>


MAPPINGS

To make sure mappings will only work in the current buffer use the<font color="#e5e5e5"> &gt;</font>
<span class="highlight"><b>        :map &lt;buffer&gt;</b><span>
command.  This needs to be combined with the two-step mapping explained above.
An example of how to define funcionality in a filetype plugin:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        if !hasmapto('&lt;Plug&gt;JavaImport')</b><span>
<span class="highlight"><b>          map &lt;buffer&gt; &lt;unique&gt; &lt;LocalLeader&gt;i &lt;Plug&gt;JavaImport</b><span>
<span class="highlight"><b>        endif</b><span>
<span class="highlight"><b>        noremap &lt;buffer&gt; &lt;unique&gt; &lt;Plug&gt;JavaImport oimport &quot;&quot;&lt;Left&gt;&lt;Esc&gt;</b><span>

<span class="highlight"><i>|hasmapto()|</i><span> is used to check if the user has already defined a map to
<span class="highlight"><i>&lt;Plug&gt;</i><span>JavaImport.  If not, then the filetype plugin defines the default
mapping.  This starts with <span class="highlight"><i>|&lt;LocalLeader&gt;|</i><span>, which allows the user to select
the key(s) he wants filetype plugin mappings to start with.  The default is a
backslash.
&quot;<span class="highlight"><i>&lt;unique&gt;</i><span>&quot; is used to give an error message if the mapping already exists or
overlaps with an existing mapping.
<span class="highlight"><i>|:noremap|</i><span> is used to avoid that any other mappings that the user has defined
interferes.  You might want to use &quot;:noremap <span class="highlight"><i>&lt;script&gt;</i><span>&quot; to allow remapping
mappings defined in this script that start with <span class="highlight"><i>&lt;SID&gt;</i><span>.

The user must have a chance to disable the mappings in a filetype plugin,
without disabling everything.  Here is an example of how this is done for a
plugin for the mail filetype:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        &quot; Add mappings, unless the user didn't want this.</b><span>
<span class="highlight"><b>        if !exists(&quot;no_plugin_maps&quot;) &amp;&amp; !exists(&quot;no_mail_maps&quot;)</b><span>
<span class="highlight"><b>          &quot; Quote text by inserting &quot;&gt; &quot;</b><span>
<span class="highlight"><b>          if !hasmapto('&lt;Plug&gt;MailQuote')</b><span>
<span class="highlight"><b>            vmap &lt;buffer&gt; &lt;LocalLeader&gt;q &lt;Plug&gt;MailQuote</b><span>
<span class="highlight"><b>            nmap &lt;buffer&gt; &lt;LocalLeader&gt;q &lt;Plug&gt;MailQuote</b><span>
<span class="highlight"><b>          endif</b><span>
<span class="highlight"><b>          vnoremap &lt;buffer&gt; &lt;Plug&gt;MailQuote :s/^/&gt; /&lt;CR&gt;</b><span>
<span class="highlight"><b>          nnoremap &lt;buffer&gt; &lt;Plug&gt;MailQuote :.,$s/^/&gt; /&lt;CR&gt;</b><span>
<span class="highlight"><b>        endif</b><span>

Two global variables are used:
no_plugin_maps          disables mappings for all filetype plugins
no_mail_maps            disables mappings for a specific filetype


USER COMMANDS

To add a user command for a specific file type, so that it can only be used in
one buffer, use the &quot;-buffer&quot; argument to <span class="highlight"><i>|:command|</i><span>.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :command -buffer  Make  make %:r.s</b><span>


VARIABLES

A filetype plugin will be sourced for each buffer of the type it's for.  Local
script variables <span class="highlight"><i>|s:var|</i><span> will be shared between all invocations.  Use local
buffer variables <span class="highlight"><i>|b:var|</i><span> if you want a variable specifically for one buffer.


FUNCTIONS

When defining a function, this only needs to be done once.  But the filetype
plugin will be sourced every time a file with this filetype will be opened.
This construct make sure the function is only defined once:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :if !exists(&quot;*s:Func&quot;)</b><span>
<span class="highlight"><b>        :  function s:Func(arg)</b><span>
<span class="highlight"><b>        :    ...</b><span>
<span class="highlight"><b>        :  endfunction</b><span>
<span class="highlight"><b>        :endif</b><span>
<font color="#e5e5e5">&lt;</font>

<span class="highlight"><b>SUMMARY                                                 </b></font></span><span class="highlight"><b><i>*ftplugin-special*</i></b><span>

Summary of special things to use in a filetype plugin:

<span class="highlight"><i>&lt;LocalLeader&gt;</i><span>           Value of &quot;maplocalleader&quot;, which the user defines as
                        the keys that filetype plugin mappings start with.

:map <span class="highlight"><i>&lt;buffer&gt;</i><span>           Define a mapping local to the buffer.

:noremap <span class="highlight"><i>&lt;script&gt;</i><span>       Only remap mappings defined in this script that start
                        with <span class="highlight"><i>&lt;SID&gt;</i><span>.

:setlocal               Set an option for the current buffer only.

:command -buffer        Define a user command local to the buffer.

exists(&quot;*s:Func&quot;)       Check if a function was already defined.

Also see <span class="highlight"><i>|plugin-special|</i><span>, the special things used for all plugins.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*41.11*</i></b></font></span> Writing a compiler plugin               <span class="highlight"><b><i>*write-compiler-plugin*</i></b><span>

A compiler plugin sets options for use with a specific compiler.  The user can
load it with the <span class="highlight"><i>|:compiler|</i><span> command.  The main use is to set the
<span class="highlight"><i>'errorformat'</i></font></span> and <span class="highlight"><i>'makeprg'</i><span> options.

The only special item about these files is a mechanism to allow a user to
overrule or add to the default file.  The default files start with:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :if exists(&quot;current_compiler&quot;)</b><span>
<span class="highlight"><b>        :  finish</b><span>
<span class="highlight"><b>        :endif</b><span>
<span class="highlight"><b>        :let current_compiler = &quot;mine&quot;</b><span>

When you write a compiler file and put it in your personal runtime directory
(e.g., ~/.vim/runtime/compiler for Unix), you set the &quot;current_compiler&quot;
variable to make the default file skip the settings.

When you write a compiler plugin for the Vim distribution or for a system-wide
runtime directory, use the mechanism mentioned above.  When
&quot;current_compiler&quot; was already set by a user plugin nothing will be done.

When you write a compiler plugin to overrule settings from a default plugin,
don't check &quot;current_compiler&quot;.  This plugin is supposed to be loaded
last, thus it should be in a directory at the end of <span class="highlight"><i>'runtimepath'</i><span>.  For Unix
that could be ~/.vim/runtime/after/compiler.

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_42.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2002 Jan 23


                              Add new menus


By now you know that Vim is very flexible.  This includes the menus used in
the GUI.  You can define your own menu entries to make certain commands easily
accessible.  This is for mouse-happy users only.

<span class="highlight"><i>|42.1|</i><span>  Introduction
<span class="highlight"><i>|42.2|</i><span>  Menu commands
<span class="highlight"><i>|42.3|</i><span>  Various
<span class="highlight"><i>|42.4|</i><span>  Toolbar and popup menus


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*42.1*</i></b><span>  Introduction

The menus that Vim uses are defined in the file &quot;$VIMRUNTIME/menu.vim&quot;.  If
you want to write your own menus, you might first want to look through that
file.
   To define a menu item, use the &quot;:menu&quot; command.  The basic form of this
command is as follows:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :menu {menu-item} {keys}</b><span>

The <span class="highlight"><i>{menu-item}</i><span> describes where on the menu to put the item.  A typical
<span class="highlight"><i>{menu-item}</i><span> is &quot;File.Save&quot;, which represents the item &quot;Save&quot; under the
&quot;File&quot; menu.  A dot is used to separate the names.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :menu File.Save  :update&lt;CR&gt;</b><span>

The &quot;:update&quot; command writes the file when it was modified.
   You can add another level: &quot;Edit.Settings.Shiftwidth&quot; defines a submenu
&quot;Settings&quot; under the &quot;Edit&quot; menu, with an item &quot;Shiftwidth&quot;.  You could use
even deeper levels.  Don't use this too much, you need to move the mouse quite
a bit to use such an item.
   The &quot;:menu&quot; command is very similar to the :map command: the left side
specifies how the item is triggered and the right hand side defines the
characters that are executed.  <span class="highlight"><i>{keys}</i><span> are characters, they are used just like
you would have typed them.  Thus in Insert mode, when <span class="highlight"><i>{keys}</i><span> is plain text,
that text is inserted.


ACCELERATORS

The ampersand character (&amp;) is used to indicate an accelerator.  For instance,
you can use Alt-F to select &quot;File&quot; and S to select &quot;Save&quot;.  (the <span class="highlight"><i>'winaltkeys'</i><span>
option may disable this though!).  Therefore, the <span class="highlight"><i>{menu-item}</i><span> looks like
&quot;&amp;File.&amp;Save&quot;.  The accelerator characters will be underlined in the menu.
   You must take care that each key is used only once in each menu.  Otherwise
you will not know which of the two will actually be used.  Vim doesn't warn
you for this.


PRIORITIES

The actual definition of the File.Save menu item is as follows:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :menu 10.340 &amp;File.&amp;Save&lt;Tab&gt;:w  :confirm w&lt;CR&gt;</b><span>

The number 10.340 is called the priority number.  It is used by the editor to
decide where it places the menu item.  The first number (10) indicates the
position on the menu bar.  Lower numbered menus are positioned to the left,
higher numbers to the right.
   These are the priorities used for the standard menus:

          10    20     40     50      60       70               9999

        +------------------------------------------------------------+
        | File  Edit  Tools  Syntax  Buffers  Window            Help |
        +------------------------------------------------------------+

Notice that the Help menu is given a very high number, to make it appear on
the far right.
   The second number (340) determines the location of the item within the
pull-down menu.  Lower numbers go on top, higher number on the bottom.  These
are the priorities in the File menu:

                        +-----------------+
            10.310      |Open...          |
            10.320      |Split-Open...    |
            10.325      |New              |
            10.330      |Close            |
            10.335      |---------------- |
            10.340      |Save             |
            10.350      |Save As...       |
            10.400      |---------------- |
            10.410      |Split Diff with  |
            10.420      |Split Patched By |
            10.500      |---------------- |
            10.510      |Print            |
            10.600      |---------------- |
            10.610      |Save-Exit        |
            10.620      |Exit             |
                        +-----------------+

Notice that there is room in between the numbers.  This is where you can
insert your own items, if you really want to (it's often better to leave the
standard menus alone and add a new menu for your own items).
   When you create a submenu, you can add another &quot;.number&quot; to the priority.
Thus each name in <span class="highlight"><i>{menu-item}</i><span> has its priority number.


SPECIAL CHARACTERS

The <span class="highlight"><i>{menu-item}</i></font></span> in this example is &quot;&amp;File.&amp;Save<span class="highlight"><i>&lt;Tab&gt;</i><span>:w&quot;. This brings up an
important point: <span class="highlight"><i>{menu-item}</i><span> must be one word.  If you want to put a dot,
space or tabs in the name, you either use the &lt;&gt; notation (<span class="highlight"><i>&lt;space&gt;</i></font></span> and <span class="highlight"><i>&lt;tab&gt;</i><span>,
for instance) or use the backslash (\) escape.<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :menu 10.305 &amp;File.&amp;Do\ It\.\.\. :exit&lt;CR&gt;</b><span>

In this example, the name of the menu item &quot;Do It...&quot; contains a space and the
command is &quot;:exit<span class="highlight"><i>&lt;CR&gt;</i><span>&quot;.

The <span class="highlight"><i>&lt;Tab&gt;</i><span> character in a menu name is used to separate the part that defines
the menu name from the part that gives a hint to the user.  The part after the
<span class="highlight"><i>&lt;Tab&gt;</i><span> is displayed right aligned in the menu.  In the File.Save menu the name
used is &quot;&amp;File.&amp;Save<span class="highlight"><i>&lt;Tab&gt;</i><span>:w&quot;.  Thus the menu name is &quot;File.Save&quot; and the hint
is &quot;:w&quot;.


SEPARATORS

The separator lines, used to group related menu items together, can be defined
by using a name that starts and ends in a '-'.  For example &quot;-sep-&quot;.  When
using several separators the names must be different.  Otherwise the names
don't matter.
   The command from a separator will never be executed, but you have to define
one anyway.  A single colon will do.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :amenu 20.510 Edit.-sep3- :</b><span>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*42.2*</i></b><span>  Menu commands

You can define menu items that exist for only certain modes.  This works just
like the variations on the &quot;:map&quot; command:

        :menu           Normal, Visual and Operator-pending mode
        :nmenu          Normal mode
        :vmenu          Visual mode
        :omenu          Operator-pending mode
        :menu!          Insert and Command-line mode
        :imenu          Insert mode
        :cmenu          Command-line mode
        :amenu          All modes

To avoid that the commands of a menu item are being mapped, use the command
&quot;:noremenu&quot;, &quot;:nnoremenu&quot;, &quot;anoremenu&quot;, etc.


USING :AMENU

The &quot;:amenu&quot; command is a bit different.  It assumes that the <span class="highlight"><i>{keys}</i><span> you
give are to be executed in Normal mode.  When Vim is in Visual or Insert mode
when the menu is used, Vim first has to go back to Normal mode.  &quot;:amenu&quot;
inserts a <span class="highlight"><i>CTRL-C</i></font></span> or <span class="highlight"><i>CTRL-O</i><span> for you.  For example, if you use this command:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        :amenu  90.100 Mine.Find\ Word  *</b><span>

Then the resulting menu commands will be:

        Normal mode:            *
        Visual mode:            <span class="highlight"><i>CTRL-C</i><span> *
        Operator-pending mode:  <span class="highlight"><i>CTRL-C</i><span> *
        Insert mode:            <span class="highlight"><i>CTRL-O</i><span> *
        Command-line mode:      <span class="highlight"><i>CTRL-C</i><span> *

When in Command-line mode the <span class="highlight"><i>CTRL-C</i><span> will abandon the command typed so far.
In Visual and Operator-pending mode <span class="highlight"><i>CTRL-C</i></font></span> will stop the mode.  The <span class="highlight"><i>CTRL-O</i><span> in
Insert mode will execute the command and then return to Insert mode.
   <span class="highlight"><i>CTRL-O</i><span> only works for one command.  If you need to use two or more
commands, put them in a function and call that function.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :amenu  Mine.Next\ File  :call &lt;SID&gt;NextFile()&lt;CR&gt;</b><span>
<span class="highlight"><b>        :function &lt;SID&gt;NextFile()</b><span>
<span class="highlight"><b>        :  next</b><span>
<span class="highlight"><b>        :  1/^Code</b><span>
<span class="highlight"><b>        :endfunction</b><span>

This menu entry goes to the next file in the argument list with &quot;:next&quot;.  Then
it searches for the line that starts with &quot;Code&quot;.
   The <span class="highlight"><i>&lt;SID&gt;</i><span> before the function name is the script ID.  This makes the
function local to the current Vim script file.  This avoids problems when a
function with the same name is defined in another script file.  See <span class="highlight"><i>|&lt;SID&gt;|</i><span>.


SILENT MENUS

The menu executes the <span class="highlight"><i>{keys}</i><span> as if you typed them.  For a &quot;:&quot; command this
means you will see the command being echoed on the command line.  If it's a
long command, the hit-Enter prompt will appear.  That can be very annoying!
   To avoid this, make the menu silent.  This is done with the <span class="highlight"><i>&lt;silent&gt;</i><span>
argument.  For example, take the call to NextFile() in the previous example.
When you use this menu, you will see this on the command line:

<span class="highlight"><b>        :call &lt;SNR&gt;34_NextFile() </b><span><font color="#e5e5e5">~</font>

To avoid this text on the command line, insert &quot;<span class="highlight"><i>&lt;silent&gt;</i><span>&quot; as the first
argument:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :amenu &lt;silent&gt; Mine.Next\ File :call &lt;SID&gt;NextFile()&lt;CR&gt;</b><span>

Don't use &quot;<span class="highlight"><i>&lt;silent&gt;</i><span>&quot; too often.  It is not needed for short commands.  If you
make a menu for someone else, being able the see the executed command will
give him a hint about what he could have typed, instead of using the mouse.


LISTING MENUS

When a menu command is used without a <span class="highlight"><i>{keys}</i><span> part, it lists the already
defined menus.  You can specify a <span class="highlight"><i>{menu-item}</i><span>, or part of it, to list specific
menus.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :amenu</b><span>

This lists all menus.  That's a long list!  Better specify the name of a menu
to get a shorter list:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :amenu Edit</b><span>

This lists only the &quot;Edit&quot; menu items for all modes.  To list only one
specific menu item for Insert mode:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :imenu Edit.Undo</b><span>

Take care that you type exactly the right name.  Case matters here.  But the
'&amp;' for accelerators can be omitted.  The <span class="highlight"><i>&lt;Tab&gt;</i><span> and what comes after it can be
left out as well.


DELETING MENUS

To delete a menu, the same command is used as for listing, but with &quot;menu&quot;
changed to &quot;unmenu&quot;.  Thus &quot;:menu&quot; becomes, &quot;:unmenu&quot;, &quot;:nmenu&quot; becomes
&quot;:nunmenu&quot;, etc.  To delete the &quot;Tools.Make&quot; item for Insert mode:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :iunmenu Tools.Make</b><span>

You can delete a whole menu, with all its items, by using the menu name.
Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :aunmenu Syntax</b><span>

This deletes the Syntax menu and all the items in it.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*42.3*</i></b><span>  Various

You can change the appearance of the menus with flags in <span class="highlight"><i>'guioptions'</i><span>.  In the
default value they are all included.  You can remove a flag with a command
like:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set guioptions-=m</b><span>
<font color="#e5e5e5">&lt;</font>
        m               When removed the menubar is not displayed.

        M               When removed the default menus are not loaded.

        g               When removed the inactive menu items are not made grey
                        but are completely removed.  (Does not work on all
                        systems.)

        t               When removed the tearoff feature is not enabled.

The dotted line at the top of a menu is not a separator line.  When you select
this item, the menu is &quot;teared-off&quot;: It is displayed in a separate window.
This is called a tearoff menu.  This is useful when you use the same menu
often.

For translating menu items, see <span class="highlight"><i>|:menutrans|</i><span>.

Since the mouse has to be used to select a menu item, it is a good idea to use
the &quot;:browse&quot; command for selecting a file.  And &quot;:confirm&quot; to get a dialog
instead of an error message, e.g., when the current buffer contains changes.
These two can be combined:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :amenu File.Open  :browse confirm edit&lt;CR&gt;</b><span>

The &quot;:browse&quot; makes a file browser appear to select the file to edit.  The
&quot;:confirm&quot; will pop up a dialog when the current buffer has changes.  You can
then select to save the changes, throw them away or cancel the command.
   For more complicated items, the confirm() and inputdialog() functions can
be used.  The default menus contain a few examples.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*42.4*</i></b><span>  Toolbar and popup menus

There are two special menus: ToolBar and PopUp.  Items that start with these
names do not appear in the normal menu bar.


TOOLBAR

The toolbar appears only when the &quot;T&quot; flag is included in the <span class="highlight"><i>'guioptions'</i><span>
option.
   The toolbar uses icons rather than text to represent the command.  For
example, the <span class="highlight"><i>{menu-item}</i><span> named &quot;ToolBar.New&quot; causes the &quot;New&quot; icon to appear
on the toolbar.
   The Vim editor has 28 built-in icons.  You can find a table here:
<span class="highlight"><i>|builtin-tools|</i><span>.  Most of them are used in the default toolbar.  You can
redefine what these items do (after the default menus are setup).
   You can add another bitmap for a toolbar item.  Or define a new toolbar
item with a bitmap.  For example, define a new toolbar item with:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :tmenu ToolBar.Compile  Compile the current file</b><span>
<span class="highlight"><b>        :amenu ToolBar.Compile  :!cc % -o %:r&lt;CR&gt;</b><span>

Now you need to create the icon.  For MS-Windows it must be in bitmap format,
with the name &quot;Compile.bmp&quot;.  For Unix XPM format is used, the file name is
&quot;Compile.xpm&quot;.  The size must be 18 by 18 pixels.  On MS-Windows other sizes
can be used as well, but it will look ugly.
   Put the bitmap in the directory &quot;bitmaps&quot; in one of the directories from
<span class="highlight"><i>'runtimepath'</i><span>.  E.g., for Unix &quot;~/.vim/bitmaps/Compile.xpm&quot;.

You can define tooltips for the items in the toolbar.  A tooltip is a short
text that explains what a toolbar item will do.  For example &quot;Open file&quot;.  It
appears when the mouse pointer is on the item, without moving for a moment.
This is very useful if the meaning of the picture isn't that obvious.
Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :tmenu ToolBar.Make  Run make in the current directory</b><span>
<font color="#e5e5e5">&lt;</font>
        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        Pay attention to the case used.  &quot;Toolbar&quot; and &quot;toolbar&quot; are different
        from &quot;ToolBar&quot;!

To remove a tooltip, use the <span class="highlight"><i>|:tunmenu|</i><span> command.

The <span class="highlight"><i>'toolbar'</i><span> option can be used to display text instead of a bitmap, or both
text and a bitmap.  Most people use just the bitmap, since the text takes
quite a bit of space.


POPUP MENU

The popup menu pops up where the mouse pointer is.  On MS-Windows you activate
it by clicking the right mouse button.  Then you can select an item with the
left mouse button.  On Unix the popup menu is used by pressing and holding the
right mouse button.
   The popup menu only appears when the <span class="highlight"><i>'mousemodel'</i><span> has been set to &quot;popup&quot;
or &quot;popup_setpos&quot;.  The difference between the two is that &quot;popup_setpos&quot;
moves the cursor to the mouse pointer position.  When clicking inside a
selection, the selection will be used unmodified.  When there is a selection
but you click outside of it, the selection is removed.
   There is a separate popup menu for each mode.  Thus there are never grey
items like in the normal menus.

What is the meaning of life, the universe and everything?  <span class="highlight"><b><i>*42*</i></b><span>
Douglas Adams, the only person who knew what this question really was about is
now dead, unfortunately.  So now you might wonder what the meaning of death
is...

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_43.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2001 Sep 03


                               Using filetypes


When you are editing a file of a certain type, for example a C program or a
shell script, you often use the same option settings and mappings.  You
quickly get tired of manually setting these each time.  This chapter explains
how to do it automatically.

<span class="highlight"><i>|43.1|</i><span>  Plugins for a filetype
<span class="highlight"><i>|43.2|</i><span>  Adding a filetype


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*43.1*</i></b></font></span>  Plugins for a filetype                          <span class="highlight"><b><i>*filetype-plugin*</i></b><span>

How to start using filetype plugins has already been discussed here:
<span class="highlight"><i>|add-filetype-plugin|</i><span>.  But you probably are not satisfied with the default
settings, because they have been kept minimal.  Suppose that for C files you
want to set the <span class="highlight"><i>'softtabstop'</i><span> option to 4 and define a mapping to insert a
three-line comment.  You do this with only two steps:

<span class="highlight"><b>                                                        </b></font></span><span class="highlight"><b><i>*your-runtime-dir*</i></b><span>
1. Create your own runtime directory.  On Unix this usually is &quot;~/.vim&quot;.  In
   this directory create the &quot;ftplugin&quot; directory:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        mkdir ~/.vim</b><span>
<span class="highlight"><b>        mkdir ~/.vim/ftplugin</b><span>
<font color="#e5e5e5">&lt;</font>
   When you are not on Unix, check the value of the <span class="highlight"><i>'runtimepath'</i><span> option to
   see where Vim will look for the &quot;ftplugin&quot; directory:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        set runtimepath</b><span>

<font color="#e5e5e5">&lt;</font>  You would normally use the first directory name (before the first comma).
   You might want to prepend a directory name to the <span class="highlight"><i>'runtimepath'</i><span> option in
   your <span class="highlight"><i>|vimrc|</i><span> file if you don't like the default value.

2. Create the file &quot;~/.vim/ftplugin/c.vim&quot;, with the contents:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        setlocal softtabstop=4</b><span>
<span class="highlight"><b>        noremap &lt;buffer&gt; &lt;LocalLeader&gt;c o/**************&lt;CR&gt;&lt;CR&gt;/&lt;Esc&gt;</b><span>

Try editing a C file.  You should notice that the <span class="highlight"><i>'softtabstop'</i><span> option is set
to 4.  But when you edit another file it's reset to the default zero.  That is
because the &quot;:setlocal&quot; command was used.  This sets the <span class="highlight"><i>'softtabstop'</i><span> option
only locally to the buffer.  As soon as you edit another buffer, it will be
set to the value set for that buffer.  For a new buffer it will get the
default value or the value from the last &quot;:set&quot; command.

Likewise, the mapping for &quot;\c&quot; will disappear when editing another buffer.
The &quot;:map <span class="highlight"><i>&lt;buffer&gt;</i><span>&quot; command creates a mapping that is local to the current
buffer.  This works with any mapping command: &quot;:map!&quot;, &quot;:vmap&quot;, etc.  The
<span class="highlight"><i>|&lt;LocalLeader&gt;|</i><span> in the mapping is replaced with the value of &quot;maplocalleader&quot;.

You can find examples for filetype plugins in this directory:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        $VIMRUNTIME/ftplugin/</b><span>

More details about writing a filetype plugin can be found here:
<span class="highlight"><i>|write-plugin|</i><span>.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*43.2*</i></b><span>  Adding a filetype

If you are using a type of file that is not recognized by Vim, this is how to
get it recognized.  You need a runtime directory of your own.  See
<span class="highlight"><i>|your-runtime-dir|</i><span> above.

Create a file &quot;filetype.vim&quot; which contains an autocommand for your filetype.
(Autocommands were explained in section <span class="highlight"><i>|40.3|</i><span>.)  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        augroup filetypedetect</b><span>
<span class="highlight"><b>        au BufNewFile,BufRead *.xyz     setf xyz</b><span>
<span class="highlight"><b>        augroup END</b><span>

This will recognize all files that end in &quot;.xyz&quot; as the &quot;xyz&quot; filetype.  The
&quot;:augroup&quot; commands put this autocommand in the &quot;filetypedetect&quot; group.  This
allows removing all autocommands for filetype detection when doing &quot;:filetype
off&quot;.  The &quot;setf&quot; command will set the <span class="highlight"><i>'filetype'</i><span> option to its argument,
unless it was set already.  This will make sure that <span class="highlight"><i>'filetype'</i><span> isn't set
twice.

You can use many different patterns to match the name of your file.  Directory
names can also be included.  See <span class="highlight"><i>|autocmd-patterns|</i><span>.  For example, the files
under &quot;/usr/share/scripts/&quot; are all &quot;ruby&quot; files, but don't have the expected
file name extension.  Adding this to the example above:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        augroup filetypedetect</b><span>
<span class="highlight"><b>        au BufNewFile,BufRead *.xyz                     setf xyz</b><span>
<span class="highlight"><b>        au BufNewFile,BufRead /usr/share/scripts/*      setf ruby</b><span>
<span class="highlight"><b>        augroup END</b><span>

However, if you now edit a file /usr/share/scripts/README.txt, this is not a
ruby file.  The danger of a pattern ending in &quot;*&quot; is that it quickly matches
too many files.  To avoid trouble with this, put the filetype.vim file in
another directory, one that is at the end of <span class="highlight"><i>'runtimepath'</i><span>.  For Unix for
example, you could use &quot;~/.vim/after/filetype.vim&quot;.
   You now put the detection of text files in ~/.vim/filetype.vim:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        augroup filetypedetect</b><span>
<span class="highlight"><b>        au BufNewFile,BufRead *.txt                     setf text</b><span>
<span class="highlight"><b>        augroup END</b><span>

That file is found in <span class="highlight"><i>'runtimepath'</i><span> first.  Then use this in
~/.vim/after/filetype.vim, which is found last:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        augroup filetypedetect</b><span>
<span class="highlight"><b>        au BufNewFile,BufRead /usr/share/scripts/*      setf ruby</b><span>
<span class="highlight"><b>        augroup END</b><span>

What will happen now is that Vim searches for &quot;filetype.vim&quot; files in each
directory in <span class="highlight"><i>'runtimepath'</i><span>.  First ~/.vim/filetype.vim is found.  The
autocommand to catch *.txt files is defined there.  Then Vim finds the
filetype.vim file in $VIMRUNTIME, which is halfway <span class="highlight"><i>'runtimepath'</i><span>.  Finally
~/.vim/after/filetype.vim is found and the autocommand for detecting ruby
files in /usr/share/scripts is added.
   When you now edit /usr/share/scripts/README.txt, the autocommands are
checked in the order in which they were defined.  The *.txt pattern matches,
thus &quot;setf text&quot; is executed to set the filetype to &quot;text&quot;.  The pattern for
ruby matches too, and the &quot;setf ruby&quot; is executed.  But since <span class="highlight"><i>'filetype'</i><span> was
already set to &quot;text&quot;, nothing happens here.
   When you edit the file /usr/share/scripts/foobar the same autocommands are
checked.  Only the one for ruby matches and &quot;setf ruby&quot; sets <span class="highlight"><i>'filetype'</i><span> to
ruby.


RECOGNIZING BY CONTENTS

If your file cannot be recognized by its file name, you might be able to
recognize it by its contents.  For example, many script files start with a
line like:

<span class="highlight"><b>        #!/bin/xyz </b><span><font color="#e5e5e5">~</font>

To recognize this script create a file &quot;scripts.vim&quot; in your runtime directory
(same place where filetype.vim goes).  It might look like this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        if did_filetype()</b><span>
<span class="highlight"><b>          finish</b><span>
<span class="highlight"><b>        endif</b><span>
<span class="highlight"><b>        if getline(1) =~ '^#!.*[/\\]xyz\&gt;'</b><span>
<span class="highlight"><b>          setf xyz</b><span>
<span class="highlight"><b>        endif</b><span>

The first check with did_filetype() is to avoid that you will check the
contents of files for which the filetype was already detected by the file
name.  That avoids wasting time on checking the file when the &quot;setf&quot; command
won't do anything.
   The scripts.vim file is sourced by an autocommand in the default
filetype.vim file.  Therefore, the order of checks is:

        1. filetype.vim files before $VIMRUNTIME in <span class="highlight"><i>'runtimepath'</i><span>
        2. first part of $VIMRUNTIME/filetype.vim
        3. all script.vim files in <span class="highlight"><i>'runtimepath'</i><span>
        4. remainder of $VIMRUNTIME/filetype.vim
        5. filetype.vim files after $VIMRUNTIME in <span class="highlight"><i>'runtimepath'</i><span>

If this is not sufficient for you, add an autocommand that matches all files
and sources a script or executes a function to check the contents of the file.

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_44.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2001 Dec 22


                         Your own syntax highlighted


Vim comes with highlighting for a couple of hundred different file types.  If
the file you are editing isn't included, read this chapter to find out how to
get this type of file highlighted.  Also see <span class="highlight"><i>|:syn-define|</i><span> in the reference
manual.

<span class="highlight"><i>|44.1|</i><span>  Basic syntax commands
<span class="highlight"><i>|44.2|</i><span>  Keywords
<span class="highlight"><i>|44.3|</i><span>  Matches
<span class="highlight"><i>|44.4|</i><span>  Regions
<span class="highlight"><i>|44.5|</i><span>  Nested items
<span class="highlight"><i>|44.6|</i><span>  Following groups
<span class="highlight"><i>|44.7|</i><span>  Other arguments
<span class="highlight"><i>|44.8|</i><span>  Clusters
<span class="highlight"><i>|44.9|</i><span>  Including another syntax file
<span class="highlight"><i>|44.10|</i><span> Synchronizing
<span class="highlight"><i>|44.11|</i><span> Installing a syntax file
<span class="highlight"><i>|44.12|</i><span> Portable syntax file layout


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*44.1*</i></b><span>  Basic syntax commands

Using an existing syntax file to start with will save you a lot of time.  Try
finding a syntax file in $VIMRUNTIME/syntax for a language that is similar.
These files will also show you the normal layout of a syntax file.  To
understand it, you need to read the following.

Let's start with the basic arguments.  Before we start defining any new
syntax, we need to clear out any old definitions:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax clear</b><span>

This isn't required in the final syntax file, but very useful when
experimenting.

There are more simplifications in this chapter.  If you are writing a syntax
file to be used by others, read all the way through the end to find out the
details.


LISTING DEFINED ITEMS

To check which syntax items are currently defined, use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax</b><span>

You can use this to check which items have actually been defined.  Quite
useful when you are experimenting with a new syntax file.  It also shows the
colors used for each item, which helps to find out what is what.
   To list the items in a specific syntax group use:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax list {group-name}</b><span>

This also can be used to list clusters (explained in <span class="highlight"><i>|44.8|</i><span>).  Just include
the @ in the name.


MATCHING CASE

   Some languages are not case sensitive, such as Pascal.  Others, such as C,
are case sensitive.  You need to tell which type you have with the following
commands:<font color="#e5e5e5"> &gt;</font>
<span class="highlight"><b>        :syntax case match</b><span>
<span class="highlight"><b>        :syntax case ignore</b><span>

The &quot;match&quot; argument means that Vim will match the case of syntax elements.
Therefore, &quot;int&quot; differs from &quot;Int&quot; and &quot;INT&quot;.  If the &quot;ignore&quot; argument is
used, the following are equivalent: &quot;Procedure&quot;, &quot;PROCEDURE&quot; and &quot;procedure&quot;.
   The :syntax case commands can appear anywhere in a syntax file and affect
the syntax definitions that follow.  In most cases, you have only one :syntax
case command in your syntax file; if you work with an unusual language that
contains both case-sensitive and non-case-sensitive elements, however, you can
scatter the :syntax case command throughout the file.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*44.2*</i></b><span>  Keywords

The most basic syntax elements are keywords.  To define a keyword, use the
following form:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax keyword {group} {keyword} ...</b><span>

The <span class="highlight"><i>{group}</i><span> is the name of a syntax group.  With the &quot;:highlight&quot; command you
can assign colors to a <span class="highlight"><i>{group}</i></font></span>.  The <span class="highlight"><i>{keyword}</i><span> argument is an actual keyword.
Here are a few examples:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax keyword xType int long char</b><span>
<span class="highlight"><b>        :syntax keyword xStatement if then else endif</b><span>

This example uses the group names &quot;xType&quot; and &quot;xStatement&quot;.  By convention,
each group name is prefixed by the filetype for the language being defined.
This example defines syntax for the x language (eXample language without an
interesting name).  In a syntax file for &quot;csh&quot; scripts the name &quot;cshType&quot;
would be used.  Thus the prefix is equal to the value of <span class="highlight"><i>'filetype'</i><span>.
   These commands cause the words &quot;int&quot;, &quot;long&quot; and &quot;char&quot; to be highlighted
one way and the words &quot;if&quot;, &quot;then&quot;, &quot;else&quot; and &quot;endif&quot; to be highlighted
another way.  Now you need to connect the x group names to standard Vim
names.  You do this with the following commands:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :highlight link xType Type</b><span>
<span class="highlight"><b>        :highlight link xStatement Statement</b><span>

This tells Vim to highlight &quot;xType&quot; like &quot;Type&quot; and &quot;xStatement&quot; like
&quot;Statement&quot;.  See <span class="highlight"><i>|group-name|</i><span> for the standard names.


UNUSUAL KEYWORDS

The characters used in a keyword must be in the <span class="highlight"><i>'iskeyword'</i><span> option.  If you
use another character, the word will never match.  Vim doesn't give a warning
message for this.
   The x language uses the '-' character in keywords.  This is how it's done:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        :setlocal iskeyword+=-</b><span>
<span class="highlight"><b>        :syntax keyword xStatement when-not</b><span>

The &quot;:setlocal&quot; command is used to change <span class="highlight"><i>'iskeyword'</i><span> only for the current
buffer.  Still it does change the behavior of commands like &quot;w&quot; and &quot;*&quot;.  If
that is not wanted, don't define a keyword but use a match (explained in the
next section).

The x language allows for abbreviations.  For example, &quot;next&quot; can be
abbreviated to &quot;n&quot;, &quot;ne&quot; or &quot;nex&quot;.  You can define them by using this command:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        :syntax keyword xStatement n[ext]</b><span>

This doesn't match &quot;nextone&quot;, keywords always match whole words only.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*44.3*</i></b><span>  Matches

Consider defining something a bit more complex.  You want to match ordinary
identifiers.  To do this, you define a match syntax item.  This one matches
any word consisting of only lowercase letters:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax match xIdentifier /\&lt;\l\+\&gt;/</b><span>
<font color="#e5e5e5">&lt;</font>
        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        Keywords overrule any other syntax item.  Thus the keywords &quot;if&quot;,
        &quot;then&quot;, etc., will be keywords, as defined with the &quot;:syntax keyword&quot;
        commands above, even though they also match the pattern for
        xIdentifier.

The part at the end is a pattern, like it's used for searching.  The // is
used to surround the pattern (like how it's done in a &quot;:substitute&quot; command).
You can use any other character, like a plus or a quote.

Now define a match for a comment.  In the x language it is anything from # to
the end of a line:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax match xComment /#.*/</b><span>

Since you can use any search pattern, you can highlight very complex things
with a match item.  See <span class="highlight"><i>|pattern|</i><span> for help on search patterns.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*44.4*</i></b><span>  Regions

In the example x language, strings are enclosed in double quotation marks (&quot;).
To highlight strings you define a region.  You need a region start (double
quote) and a region end (double quote).  The definition is as follows:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax region xString start=/&quot;/ end=/&quot;/</b><span>

The &quot;start&quot; and &quot;end&quot; directives define the patterns used to find the start
and end of the region.  But what about strings that look like this?

<span class="highlight"><b>        &quot;A string with a double quote (\&quot;) in it&quot; </b><span><font color="#e5e5e5">~</font>

This creates a problem: The double quotation marks in the middle of the string
will end the region.  You need to tell Vim to skip over any escaped double
quotes in the string.  Do this with the skip keyword:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax region xString start=/&quot;/ skip=/\\&quot;/ end=/&quot;/</b><span>

The double backslash matches a single backslash, since the backslash is a
special character in search patterns.

When to use a region instead of a match?  The main difference is that a match
item is a single pattern, which must match as a whole.  A region starts as
soon as the &quot;start&quot; pattern matches.  Whether the &quot;end&quot; pattern is found or
not doesn't matter.  Thus when the item depends on the &quot;end&quot; pattern to match,
you cannot use a region.  Otherwise, regions are often simpler to define.  And
it is easier to use nested items, as is explained in the next section.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*44.5*</i></b><span>  Nested items

Take a look at this comment:

<span class="highlight"><b>        %Get input  TODO: Skip white space </b><span><font color="#e5e5e5">~</font>

You want to highlight TODO in big yellow letters, even though it is in a
comment that is highlighted blue.  To let Vim know about this, you define the
following syntax groups:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax keyword xTodo TODO contained</b><span>
<span class="highlight"><b>        :syntax match xComment /%.*/ contains=xTodo</b><span>

In the first line, the &quot;contained&quot; argument tells Vim that this keyword can
exist only inside another syntax item.  The next line has &quot;contains=xTodo&quot;.
This indicates that the xTodo syntax element is inside it.  The result is that
the comment line as a whole is matched with &quot;xComment&quot; and made blue.  The
word TODO inside it is matched by xTodo and highlighted yellow (highlighting
for xTodo was setup for this).


RECURSIVE NESTING

The x language defines code blocks in curly braces.  And a code block may
contain other code blocks.  This can be defined this way:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax region xBlock start=/{/ end=/}/ contains=xBlock</b><span>

Suppose you have this text:

<span class="highlight"><b>        while i &lt; b { </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                if a { </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                        b = c; </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                } </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        } </b><span><font color="#e5e5e5">~</font>

First a xBlock starts at the { in the first line.  In the second line another
{ is found.  Since we are inside a xBlock item, and it contains itself, a
nested xBlock item will start here.  Thus the &quot;b = c&quot; line is inside the
second level xBlock region.  Then a } is found in the next line, which matches
with the end pattern of the region.  This ends the nested xBlock.  Because the
} is included in the nested region, it is hidden from the first xBlock region.
Then at the last } the first xBlock region ends.


KEEPING THE END

Consider the following two syntax items:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax region xComment start=/%/ end=/$/ contained</b><span>
<span class="highlight"><b>        :syntax region xPreProc start=/#/ end=/$/ contains=xComment</b><span>

You define a comment as anything from % to the end of the line.  A
preprocessor directive is anything from # to the end of the line.  Because you
can have a comment on a preprocessor line, the preprocessor definition
includes a &quot;contains=xComment&quot; argument.  Now look what happens with this
text:

<span class="highlight"><b>        #define X = Y  % Comment text </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        int foo = 1; </b><span><font color="#e5e5e5">~</font>

What you see is that the second line is also highlighted as xPreProc.  The
preprocessor directive should end at the end of the line.  That is why
you have used &quot;end=/$/&quot;.  So what is going wrong?
   The problem is the contained comment.  The comment starts with % and ends
at the end of the line.  After the comment ends, the preprocessor syntax
continues.  This is after the end of the line has been seen, so the next
line is included as well.
   To avoid this problem and to avoid a contained syntax item eating a needed
end of line, use the &quot;keepend&quot; argument.  This takes care of
the double end-of-line matching:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax region xComment start=/%/ end=/$/ contained</b><span>
<span class="highlight"><b>        :syntax region xPreProc start=/#/ end=/$/ contains=xComment keepend</b><span>


CONTAINING MANY ITEMS

You can use the contains argument to specify that everything can be contained.
For example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax region xList start=/\[/ end=/\]/ contains=ALL</b><span>

All syntax items will be contained in this one.  It also contains itself, but
not at the same position (that would cause an endless loop).
   You can specify that some groups are not contained.  Thus contain all
groups but the ones that are listed:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        :syntax region xList start=/\[/ end=/\]/ contains=ALLBUT,xString</b><span>

With the &quot;TOP&quot; item you can include all items that don't have a &quot;contained&quot;
argument.  &quot;CONTAINED&quot; is used to only include items with a &quot;contained&quot;
argument.  See <span class="highlight"><i>|:syn-contains|</i><span> for the details.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*44.6*</i></b><span>  Following groups

The x language has statements in this form:

<span class="highlight"><b>        if (condition) then </b><span><font color="#e5e5e5">~</font>

You want to highlight the three items differently.  But &quot;(condition)&quot; and
&quot;then&quot; might also appear in other places, where they get different
highlighting.  This is how you can do this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax match xIf /if/ nextgroup=xIfCondition skipwhite</b><span>
<span class="highlight"><b>        :syntax match xIfCondition /([^)]*)/ contained nextgroup=xThen skipwhite</b><span>
<span class="highlight"><b>        :syntax match xThen /then/ contained</b><span>

The &quot;nextgroup&quot; argument specifies which item can come next.  This is not
required.  If none of the items that are specified are found, nothing happens.
For example, in this text:

<span class="highlight"><b>        if not (condition) then </b><span><font color="#e5e5e5">~</font>

The &quot;if&quot; is matched by xIf.  &quot;not&quot; doesn't match the specified nextgroup
xIfCondition, thus only the &quot;if&quot; is highlighted.

The &quot;skipwhite&quot; argument tells Vim that white space (spaces and tabs) may
appear in between the items.  Similar arguments are &quot;skipnl&quot;, which allows a
line break in between the items, and &quot;skipempty&quot;, which allows empty lines.
Notice that &quot;skipnl&quot; doesn't skip an empty line, something must match after
the line break.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*44.7*</i></b><span>  Other arguments

MATCHGROUP

When you define a region, the entire region is highlighted according to the
group name specified.  To highlight the text enclosed in parentheses () with
the group xInside, for example, use the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax region xInside start=/(/ end=/)/</b><span>

Suppose, that you want to highlight the parentheses differently.  You can do
this with a lot of convoluted region statements, or you can use the
&quot;matchgroup&quot; argument.  This tells Vim to highlight the start and end of a
region with a different highlight group (in this case, the Xparen group):<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax region xInside matchgroup=xParen start=/(/ end=/)/</b><span>

The &quot;matchgroup&quot; argument applies to the start or end match that comes after
it.  In the previous example both start and end are highlighted with xParen.
To highlight the end with xParenEnd: &gt;<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax region xInside matchgroup=xParen start=/(/</b><span>
<span class="highlight"><b>                \ matchgroup=xParenEnd end=/)/</b><span>

A side effect of using &quot;matchgroup&quot; is that contained items will not match in
the start or end of the region.  The example for &quot;transparent&quot; uses this.


TRANSPARENT

In a C language file you would like to highlight the () text after a &quot;while&quot;
differently from the () text after a &quot;for&quot;.  In both of these there can be
nested () items, which should be highlighted in the same way.  You must make
sure the () highlighting stops at the matching ).  This is one way to do this:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        :syntax region cWhile matchgroup=cWhile start=/while\s*(/ end=/)/</b><span>
<span class="highlight"><b>                \ contains=cCondNest</b><span>
<span class="highlight"><b>        :syntax region cFor matchgroup=cFor start=/for\s*(/ end=/)/</b><span>
<span class="highlight"><b>                \ contains=cCondNest</b><span>
<span class="highlight"><b>        :syntax region cCondNest start=/(/ end=/)/ contained transparent</b><span>

Now you can give cWhile and cFor different highlighting.  The cCondNest item
can appear in either of them, but take over the highlighting of the item it is
contained in.  The &quot;transparent&quot; argument causes this.
   Notice that the &quot;matchgroup&quot; argument has the same group as the item
itself.  Why define it then?  Well, the side effect of using a matchgroup is
that contained items are not found in the match with the start item then.
This avoids that the cCondNest group matches the ( just after the &quot;while&quot; or
&quot;for&quot;.  If this would happen, it would span the whole text until the matching
) and the region would continue after it.  Now cCondNest only matches after
the match with the start pattern, thus after the first (.


OFFSETS

Suppose you want to define a region for the text between ( and ) after an
&quot;if&quot;.  But you don't want to include the &quot;if&quot; or the ( and ).  You can do this
by specifying offsets for the patterns.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax region xCond start=/if\s*(/ms=e+1 end=/)/me=s-1</b><span>

The offset for the start pattern is &quot;ms=e+1&quot;.  &quot;ms&quot; stands for Match Start.
This defines an offset for the start of the match.  Normally the match starts
where the pattern matches.  &quot;e+1&quot; means that the match now starts at the end
of the pattern match, and then one character further.
   The offset for the end pattern is &quot;me=s-1&quot;.  &quot;me&quot; stands for Match End.
&quot;s-1&quot; means the start of the pattern match and then one character back.  The
result is that in this text:

<span class="highlight"><b>        if (foo == bar) </b><span><font color="#e5e5e5">~</font>

Only the text &quot;foo == bar&quot; will be highlighted as xCond.

More about offsets here: <span class="highlight"><i>|:syn-pattern-offset|</i><span>.


ONELINE

The &quot;oneline&quot; argument indicates that the region does not cross a line
boundary.  For example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax region xIfThen start=/if/ end=/then/ oneline</b><span>

This defines a region that starts at &quot;if&quot; and ends at &quot;then&quot;.  But if there is
no &quot;then&quot; after the &quot;if&quot;, the region doesn't match.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        When using &quot;oneline&quot; the region doesn't start if the end pattern
        doesn't match in the same line.  Without &quot;oneline&quot; Vim does _not_
        check if there is a match for the end pattern.  The region starts even
        when the end pattern doesn't match in the rest of the file.


CONTINUATION LINES AND AVOIDING THEM

Things now become a little more complex.  Let's define a preprocessor line.
This starts with a # in the first column and continues until the end of the
line.  A line that ends with \ makes the next line a continuation line.  The
way you handle this is to allow the syntax item to contain a continuation
pattern:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax region xPreProc start=/^#/ end=/$/ contains=xLineContinue</b><span>
<span class="highlight"><b>        :syntax match xLineContinue &quot;\\$&quot; contained</b><span>

In this case, although xPreProc normally matches a single line, the group
contained in it (namely xLineContinue) lets it go on for more than one line.
For example, it would match both of these lines:

<span class="highlight"><b>        #define SPAM  spam spam spam \ </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                        bacon and spam </b><span><font color="#e5e5e5">~</font>

In this case, this is what you want.  If it is not what you want, you can call
for the region to be on a single line by adding &quot;excludenl&quot; to the contained
pattern.  For example, you want to highlight &quot;end&quot; in xPreProc, but only at
the end of the line.  To avoid making the xPreProc continue on the next line,
like xLineContinue does, use &quot;excludenl&quot; like this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax region xPreProc start=/^#/ end=/$/</b><span>
<span class="highlight"><b>                \ contains=xLineContinue,xPreProcEnd</b><span>
<span class="highlight"><b>        :syntax match xPreProcEnd excludenl /end$/ contained</b><span>
<span class="highlight"><b>        :syntax match xLineContinue &quot;\\$&quot; contained</b><span>

&quot;excludenl&quot; must be placed before the pattern.  Since &quot;xLineContinue&quot; doesn't
have &quot;excludenl&quot;, a match with it will extend xPreProc to the next line as
before.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*44.8*</i></b><span>  Clusters

One of the things you will notice as you start to write a syntax file is that
you wind up generating a lot of syntax groups.  Vim enables you to define a
collection of syntax groups called a cluster.
   Suppose you have a language that contains for loops, if statements, while
loops, and functions.  Each of them contains the same syntax elements: numbers
and identifiers.  You define them like this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax match xFor /^for.*/ contains=xNumber,xIdent</b><span>
<span class="highlight"><b>        :syntax match xIf /^if.*/ contains=xNumber,xIdent</b><span>
<span class="highlight"><b>        :syntax match xWhile /^while.*/ contains=xNumber,xIdent</b><span>

You have to repeat the same &quot;contains=&quot; every time.  If you want to add
another contained item, you have to add it three times.  Syntax clusters
simplify these definitions by enabling you to have one cluster stand for
several syntax groups.
   To define a cluster for the two items that the three groups contain, use
the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax cluster xState contains=xNumber,xIdent</b><span>

Clusters are used inside other :syntax items just like any syntax group.
Their names start with @.  Thus, you can define the three groups like this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax match xFor /^for.*/ contains=@xState</b><span>
<span class="highlight"><b>        :syntax match xIf /^if.*/ contains=@xState</b><span>
<span class="highlight"><b>        :syntax match xWhile /^while.*/ contains=@xState</b><span>

You can add new group names to this cluster with the add argument:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax cluster xState add=xString</b><span>

You can remove syntax groups from this list as well:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax cluster xState remove=xNumber</b><span>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*44.9*</i></b><span>  Including another syntax file

The C++ language syntax is a superset of the C language.  Because you do not
want to write two syntax files, you can have the C++ syntax file read in the
one for C by using the following command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :runtime! syntax/c.vim</b><span>

The &quot;:runtime!&quot; command searches <span class="highlight"><i>'runtimepath'</i><span> for all &quot;syntax/c.vim&quot; files.
This makes the C syntax be defined like for C files.  If you have replaced the
c.vim syntax file, or added items with an extra file, these will be loaded as
well.
   After loading the C syntax items the specific C++ items can be defined.
For example, add keywords that are not used in C:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax keyword cppStatement    new delete this friend using</b><span>

This works just like in any other syntax file.

Now consider the Perl language.  It consists of two distinct parts: a
documentation section in POD format, and a program written in Perl itself.
The POD section starts with &quot;=head&quot; and ends with &quot;=cut&quot;.
   You want to define the POD syntax in one file, and use it from the Perl
syntax file.  The &quot;:syntax include&quot; command reads in a syntax file and stores
the elements it defined in a syntax cluster.  For Perl, the statements are as
follows:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax include @Pod &lt;sfile&gt;:p:h/pod.vim</b><span>
<span class="highlight"><b>        :syntax region perlPOD start=/^=head/ end=/^=cut/ contains=@Pod</b><span>

When &quot;=head&quot; is found in a Perl file, the perlPOD region starts.  In this
region the @Pod cluster is contained.  All the items defined as top-level
items in the pod.vim syntax files will match here.  When &quot;=cut&quot; is found, the
region ends and we go back to the items defined in the Perl file.
   The &quot;:syntax include&quot; file is clever enough to ignore a &quot;:syntax clear&quot;
command in the included file.  And an argument like &quot;contains=ALL&quot; will only
contain items defined in the included file, not in the file that includes it.
   The &quot;<span class="highlight"><i>&lt;sfile&gt;</i></font></span>:p:h/&quot; part uses the name of the current file (<span class="highlight"><i>&lt;sfile&gt;</i><span>),
expands it to a full path (:p) and then takes the head (:h).  This results in
the directory name of the file.  This causes the pod.vim file in the same
directory to be included.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*44.10*</i></b><span> Synchronizing

Compilers have it easy.  They start at the beginning of a file and parse it
straight through.  Vim does not have it so easy.  It must start in the middle,
where the editing is being done.  So how does it tell where it is?
   The secret is the &quot;:syntax sync&quot; command.  This tells Vim how to figure out
where it is.  For example, the following command tells Vim to scan backward
for the beginning or end of a C-style comment and begin syntax coloring from
there:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax sync ccomment</b><span>

You can tune this processing with some arguments.  The &quot;minlines&quot; argument
tells Vim the minimum number of lines to look backward, and &quot;maxlines&quot; tells
the editor the maximum number of lines to scan.
   For example, the following command tells Vim to look at least 10 lines
before the top of the screen:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax sync ccomment minlines=10 maxlines=500</b><span>

If it cannot figure out where it is in that space, it starts looking farther
and farther back until it figures out what to do.  But it looks no farther
back than 500 lines. (A large &quot;maxlines&quot; slows down processing.  A small one
might cause synchronization to fail.)
   To make synchronizing go a bit faster, tell Vim which syntax items can be
skipped.  Every match and region that only needs to be used when actually
displaying text can be given the &quot;display&quot; argument.
   By default, the comment to be found will be colored as part of the Comment
syntax group.  If you want to color things another way, you can specify a
different syntax group:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax sync ccomment xAltComment</b><span>

If your programming language does not have C-style comments in it, you can try
another method of synchronization.  The simplest way is to tell Vim to space
back a number of lines and try to figure out things from there.  The following
command tells Vim to go back 150 lines and start parsing from there:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax sync minlines=150</b><span>

A large &quot;minlines&quot; value can make Vim slower, especially when scrolling
backwards in the file.
   Finally, you can specify a syntax group to look for by using this command:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        :syntax sync match {sync-group-name}</b><span>
<span class="highlight"><b>                \ grouphere {group-name} {pattern}</b><span>

This tells Vim that when it sees <span class="highlight"><i>{pattern}</i></font></span> the syntax group named <span class="highlight"><i>{group-name}</i><span>
begins just after the pattern given.  The <span class="highlight"><i>{sync-group-name}</i><span> is used to give a
name to this synchronization specification.  For example, the sh scripting
language begins an if statement with &quot;if&quot; and ends it with &quot;fi&quot;:

<span class="highlight"><b>        if [ --f file.txt ] ; then </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>                echo &quot;File exists&quot; </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        fi </b><span><font color="#e5e5e5">~</font>

To define a &quot;grouphere&quot; directive for this syntax, you use the following
command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax sync match shIfSync grouphere shIf &quot;\&lt;if\&gt;&quot;</b><span>

The &quot;groupthere&quot; argument tells Vim that the pattern ends a group.  For
example, the end of the if/fi group is as follows:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax sync match shIfSync groupthere NONE &quot;\&lt;fi\&gt;&quot;</b><span>

In this example, the NONE tells Vim that you are not in any special syntax
region.  In particular, you are not inside an if block.

You also can define matches and regions that are with no &quot;grouphere&quot; or
&quot;groupthere&quot; arguments.  These groups are for syntax groups skipped during
synchronization.  For example, the following skips over anything inside {},
even if it would normally match another synchronization method:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :syntax sync match xSpecial /{.*}/</b><span>

More about synchronizing in the reference manual: <span class="highlight"><i>|:syn-sync|</i><span>.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*44.11*</i></b><span> Installing a syntax file

When your new syntax file is ready to be used, drop it in a &quot;syntax&quot; directory
in <span class="highlight"><i>'runtimepath'</i><span>.  For Unix that would be &quot;~/.vim/syntax&quot;.
  The name of the syntax file must be equal to the file type, with &quot;.vim&quot;
added.  Thus for the x language, the full path of the file would be:

<span class="highlight"><b>        ~/.vim/syntax/x.vim </b><span><font color="#e5e5e5">~</font>

You must also make the file type be recognized.  See <span class="highlight"><i>|43.2|</i><span>.

If your file works well, you migth want to make it available to other Vim
users.  First read the next section to make sure your file works well for
others.  Then e-mail it to the Vim maintainer: &lt;maintainer@vim.org&gt;.  Also
explain how the filetype can be detected.  With a bit of luck your file will
be included in the next Vim version!


ADDING TO AN EXISTING SYNTAX FILE

We were assuming you were adding a completely new syntax file.  When an existing
syntax file works, but is missing some items, you can add items in a separate
file.  That avoids changing the distributed syntax file, which will be lost
when installing a new version of Vim.
   Write syntax commands in your file, possibly using group names from the
existing syntax.  For example, to add new variable types to the C syntax file:
<font color="#e5e5e5">&gt;</font>
<span class="highlight"><b>        :syntax keyword cType off_t uint</b><span>

Write the file with the same name as the original syntax file.  In this case
&quot;c.vim&quot;.  Place it in a directory near the end of <span class="highlight"><i>'runtimepath'</i><span>.  This makes
it loaded after the original syntax file.  For Unix this would be:

<span class="highlight"><b>        ~/.vim/after/syntax/c.vim </b><span><font color="#e5e5e5">~</font>

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*44.12*</i></b><span> Portable syntax file layout

Wouldn't it be nice if all Vim users exchange syntax files?  To make this
possible, the syntax file must follow a few guidelines.

Start with a header that explains what the syntax file is for, who maintains
it and when it was last updated.  Don't include too much information about
changes history, not many people will read it.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        &quot; Vim syntax file</b><span>
<span class="highlight"><b>        &quot; Language:     C</b><span>
<span class="highlight"><b>        &quot; Maintainer:   Bram Moolenaar &lt;Bram@vim.org&gt;</b><span>
<span class="highlight"><b>        &quot; Last Change:  2001 Jun 18</b><span>
<span class="highlight"><b>        &quot; Remark:       Included by the C++ syntax.</b><span>

Use the same layout as the other syntax files.  Using an existing syntax file
as an example will save you a lot of time.

Choose a good, descriptive name for your syntax file.  Use lowercase letters
and digits.  Don't make it too long, it is used in many places: The name of
the syntax file &quot;name.vim&quot;, <span class="highlight"><i>'filetype'</i><span>, b:current_syntax the start of each
syntax group (nameType, nameStatement, nameString, etc).

Start with a check for &quot;b:current_syntax&quot;.  If it is defined, some other
syntax file, earlier in <span class="highlight"><i>'runtimepath'</i><span> was already loaded.  To be compatible
with Vim 5.8 use:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        if version &lt; 600</b><span>
<span class="highlight"><b>          syntax clear</b><span>
<span class="highlight"><b>        elseif exists(&quot;b:current_syntax&quot;)</b><span>
<span class="highlight"><b>          finish</b><span>
<span class="highlight"><b>        endif</b><span>

Set &quot;b:current_syntax&quot; to the name of the syntax at the end.  Don't forget
that included files do this too, you might have to reset &quot;b:current_syntax&quot; if
you include two files.

If you want your syntax file to work with Vim 5.x, add a check for v:version.
See yacc.vim for an example.

Do not include anything that is a user preference.  Don't set <span class="highlight"><i>'tabstop'</i><span>,
<span class="highlight"><i>'expandtab'</i><span>, etc.  These belong in a filetype plugin.

Do not include mappings or abbreviations.  Only include setting <span class="highlight"><i>'iskeyword'</i><span> if
it is really necessary for recognizing keywords.

Avoid using specific colors.  Link to the standard highlight groups whenever
possible.  Don't forget that some people use a different background color, or
have only eight colors available.
For backwards compatibility with Vim 5.8 this construction is used:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        if version &gt;= 508 || !exists(&quot;did_c_syn_inits&quot;)</b><span>
<span class="highlight"><b>          if version &lt; 508</b><span>
<span class="highlight"><b>            let did_c_syn_inits = 1</b><span>
<span class="highlight"><b>            command -nargs=+ HiLink hi link &lt;args&gt;</b><span>
<span class="highlight"><b>          else</b><span>
<span class="highlight"><b>            command -nargs=+ HiLink hi def link &lt;args&gt;</b><span>
<span class="highlight"><b>          endif</b><span>

<span class="highlight"><b>          HiLink nameString     String</b><span>
<span class="highlight"><b>          HiLink nameNumber     Number</b><span>
<span class="highlight"><b>          ... etc ...</b><span>

<span class="highlight"><b>          delcommand HiLink</b><span>
<span class="highlight"><b>        endif</b><span>

Add the &quot;display&quot; argument to items that are not used when syncing, to speed
up scrolling backwards and <span class="highlight"><i>CTRL-L</i><span>.

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_45.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2001 Sep 03


                             Select your language


The messages in Vim can be given in several languages.  This chapter explains
how to change which one is used.  Also, the different ways to work with files
in various languages is explained.

<span class="highlight"><i>|45.1|</i><span>  Language for Messages
<span class="highlight"><i>|45.2|</i><span>  Language for Menus
<span class="highlight"><i>|45.3|</i><span>  Using another encoding
<span class="highlight"><i>|45.4|</i><span>  Editing files with a different encoding
<span class="highlight"><i>|45.5|</i><span>  Entering language text


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*45.1*</i></b><span>  Language for Messages

When you start Vim, it checks the environment to find out what language you
are using.  Mostly this should work fine, and you get the messages in your
language (if they are available).  To see what the current language is, use
this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :language</b><span>

If it replies with &quot;C&quot;, this means the default is being used, which is
English.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        Using different languages only works when Vim was compiled to handle
        it.  To find out if it works, use the &quot;:version&quot; command and check the
        output for &quot;+gettext&quot; and &quot;+multi_lang&quot;.  If they are there, you are
        OK.  If you see &quot;-gettext&quot; or &quot;-multi_lang&quot; you will have to find
        another Vim.

What if you would like your messages in a different language?  There are
several ways.  Which one you should use depends on the capabilities of your
system.
   The first way is to set the environment to the desired language before
starting Vim.  Example for Unix:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        env LANG=de_DE.ISO_8859-1  vim</b><span>

This only works if the language is available on your system.  The advantage is
that all the GUI messages and things in libraries will use the right language
as well.  A disadvantage is that you must do this before starting Vim.  If you
want to change language while Vim is running, you can use the second method:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :language fr_FR.ISO_8859-1</b><span>

This way you can try out several names for your language.  You will get an
error message when it's not supported on your system.  You don't get an error
when translated messages are not available.  Vim will silently fall back to
using English.
   To find out which languages are supported on your system, find the
directory where they are listed.  On my system it is &quot;/usr/share/locale&quot;.  On
some systems it's in &quot;/usr/lib/locale&quot;.  The manual page for &quot;setlocale&quot;
should give you a hint where it is found on your system.
   Be careful to type the name exactly as it should be.  Upper and lowercase
matter, and the '-' and '_' characters are easily confused.

You can also set the language separately for messages, edited text and the
time format.  See <span class="highlight"><i>|:language|</i><span>.


DO-IT-YOURSELF MESSAGE TRANSLATION

If translated messages are not available for your language, you could write
them yourself.  To do this, get the source code for Vim and the GNU gettext
package.  After unpacking the sources, instructions can be found in the
directory src/po/README.txt.
   It's not too difficult to do the translation.  You don't need to be a
programmer.  You must know both English and the language you are translating
to, of course.
   When you are satisfied with the translation, consider making it available
to others.  Upload it at vim-online (http://vim.sf.net) or e-mail it to
the Vim maintainer &lt;maintainer@vim.org&gt;.  Or both.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*45.2*</i></b><span>  Language for Menus

The default menus are in English.  To be able to use your local language, they
must be translated.  Normally this is automatically done for you if the
environment is set for your language, just like with messages.  You don't need
to do anything extra for this.  But it only works if translations for the
language are available.
   Suppose you are in Germany, with the language set to German, but prefer to
use &quot;File&quot; instead of &quot;Datei&quot;.  You can switch back to using the English menus
this way:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set langmenu=none</b><span>

It is also possible to specify a language:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set langmenu=nl_NL.ISO_8859-1</b><span>

Like above, differences between &quot;-&quot; and &quot;_&quot; matter.  However, upper/lowercase
differences are ignored here.
   The <span class="highlight"><i>'langmenu'</i><span> option must be set before the menus are loaded.  Once the
menus have been defined changing <span class="highlight"><i>'langmenu'</i><span> has no direct effect.  Therefore,
put the command to set <span class="highlight"><i>'langmenu'</i><span> in your vimrc file.
   If you really want to switch menu language while running Vim, you can do it
this way:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :source $VIMRUNTIME/delmenu.vim</b><span>
<span class="highlight"><b>        :set langmenu=de_DE.ISO_8859-1</b><span>
<span class="highlight"><b>        :source $VIMRUNTIME/menu.vim</b><span>

There is one drawback: All menus that you defined yourself will be gone.  You
will need to redefine them as well.


DO-IT-YOURSELF MENU TRANSLATION

To see which menu translations are available, look in this directory:

<span class="highlight"><b>        $VIMRUNTIME/lang </b><span><font color="#e5e5e5">~</font>

The files are called menu_<span class="highlight"><i>{language}</i><span>.vim.  If you don't see the language you
want to use, you can do your own translations.  The simplest way to do this is
by copying one of the existing language files, and change it.
   First find out the name of your language with the &quot;:language&quot; command.  Use
this name, but with all letters made lowercase.  Then copy the file to your
own runtime directory, as found early in <span class="highlight"><i>'runtimepath'</i><span>.  For example, for Unix
you would do:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :!cp $VIMRUNTIME/lang/menu_ko_kr.euckr.vim ~/.vim/lang/menu_nl_be.iso_8859-1.vim</b><span>

You will find hints for the translation in &quot;$VIMRUNTIME/lang/README.txt&quot;.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*45.3*</i></b><span>  Using another encoding

Vim guesses that the files you are going to edit are encoded for your
language.  For many European languages this is &quot;latin1&quot;.  Then each byte is
one character.  That means there are 256 different characters possible.  For
Asian languages this is not sufficient.  These mostly use a double-byte
encoding, providing for over ten thousand possible characters.  This still
isn't enough when a text is to contain several different languages.  This is
where Unicode comes in.  It was designed to include all characters used in
commonly used languages.  This is the &quot;Super encoding that replaces all
others&quot;.  But it isn't used that much yet.
   Fortunately, Vim supports these three kinds of encodings.  And, with some
restrictions, you can use them even when your environment uses another
language than the text.
   Nevertheless, when you only edit files that are in the encoding of your
language, the default should work fine and you don't need to do anything.  The
following is only relevant when you want to edit different languages.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        Using different encodings only works when Vim was compiled to handle
        it.  To find out if it works, use the &quot;:version&quot; command and check the
        output for &quot;+multi_byte&quot;.  If it's there, you are OK.  If you see
        &quot;-multi_byte&quot; you will have to find another Vim.


USING UNICODE IN THE GUI

The nice thing about Unicode is that other encodings can be converted to it
and back without losing information.  When you make Vim use Unicode
internally, you will be able to edit files in any encoding.
   Unfortunately, the number of systems supporting Unicode is still limited.
Thus it's unlikely that your language uses it.  You need to tell Vim you want
to use Unicode, and how to handle interfacing with the rest of the system.
   Let's start with the GUI version of Vim, which is able to display Unicode
characters.  This should work:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set encoding=utf-8</b><span>
<span class="highlight"><b>        :set guifont=-misc-fixed-medium-r-normal--18-120-100-100-c-90-iso10646-1</b><span>

The <span class="highlight"><i>'encoding'</i><span> option tells Vim the encoding of the characters that you use.
This applies to the text in buffers (files you are editing), registers, Vim
script files, etc.  You can regard <span class="highlight"><i>'encoding'</i><span> as the setting for the internals
of Vim.
   This example assumes you have this font on your system.  The name in the
example is for X-Windows.  This font is in a package that is used to enhance
xterm with Unicode support.  If you don't have this font, you might find it
here:

<span class="highlight"><b>        http://www.cl.cam.ac.uk/~mgk25/download/ucs-fonts.tar.gz </b><span><font color="#e5e5e5">~</font>

For MS-Windows, some fonts have a limited number of Unicode characters.  Try
using the &quot;Courier New&quot; font.  You can use the Edit/Select Font... menu to
select and try out the fonts available.  Only fixed-width fonts can be used
though.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set guifont=courier_new:h12</b><span>

If it doesn't work well, try getting a fontpack.  If Microsoft didn't move it,
you can find it here:

<span class="highlight"><b>        http://www.microsoft.com/typography/fontpack/default.htm </b><span><font color="#e5e5e5">~</font>

Now you have told Vim to use Unicode internally and display text with a
Unicode font.  Typed characters still arrive in the encoding of your original
language.  This requires converting them to Unicode.  Tell Vim the language
from which to convert with the <span class="highlight"><i>'termencoding'</i><span> option.  You can do it like
this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :let &amp;termencoding = &amp;encoding</b><span>
<span class="highlight"><b>        :set encoding=utf-8</b><span>

This assigns the old value of <span class="highlight"><i>'encoding'</i></font></span> to <span class="highlight"><i>'termencoding'</i><span> before setting
<span class="highlight"><i>'encoding'</i><span> to utf-8.  You will have to try out if this really works for your
setup.  It should work especially well when using an input method for an Asian
language, and you want to edit Unicode text.


USING UNICODE IN A UNICODE TERMINAL

There are terminals that support Unicode directly.  The standard xterm that
comes with XFree86 is one of them.  Let's use that as an example.
   First of all, the xterm must have been compiled with Unicode support.  See
<span class="highlight"><i>|UTF8-xterm|</i><span> how to check that and how to compile it when needed.
   Start the xterm with the &quot;-u8&quot; argument.  You might also need so specify a
font.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>   xterm -u8 -fn -misc-fixed-medium-r-normal--18-120-100-100-c-90-iso10646-1</b><span>

Now you can run Vim inside this terminal.  Set <span class="highlight"><i>'encoding'</i><span> to &quot;utf-8&quot; as
before.  That's all.


USING UNICODE IN AN ORDINARY TERMINAL

Suppose you want to work with Unicode files, but don't have a terminal with
Unicode support.  You can do this with Vim, although characters that are not
supported by the terminal will not be displayed.  The layout of the text
will be preserved. <font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :let &amp;termencoding = &amp;encoding</b><span>
<span class="highlight"><b>        :set encoding=utf-8</b><span>

This is the same as what was used for the GUI.  But it works differently: Vim
will convert the displayed text before sending it to the terminal.  That
avoids that the display is messed up with strange characters.
   For this to work the conversion between <span class="highlight"><i>'termencoding'</i></font></span> and <span class="highlight"><i>'encoding'</i><span> must
be possible.  Vim will convert from latin1 to Unicode, thus that always works.
For other conversions the <span class="highlight"><i>|+iconv|</i><span> feature is required.
   Try editing a file with Unicode characters in it.  You will notice that Vim
will put a question mark (or underscore or some other character) in places
where a character should be that the terminal can't display.  Move the cursor
to a question mark and use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        ga</b><span>

Vim will display a line with the code of the character.  This gives you a hint
about what character it is.  You can look it up in a Unicode table.  You could
actually view a file that way, if you have lots of time at hand.

        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        Since <span class="highlight"><i>'encoding'</i><span> is used for all text inside Vim, changing it makes
        all non-ASCII text invalid.  You will notice this when using registers
        and the <span class="highlight"><i>'viminfo'</i><span> file (e.g., a remembered search pattern).  It's
        recommended to set <span class="highlight"><i>'encoding'</i><span> in your vimrc file, and leave it alone.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*45.4*</i></b><span>  Editing files with a different encoding

Suppose you have setup Vim to use Unicode, and you want to edit a file that is
in 16-bit Unicode.  Sounds simple, right?  Well, Vim actually uses utf-8
encoding internally, thus the 16-bit encoding must be converted.  Thus there
is a difference between the character set (Unicode) and the encoding (utf-8 or
16-bit).
   Vim will try to detect what kind of file you are editing.  It uses the
encoding names in the <span class="highlight"><i>'fileencodings'</i><span> option.  When using Unicode, the default
value is: &quot;ucs-bom,utf-8,latin1&quot;.  This means that Vim checks the file to see
if it's one of these encodings:

        ucs-bom         File must start with a Byte Order Mark (BOM).  This
                        allows detection of 16-bit, 32-bit and utf-8 Unicode
                        encodings.
        utf-8           utf-8 Unicode.  This is rejected when a sequence of
                        bytes is illegal in utf-8.
        latin1          The good old 8-bit encoding.  Always works.

When you start editing that 16-bit Unicode file, and it has a BOM, Vim will
detect this and convert the file to utf-8 when reading it.  The <span class="highlight"><i>'fileencoding'</i><span>
option (without s at the end) is set to the detected value.  In this case it
is &quot;ucs-2le&quot;.  That means it's Unicode, two bytes and little-endian.  This
file format is common on MS-Windows (e.g., for registry files).
   When writing the file, Vim will compare <span class="highlight"><i>'fileencoding'</i></font></span> with <span class"highlight"><i>'encoding'</i><span>.  If
they are different, the text will be converted.
   An empty value for <span class="highlight"><i>'fileencoding'</i><span> means that no conversion is to be done.
Thus the text is assumed to be encoded with <span class="highlight"><i>'encoding'</i><span>.

If the default <span class="highlight"><i>'fileencodings'</i><span> value is not good for you, set it to the
encodings you want Vim to try.  Only when a value is found to be invalid will
the next one be used.  Putting &quot;latin1&quot; first doesn't work, because it is
never illegal.  An example, to fall back to Japanese when the file doesn't
have a BOM and isn't utf-8:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set fileencodings=ucs-bom,utf-8,sjis</b><span>

See <span class="highlight"><i>|encoding-values|</i><span> for suggested values.  Other values may work as well.
This depends on the conversion available.


FORCING AN ENCODING

If the automatic detection doesn't work you must tell Vim what encoding the
file is.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :edit ++enc=koi8-r russian.txt</b><span>

The &quot;++enc&quot; part specifies the name of the encoding to be used for this file
only.  Vim will convert the file from the specified encoding, Russian in this
example, to <span class="highlight"><i>'encoding'</i></font></span>.  <span class="highlight"><i>'fileencoding'</i><span> will also be set to the specified
encoding, so that the reverse conversion can be done when writing the file.
   The same argument can be used when writing the file.  This way you can
actually use Vim to convert a file.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :write ++enc=utf-8 russian.txt</b><span>
<font color="#e5e5e5">&lt;</font>
        <span class="highlight"><b><i><u>Note</u></i></b><span>:
        Conversion may result in lost characters.  Conversion from an encoding
        to Unicode and back is mostly free of this problem, unless there are
        illegal characters.  Conversion from Unicode to other encodings often
        loses information when there was more than one language in the file.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*45.5*</i></b><span>  Entering language text

Computer keyboards don't have much more than a hundred keys.  Some languages
have thousands of characters, Unicode has ten thousands.  So how do you type
these characters?
   First of all, when you don't use too many of the special characters, you
can use digraphs.  This was already explained in <span class="highlight"><i>|24.9|</i><span>.
   When you use a language that uses many more characters than keys on your
keyboard, you will want to use an Input Method (IM).  This requires learning
the translation from typed keys to resulting character.  When you need an IM
you probably already have one on your system.  It should work with Vim like
with other programs.  For details see <span class="highlight"><i>|mbyte-XIM|</i><span> for X-Windows and
<span class="highlight"><i>|mbyte-IME|</i><span> for MS-Windows.


KEYMAPS

For some languages the character set is different from latin, but uses a
similar number of characters.  It's possible to map keys to characters.  Vim
uses keymaps for this.
   Suppose you want to type hebrew.  You can load the keymap like this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set keymap=hebrew</b><span>

Vim will try to find a keymap file for you.  This depends on the value of
<span class="highlight"><i>'encoding'</i><span>.  If no matching file was found, you will get an error message.

Now you can type Hebrew in Insert mode.  In Normal mode, and when typing a &quot;:&quot;
command, Vim automatically switches to English.  You can use this command to
switch between Hebrew and English:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        CTRL-^</b><span>

This only works in Insert mode and Command-line mode.  In Normal mode it does
something completely different (jumps to alternate file).
   The usage of the keymap is indicated in the mode message, if you have the
<span class="highlight"><i>'showmode'</i><span> option set.  In the GUI Vim will indicate the usage of keymaps with
a different cursor color.
   You can also change the usage of the keymap with the <span class="highlight"><i>'iminsert'</i><span> and
<span class="highlight"><i>'imsearch'</i><span> options.

To see the list of mappings, use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :lmap</b><span>

To find out which keymap files are available, in the GUI you can use the
Edit/Keymap menu.  Otherwise you can use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :echo globpath(&amp;rtp, &quot;keymap/*.vim&quot;)</b><span>


DO-IT-YOURSELF KEYMAPS

You can create your own keymap file.  It's not very difficult.  Start with
a keymap file that is similar to the language you want to use.  Copy it to the
&quot;keymap&quot; directory in your runtime directory.  For example, for Unix, you
would use the directory &quot;~/.vim/keymap&quot;.
   The name of the keymap file must look like this:

<span class="highlight"><b>        keymap/{name}.vim </b><span><font color="#e5e5e5">~</font>
or
<span class="highlight"><b>        keymap/{name}_{encoding}.vim </b><span><font color="#e5e5e5">~</font>

<span class="highlight"><i>{name}</i><span> is the name of the keymap.  Chose a name that is obvious, but different
from existing keymaps (unless you want to replace an existing keymap file).
The name cannot contain an underscore.  Optionally, add the encoding used.
Examples:

<span class="highlight"><b>        keymap/hebrew.vim </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        keymap/hebrew_utf-8.vim </b><span><font color="#e5e5e5">~</font>

The contents of the file should be self-explanatory.  Look at a few of the
keymaps that are distributed with Vim.  For the details, see <span class="highlight"><i>|mbyte-keymap|</i><span>.


LAST RESORT

If all other methods fail, you can enter any character with <span class="highlight"><i>CTRL-V</i><span>:

<span class="highlight"><b>        encoding   type                 range </b><span><font color="#e5e5e5">~</font>
        8-bit      <span class="highlight"><i>CTRL-V</i><span> 123           decimal 0-255
        8-bit      <span class="highlight"><i>CTRL-V</i><span> x a1          hexadecimal 00-ff
        16-bit     <span class="highlight"><i>CTRL-V</i><span> u 013b        hexadecimal 0000-ffff
        31-bit     <span class="highlight"><i>CTRL-V</i><span> U 001303a4    hexadecimal 00000000-7fffffff

Don't type the spaces.  See <span class="highlight"><i>|i_CTRL-V_digit|</i><span> for the details.

<span class="highlight"><b>==============================================================================</b><span>


<span class="highlight"><b><i>*usr_90.txt*</i></b></font></span>    For <span class="highlight"><i>Vim version 6.1.</i><span>  Last change: 2001 Oct 23


                                Installing Vim

<span class="highlight"><b>                                                                </b></font></span><span class="highlight"><b><i>*install*</i></b><span>
Before you can use Vim you have to install it.  Depending on your system it's
simple or easy.  This chapter gives a few hints and also explains how
upgrading to a new version is done.

<span class="highlight"><i>|90.1|</i><span>  Unix
<span class="highlight"><i>|90.2|</i><span>  MS-Windows
<span class="highlight"><i>|90.3|</i><span>  Upgrading
<span class="highlight"><i>|90.4|</i><span>  Common installation issues
<span class="highlight"><i>|90.5|</i><span>  Uninstalling Vim


<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*90.1*</i></b><span>  Unix

First you have to decide if you are going to install Vim system-wide or for a
single user.  The installation is almost the same, but the directory where Vim
is installed in differs.
   For a system-wide installation the base directory &quot;/usr/local&quot; is often
used.  But this may be different for your system.  Try finding out where other
packages are installed.
   When installing for a single user, you can use your home directory as the
base.  The files will be placed in subdirectories like &quot;bin&quot; and &quot;shared/vim&quot;.


FROM A PACKAGE

You can get precompiled binaries for many different UNIX systems.  There is a
long list with links on this page:

<span class="highlight"><b>        http://www.vim.org/binaries.html </b><span><font color="#e5e5e5">~</font>

Volunteers maintain the binaries, so they are often out of date.  It is a
good idea to compile your own UNIX version from the source.  Also, creating
the editor from the source allows you to control which features are compiled.
This does require a compiler though.

If you have a Linux distribution, the &quot;vi&quot; program is probably a minimal
version of Vim.  It doesn't do syntax highlighting, for example.  Try finding
another Vim package in your distribution, or search on the web site.


FROM SOURCES

To compile and install Vim, you will need the following:

        -  A C compiler (GCC preferred)
        -  The GZIP program (you can get it from www.gnu.org)
        -  The Vim source and runtime archives

To get the Vim archives, look in this file for a mirror near you, this should
provide the fastest download:

<span class="highlight"><b>        ftp://ftp.vim.org/pub/vim/MIRRORS </b><span><font color="#e5e5e5">~</font>

Or use the home site ftp.vim.org, if you think it's fast enough.  Go to the
&quot;unix&quot; directory and you'll find a list of files there.  The version number is
embedded in the file name.  You will want to get the most recent version.
   You can get the files for Unix in two ways: One big archive that contains
everything, or four smaller ones that each fit on a floppy disk.  For version
6.0 the single big one is called:

<span class="highlight"><b>        vim-6.0.tar.bz2 </b><span><font color="#e5e5e5">~</font>

You need the bzip2 program to uncompress it.  If you don't have it, get the
four smaller files, which can be uncompressed with gzip.  For Vim 6.0 they are
called:

<span class="highlight"><b>        vim-6.0-src1.tar.gz </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        vim-6.0-src2.tar.gz </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        vim-6.0-rt1.tar.gz </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        vim-6.0-rt2.tar.gz </b><span><font color="#e5e5e5">~</font>


COMPILING

First create a top directory to work in, for example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        mkdir ~/vim</b><span>
<span class="highlight"><b>        cd ~/vim</b><span>

Then unpack the archives there.  If you have the one big archive, you unpack
it like this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        bzip2 -d -c path/vim-6.0.tar.bz2 | tar xf -</b><span>

Change &quot;path&quot; to where you have downloaded the file.

        gzip -d path/vim-6.0-src1.tar.gz | tar xf -
        gzip -d path/vim-6.0-src2.tar.gz | tar xf -
        gzip -d path/vim-6.0-rt1.tar.gz | tar xf -
        gzip -d path/vim-6.0-rt2.tar.gz | tar xf -

If you are satisfied with getting the default features, and your environment
is setup properly, you should be able to compile Vim with just this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        cd vim60/src</b><span>
<span class="highlight"><b>        make</b><span>

The make program will run configure and compile everything.  Further on we
will explain how to compile with different features.
   If there are errors while compiling, carefully look at the error messages.
There should be a hint about what went wrong.  Hopefully you will be able to
correct it.  You might have to disable some features to make Vim compile.
Look in the Makefile for specific hints for your system.


TESTING

Now you can check if compiling worked OK:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        make test</b><span>

This will run a sequence of test scripts to verify that Vim works as expected.
Vim will be started many times and all kinds of text and messages flash by.
If it is alright you will finally see:

<span class="highlight"><b>        test results: </b><span><font color="#e5e5e5">~</font>
<span class="highlight"><b>        ALL DONE </b><span><font color="#e5e5e5">~</font>

If there are one or two messages about failed tests, Vim might still work, but
not perfectly.  If you see a lot of error messages or Vim doesn't finish until
the end, there must be something wrong.  Either try to find out yourself, or
find someone who can solve it.  You could look in the <span class="highlight"><i>|maillist-archive|</i><span> for a
solution.  If everything else fails, you could ask in the vim <span class="highlight"><i>|maillist|</i><span> if
someone can help you.


INSTALLING
<span class="highlight"><b>                                                        </b></font></span><span class="highlight"><b><i>*install-home*</i></b><span>
If you want to install in your home directory, edit the Makefile and search
for a line:

<span class="highlight"><b>        #prefix = $(HOME) </b><span><font color="#e5e5e5">~</font>

Remove the # at the start of the line.
   When installing for the whole system, Vim has most likely already selected
a good installation directory for you.  You can also specify one, see below.
You need to become root for the following.

To install Vim do:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        make install</b><span>

That should move all the relevant files to the right place.  Now you can try
running vim to verify that it works.  Use two simple tests to check if Vim can
find its runtime files:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :help</b><span>
<span class="highlight"><b>        :syntax enable</b><span>

If this doesn't work, use this command to check where Vim is looking for the
runtime files:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :echo $VIMRUNTIME</b><span>

You can also start Vim with the &quot;-V&quot; argument to see what happens during
startup:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        vim -V</b><span>

Don't forget that the user manual assumes you Vim in a certain way.  After
installing Vim, follow the instructions at <span class="highlight"><i>|not-compatible|</i><span> to make Vim work
as assumed in this manual.


SELECTING FEATURES

Vim has many ways to select features.  One of the simple ways is to edit the
Makefile.  There are many directions and examples.  Often you can enable or
disable a feature by uncommenting a line.
   An alternative is to run &quot;configure&quot; separately.  This allows you to
specify configuration options manually.  The disadvantage is that you have to
figure out what exactly to type.
   Some of the most interesting configure arguments follow.  These can also be
enabled from the Makefile.

        --prefix=<span class="highlight"><i>{directory}</i><span>            Top directory where to install Vim.

        --with-features=tiny            Compile with many features disabled.
        --with-features=small           Compile with some features disabled.
        --with-features=big             Compile with more features enabled.
        --with-features=huge            Compile with most features enabled.
                                        See <span class="highlight"><i>|+feature-list|</i><span> for which feature
                                        is enabled in which case.

        --enable-perlinterp             Enable the Perl interface.  There are
                                        similar arguments for ruby, python and
                                        tcl.

        --disable-gui                   Do not compile the GUI interface.
        --without-x                     Do not compile X-windows features.
                                        When both of these are used, Vim will
                                        not connect to the X server, which
                                        makes startup faster.

To see the whole list use:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        ./configure --help</b><span>

You can find a bit of explanation for each feature, and links for more
information here: <span class="highlight"><i>|feature-list|</i><span>.
   For the adventurous, edit the file &quot;feature.h&quot;.  You can also change the
source code yourself!

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*90.2*</i></b><span>  MS-Windows

There are two ways to install the Vim program for Microsoft Windows.  You can
uncompress several archives, or use a self-installing big archive.  Most users
with fairly recent computers will prefer the second method.  For the first
one, you will need:

        - An archive with binaries for Vim.
        - The Vim runtime archive.
        - A program to unpack the zip files.

To get the Vim archives, look in this file for a mirror near you, this should
provide the fastest download:

<span class="highlight"><b>        ftp://ftp.vim.org/pub/vim/MIRRORS </b><span><font color="#e5e5e5">~</font>

Or use the home site ftp.vim.org, if you think it's fast enough.  Go to the
&quot;pc&quot; directory and you'll find a list of files there.  The version number is
embedded in the file name.  You will want to get the most recent version.
We will use &quot;60&quot; here, which is version 6.0.

        gvim60.exe              The self-installing archive.

This is all you need for the second method.  Just launch the executable, and
follow the prompts.

For the first method you must chose one of the binary archives.  These are
available:

        gvim60.zip              The normal MS-Windows GUI version.
        gvim60ole.zip           The MS-Windows GUI version with OLE support.
                                Uses more memory, supports interfacing with
                                other OLE applications.
        vim60w32.zip            32 bit MS-Windows console version.  For use in
                                a Win NT/2000/XP console.  Does not work well
                                on Win 95/98.
        vim60d32.zip            32 bit MS-DOS version.  For use in the
                                Win 95/98 console window.
        vim60d16.zip            16 bit MS-DOS version.  Only for old systems.
                                Does not support long filenames.

You only need one of them.  Although you could install both a GUI and a
console version.  You always need to get the archive with runtime files.

        vim60rt.zip             The runtime files.

Use your un-zip program to unpack the files.  For example, using the &quot;unzip&quot;
program:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        cd c:\</b><span>
<span class="highlight"><b>        unzip path\gvim60.zip</b><span>
<span class="highlight"><b>        unzip path\vim60rt.zip</b><span>

This will unpack the files in the directory &quot;c:\vim\vim60&quot;.  If you already
have a &quot;vim&quot; directory somewhere, you will want to move to the directory just
above it.
   Now change to the &quot;vim\vim60&quot; directory and run the install program:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        install</b><span>

Carefully look through the messages and select the options you want to use.
If you finally select &quot;do it&quot; the install program will carry out the actions
you selected.
   The install program doesn't move the runtime files.  They remain where you
unpacked them.

In case you are not satisfied with the features included in the supplied
binaries, you could try compiling Vim yourself.  Get the source archive from
the same location as where the binaries are.  You need a compiler for which a
makefile exists.  Microsoft Visual C works, but is expensive.  The Free
Borland command-line compiler 5.5 can be used, as well as the free MingW and
Cygwin compilers.  Check the file src/INSTALLpc.txt for hints.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*90.3*</i></b><span>  Upgrading

If you are running one version of Vim and want to install another, here is
what to do.


UNIX

When you type &quot;make install&quot; the runtime files will be copied to a directory
which is specific for this version.  Thus they will not overwrite a previous
version.  This makes it possible to use two or more versions next to
each other.
   The executable &quot;vim&quot; will overwrite an older version.  If you don't care
about keeping the old version, running &quot;make install&quot; will work fine.  You can
delete the old runtime files manually.  Just delete the directory with the
version number in it and all files below it.  Example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        rm -rf /usr/local/share/vim/vim58</b><span>

There are normally no changed files below this directory.  If you did change
the &quot;filetype.vim&quot; file, for example, you better merge the changes into the
new version before deleting it.

If you are careful and want to try out the new version for a while before
switching to it, install the new version under another name.  You need to
specify a configure argument.  For example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        ./configure --with-vim-name=vim6</b><span>

Before running &quot;make install&quot;, you could use &quot;make -n install&quot; to check that
no valuable existing files are overwritten.
   When you finally decide to switch to the new version, all you need to do is
to rename the binary to &quot;vim&quot;.  For example:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        mv /usr/local/bin/vim6 /usr/local/bin/vim</b><span>


MS-WINDOWS

Upgrading is mostly equal to installing a new version.  Just unpack the files
in the same place as the previous version.  A new directory will be created,
e.g., &quot;vim61&quot;, for the files of the new version.  Your runtime files, vimrc
file, viminfo, etc. will be left alone.
   If you want to run the new version next to the old one, you will have to do
some handwork.  Don't run the install program, it will overwrite a few files
of the old version.  Execute the new binaries by specifying the full path.
The program should be able to automatically find the runtime files for the
right version.  However, this won't work if you set the $VIMRUNTIME variable
somewhere.
   If you are satisfied with the upgrade, you can delete the files of the
previous version.  See <span class="highlight"><i>|90.5|</i><span>.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*90.4*</i></b><span>  Common installation issues

This section describes some of the common problems that occur when installing
Vim and suggests some solutions.  It also contains answers to many
installation questions.


Q: I Do Not Have Root Privileges.  How Do I Install Vim? (Unix)

Use the following configuration command to install Vim in a directory called
$HOME/vim:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        ./configure --prefix=$HOME</b><span>

This gives you a personal copy of Vim.  You need to put $HOME/bin in your
path to execute the editor.  Also see <span class="highlight"><i>|install-home|</i><span>.


Q: The Colors Are Not Right on My Screen. (Unix)

Check your terminal settings by using the following command in a shell:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        echo $TERM</b><span>

If the terminal type listed is not correct, fix it.  For more hints, see
<span class="highlight"><i>|06.2|</i><span>.  Another solution is to always use the GUI version of Vim, called
gvim.  This avoids the need for a correct terminal setup.


Q: My Backspace And Delete Keys Don't Work Right

The definition of what key sends what code is very unclear for backspace <span class="highlight"><i>&lt;BS&gt;</i><span>
and Delete <span class="highlight"><i>&lt;Del&gt;</i><span> keys.  First of all, check your $TERM setting.  If there is
nothing wrong with it, try this:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        :set t_kb=^V&lt;BS&gt;</b><span>
<span class="highlight"><b>        :set t_kD=^V&lt;Del&gt;</b><span>

In the first line you need to press <span class="highlight"><i>CTRL-V</i><span> and then hit the backspace key.
In the second line you need to press <span class="highlight"><i>CTRL-V</i><span> and then hit the Delete key.
You can put these lines in your vimrc file, see <span class="highlight"><i>|05.1|</i><span>.  A disadvantage is
that it won't work when you use another terminal some day.  Look here for
alternate solutions: <span class="highlight"><i>|:fixdel|</i><span>.


Q: I Am Using RedHat Linux.  Can I Use the Vim That Comes with the System?

By default RedHat installs a minimal version of Vim.  Check your RPM packages
for something named &quot;Vim-enhanced-version.rpm&quot; and install that.


Q: How Do I Turn Syntax Coloring On?  How do I make plugins work?

Use the example vimrc script.  You can find an explanation on how to use it
here: <span class="highlight"><i>|not-compatible|</i><span>.

See chapter 6 for information about syntax highlighting: <span class="highlight"><i>|usr_06.txt|</i><span>.


Q: What Is a Good vimrc File to Use?

See the www.vim.org Web site for several good examples.


Q: Where Do I Find a Good Vim Plugin?

See the Vim-online site: http://vim.sf.net.  Many users have uploaded useful
Vim scripts and plugins there.


Q: Where Do I Find More Tips?

See the Vim-online site: http://vim.sf.net.  There is an archive with hints
from Vim users.  You might also want to search in the <span class="highlight"><i>|maillist-archive|</i><span>.

<span class="highlight"><b>==============================================================================</b><span>
<span class="highlight"><b><i>*90.5*</i></b><span>  Uninstalling Vim

In the unlikely event you want to uninstall Vim completely, this is how you do
it.


UNIX

When you installed Vim as a package, check your package manager to find out
how to remove the package again.
   If you installed Vim from sources you can use this command:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        make uninstall</b><span>

However, if you have deleted the original files or you used an archive that
someone supplied, you can't do this.  Do delete the files manually, here is an
example for when &quot;/usr/local&quot; was used as the root:<font color="#e5e5e5"> &gt;</font>

<span class="highlight"><b>        rm -rf /usr/local/share/vim/vim60</b><span>
<span class="highlight"><b>        rm /usr/local/bin/eview</b><span>
<span class="highlight"><b>        rm /usr/local/bin/evim</b><span>
<span class="highlight"><b>        rm /usr/local/bin/ex</b><span>
<span class="highlight"><b>        rm /usr/local/bin/gview</b><span>
<span class="highlight"><b>        rm /usr/local/bin/gvim</b><span>
<span class="highlight"><b>        rm /usr/local/bin/gvim</b><span>
<span class="highlight"><b>        rm /usr/local/bin/gvimdiff</b><span>
<span class="highlight"><b>        rm /usr/local/bin/rgview</b><span>
<span class="highlight"><b>        rm /usr/local/bin/rgvim</b><span>
<span class="highlight"><b>        rm /usr/local/bin/rview</b><span>
<span class="highlight"><b>        rm /usr/local/bin/rvim</b><span>
<span class="highlight"><b>        rm /usr/local/bin/rvim</b><span>
<span class="highlight"><b>        rm /usr/local/bin/view</b><span>
<span class="highlight"><b>        rm /usr/local/bin/vim</b><span>
<span class="highlight"><b>        rm /usr/local/bin/vimdiff</b><span>
<span class="highlight"><b>        rm /usr/local/bin/vimtutor</b><span>
<span class="highlight"><b>        rm /usr/local/bin/xxd</b><span>
<span class="highlight"><b>        rm /usr/local/man/man1/eview.1</b><span>
<span class="highlight"><b>        rm /usr/local/man/man1/evim.1</b><span>
<span class="highlight"><b>        rm /usr/local/man/man1/ex.1</b><span>
<span class="highlight"><b>        rm /usr/local/man/man1/gview.1</b><span>
<span class="highlight"><b>        rm /usr/local/man/man1/gvim.1</b><span>
<span class="highlight"><b>        rm /usr/local/man/man1/gvimdiff.1</b><span>
<span class="highlight"><b>        rm /usr/local/man/man1/rgview.1</b><span>
<span class="highlight"><b>        rm /usr/local/man/man1/rgvim.1</b><span>
<span class="highlight"><b>        rm /usr/local/man/man1/rview.1</b><span>
<span class="highlight"><b>        rm /usr/local/man/man1/rvim.1</b><span>
<span class="highlight"><b>        rm /usr/local/man/man1/view.1</b><span>
<span class="highlight"><b>        rm /usr/local/man/man1/vim.1</b><span>
<span class="highlight"><b>        rm /usr/local/man/man1/vimdiff.1</b><span>
<span class="highlight"><b>        rm /usr/local/man/man1/vimtutor.1</b><span>
<span class="highlight"><b>        rm /usr/local/man/man1/xxd.1</b><span>


MS-WINDOWS

If you installed Vim with the self-installing archive you can run
the &quot;uninstall-gui&quot; program located in the same directory as the other Vim
programs, e.g. &quot;c:\vim\vim60&quot;.  You can also launch it from the Start menu if
installed the Vim entries there.  This will remove most of the files, menu
entries and desktop shortcuts.  Some files may remain however, as they need a
Windows restart before being deleted.
   You will be given the option to remove the whole &quot;vim&quot; directory.  It
probably contains your vimrc file and other runtime files that you created, so
be careful.

Else, if you installed Vim with the zip archives, the preferred way is to use
the &quot;uninstal&quot; program (<span class="highlight"><b><i><u>note</u></i></b><span> the missing l at the end).  You can find it in
the same directory as the &quot;install&quot; program, e.g., &quot;c:\vim\vim60&quot;.  This
should also work from the usual &quot;install/remove software&quot; page.
   However, this only removes the registry entries for Vim.  You have to
delete the files yourself.  Simply select the directory &quot;vim\vim60&quot; and delete
it recursively.  There should be no files there that you changed, but you
might want to check that first.
   The &quot;vim&quot; directory probably contains your vimrc file and other runtime
files that you created.  You might want to keep that.

<span class="highlight"><b>==============================================================================</b><span>



Copyright: see |manual-copyright|
</pre>
</body>
</html>

