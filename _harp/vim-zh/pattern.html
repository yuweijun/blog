<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>VIM: pattern</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<h2>PATTERN</h2>
<pre>
<b class="vimtag">*<a name="pattern.txt">pattern.txt</a>*</b>   For Vim version 7.3.  最近更新：2009年4月


                  VIM REFERENCE MANUAL    by Bram Moolenaar
                    <code class="vim">译者</code>: lang2 http://vimcdoc.sf.net


模式及查找命令                                  <b class="vimtag">*<a name="pattern-searches">pattern-searches</a>*</b>

最基本的东西可以在用户手册的 |<code class="badlink">03.9</code>| 节中找到。在 |<a class="vim-doc" href="usr_27.html">usr_27.txt</a>| 也有一些解释。

1. 查找命令                     |<code class="badlink">search-commands</code>|
2. 匹配模式的定义               |<code class="badlink">search-pattern</code>|
3. 魔术                         |<code class="badlink">/magic</code>|
4. 模式项总览                   |<code class="badlink">pattern-overview</code>|
5. 倍数项                       |<code class="badlink">pattern-multi-items</code>|
6. 普通匹配原                   |<code class="badlink">pattern-atoms</code>|
7. 忽略大小写                   |<code class="badlink">/ignorecase</code>|
8. 合成用字符                   |<code class="badlink">patterns-composing</code>|
9. 与 Perl 匹配模式的比较       |<code class="badlink">perl-patterns</code>|
10. 高亮显示匹配                |<code class="badlink">match-highlight</code>|

</pre><hr class="doubleline" /><pre>
<h4>1. 查找命令                                     <b class="vimtag">*<a name="search-commands">search-commands</a>*</b> <b class="vimtag">*<a name="E486">E486</a>*</b></h4>
                                                        <b class="vimtag">*<a name="%2F">/</a>*</b>
/<code class="special">{pattern}</code>[/]<code class="special">&lt;CR&gt;</code>       正向查找第 <code class="special">[count]</code> 次出现 <code class="special">{pattern}</code> 的地方
                        (|<code class="badlink">exclusive</code>| 开动作)。

/<code class="special">{pattern}</code>/<code class="special">{offset}</code><code class="special">&lt;CR&gt;</code> 正向查找第 <code class="special">[count]</code> 次出现 <code class="special">{pattern}</code> 的地方并向上或下移
                        动 |<code class="badlink"><code class="special">{offset}</code></code>| 行。|<code class="badlink">linewise</code>| 行动作。

                                                        <b class="vimtag">*<a name="%2F%3CCR%3E">/&lt;CR&gt;</a>*</b>
/<code class="special">&lt;CR&gt;</code>                   正向查找第 <code class="special">[count]</code> 次出现处，使用上次的模式
                        |<code class="badlink">last-pattern</code>| 以及上次的 |<code class="badlink"><code class="special">{offset}</code></code>|。

//<code class="special">{offset}</code><code class="special">&lt;CR&gt;</code>          正向查找第 <code class="special">[count]</code> 次出现处，使用上次的模式
                        |<code class="badlink">last-pattern</code>| 以及新偏移 |<code class="badlink"><code class="special">{offset}</code></code>|。若 <code class="special">{offset}</code> 为
                        空，不使用任何偏移。

                                                        <b class="vimtag">*<a name="?">?</a>*</b>
?<code class="special">{pattern}</code>[?]<code class="special">&lt;CR&gt;</code>       反向查找第 <code class="special">[count]</code> 次出现 <code class="special">{pattern}</code> 的地方
                        (|<code class="badlink">exclusive</code>| 开动作)

?<code class="special">{pattern}</code>?<code class="special">{offset}</code><code class="special">&lt;CR&gt;</code> 反向查找第 <code class="special">[count]</code> 次出现 <code class="special">{pattern}</code> 的地方
                        并向上或下移动 |<code class="badlink"><code class="special">{offset}</code></code>| 行 |<code class="badlink">linewise</code>| 行动作。

                                                        <b class="vimtag">*<a name="?%3CCR%3E">?&lt;CR&gt;</a>*</b>
?<code class="special">&lt;CR&gt;</code>                   反向查找第 <code class="special">[count]</code> 次出现处，使用上次的模式
                        |<code class="badlink">last-pattern</code>| 以及上次的 |<code class="badlink"><code class="special">{offset}</code></code>|。

??<code class="special">{offset}</code><code class="special">&lt;CR&gt;</code>          反向查找第 <code class="special">[count]</code> 次出现处，使用上次的模式
                        |<code class="badlink">last-pattern</code>| 以及新偏移 |<code class="badlink"><code class="special">{offset}</code></code>|。若 <code class="special">{offset}</code> 为
                        空，不使用任何偏移。

                                                        <b class="vimtag">*<a name="n">n</a>*</b>
n                       将上次的 "/" 或 "?" 重复 <code class="special">[count]</code> 次。
                        |<code class="badlink">last-pattern</code>| <code class="special"><code class="special">{Vi: 无计数}</code></code>

                                                        <b class="vimtag">*<a name="N">N</a>*</b>
N                       将上次的 "/" 或 "?" 在相反方向上重复 <code class="special">[count]</code> 次。
                        |<code class="badlink">last-pattern</code>| <code class="special"><code class="special">{Vi: 无计数}</code></code>

                                                        <b class="vimtag">*<a name="star">star</a>*</b> <b class="vimtag">*<a name="E348">E348</a>*</b> <b class="vimtag">*<a name="E349">E349</a>*</b>
*                       正向查找第 <code class="special">[count]</code> 次出现距离当前光标最近的单词的地
                        方。用于查找的单词是以下最先符合条件的:
                                1. 光标所在的关键字 |<code class="badlink">'iskeyword'</code>|
                                2. 当前行内的光标后的第一个关键字。
                                3. 光标所在的非空白单词
                                4. 当前行内的光标后的第一个非空白单词
                        只查找整字，就像使用了命令 "/\<code class="special">&lt;keyword\&gt;</code>" 一样。
                        (|<code class="badlink">exclusive</code>| 开动作) <code class="special"><code class="special">{Vi 无此功能}</code></code>
                        使用 'ignorecase'，不使用 'smartcase'。

                                                        <b class="vimtag">*<a name="%23">#</a>*</b>
#                       同 "*"，但反向查找。也可以用磅符号 (字符 163)。如果
                        "#" 的功能和退格键一样，试着在启动 Vim 前使用
                        "stty erase <code class="special">&lt;BS&gt;</code>" (<code class="special">&lt;BS&gt;</code> 是 <code class="keystroke">CTRL-H</code> 或真的退格键)。
                        <code class="special"><code class="special">{Vi 无此功能}</code></code>

                                                        <b class="vimtag">*<a name="gstar">gstar</a>*</b>
g*                      同 "*"，但不使用 "\<code class="special">&lt;" 和 "\&gt;</code>"。这样查找就会匹配非整字
                        的地方。<code class="special"><code class="special">{Vi 无此功能}</code></code>

                                                        <b class="vimtag">*<a name="g%23">g#</a>*</b>
g#                      同 "#"，但不使用 "\<code class="special">&lt;" 和 "\&gt;</code>"。这样查找就会匹配非整字
                        的地方。<code class="special"><code class="special">{Vi 无此功能}</code></code>

                                                        <b class="vimtag">*<a name="gd">gd</a>*</b>
gd                      跳转 (goto) 至局部声明 (declaration)。当光标下是一个局
                        部变量时，此命令会跳转到该变量被声明的地方。
                        首先，Vim 会查找当前函数的起始处，就像使用 "[[" 一样。
                        如果找不到会停止在第一行。如果找到， Vim 会反向搜索直
                        到找到一个空行，然后从这里开始正向查找光标所在的关键
                        字，就像使用了 "*" 一样，但看起来象注释的行会被忽略。
                        (见 'comments' 选项)。
                        <code class="note">注意</code> 这并非总有效。Vim 不会做语法分析。它仅仅查找关键
                        字的匹配。如果头文件也需要搜索的话，可以使用
                        |<code class="badlink">include-search</code>| 列出的命令。
                        这个命令之后，可以使用 |<code class="badlink">n</code>| 正向查找下一个匹配 (不能反
                        向)。
                        <code class="special"><code class="special">{Vi 无此功能}</code></code>

                                                        <b class="vimtag">*<a name="gD">gD</a>*</b>
gD                      跳转 (goto) 至全局声明 (Declaration)。当光标下是一个全
                        局变量时，此命令会跳转到该变量被声明的地方。此命令和
                        "gd" 命令一样，不过查找总是从第一行开始。<code class="special"><code class="special">{Vi 无此功能}</code></code>

                                                        <b class="vimtag">*<a name="1gd">1gd</a>*</b>
1gd                     同 "gd"，但忽略光标位置前结束的 <code class="special">{}</code> 块里的匹配。
                        <code class="special"><code class="special">{Vi 无此功能}</code></code>

                                                        <b class="vimtag">*<a name="1gD">1gD</a>*</b>
1gD                     同 "gD"，但忽略光标位置前结束的 <code class="special">{}</code> 块里的匹配。
                        <code class="special"><code class="special">{Vi 无此功能}</code></code>

                                                        <b class="vimtag">*<a name="CTRL-C">CTRL-C</a>*</b>
<code class="keystroke">CTRL-C</code>                  中止当前的 (搜索) 命令。在 MS-DOS 上用 <code class="keystroke">CTRL-Break</code>
                        |<code class="badlink">dos-CTRL-Break</code>|。
                        在普通模式下，任何等待的命令将被终止。

                                                        <b class="vimtag">*<a name=":noh">:noh</a>*</b> <b class="vimtag">*<a name=":nohlsearch">:nohlsearch</a>*</b>
:noh[lsearch]           停止 'hlsearch' 选项的高亮显示。如果再执行查找命令或者
                        设定 'hlsearch' 选项，高亮会自动打开。此命令无法在自动
                        命令里使用，因为高亮的状态会在自动命令执行期间自动保存
                        和恢复 |<code class="badlink">autocmd-searchpat</code>|。
                        执行用户函数时也是如此。

如果打开 'incsearch' 选项，键入查找模式时，即时显示当前的匹配。不过，你还得用
<code class="special">&lt;CR&gt;</code> 来结束查找命令并将光标定位到显示的匹配。也可以用 <code class="special">&lt;ESC&gt;</code> 来放弃查找。

如果打开 'hlsearch'，最后一次查找命令的所有匹配点都会被高亮。用 |<code class="badlink">:nohlsearch</code>|
命令来暂停。

                                        <b class="vimtag">*<a name="search-offset">search-offset</a>*</b> <b class="vimtag">*<a name="<code class="special">{offset}</code>"><code class="special">{offset}</code></a>*</b>
这些命令查找一个指定的模式。而 "/" 和 "?" 命令还可以指定一个额外的偏移量。有两
种偏移：行偏移和字符偏移。<code class="special"><code class="special">{Vi 没有字符偏移}</code></code>

偏移用来指定光标相对于找到的匹配的位置:
    <code class="special">[num]</code>       <code class="special">[num]</code> 行向下，第一列
    +<code class="special">[num]</code>      <code class="special">[num]</code> 行向下，第一列
    -<code class="special">[num]</code>      <code class="special">[num]</code> 行向上，第一列
    e<code class="special">[+num]</code>     <code class="special">[num]</code> 字符向右 (从匹配结束 (end) 处算起)
    e<code class="special">[-num]</code>     <code class="special">[num]</code> 字符向左 (从匹配结束 (end) 处算起)
    s<code class="special">[+num]</code>     <code class="special">[num]</code> 字符向右 (从匹配开始 (start) 处算起)
    s<code class="special">[-num]</code>     <code class="special">[num]</code> 字符向左 (从匹配开始 (start) 处算起)
    b<code class="special">[+num]</code>     <code class="special">[num]</code> 等价于 s<code class="special">[+num]</code> (从匹配开始 (begin) 处算起)
    b<code class="special">[-num]</code>     <code class="special">[num]</code> 等价于 s<code class="special">[-num]</code> (从匹配开始 (begin) 处算起)
    ;<code class="special">{pattern}</code>  开始另一项搜索，见 |<code class="badlink">//;</code>|

如果给出了 '-' 或 '+' 但是省略了 <code class="special">[num]</code>，会使用缺省的 1。
如果使用了 'e' 偏移，查找会成为 |<code class="badlink">inclusive</code>| 闭动作 (光标要到达的字符本身会包含
在操作里)。

示例:

<code class="section">模式                    光标位置        </code>
/test/+1                "test" 下一行，第一列
/test/e                 "test" 的后一个 't'
/test/s+2               "test" 中的 's'
/test/b-3               "test" 前的第三个字符

如果把这些命令之一和一个操作符连用，影响的是查找之前和之后光标位置之间的字符。
然而，如果使用了行偏移，影响的是两光标位置之间的所有整行。

一个演示如何查找一个模式并用另一个单词来更改匹配的例子:
<code class="example">        /foo<code class="special">&lt;CR&gt;</code>        查找 "foo"</code>
<code class="example">        c//e            修改从当前位置到匹配结尾的部分</code>
<code class="example">        bar<code class="special">&lt;Esc&gt;</code>        输入替换文本</code>
<code class="example">        //<code class="special">&lt;CR&gt;</code>          跳转到下一个相同匹配的开始</code>
<code class="example">        c//e            修改从当前位置到匹配结尾的部分</code>
<code class="example">        beep<code class="special">&lt;Esc&gt;</code>       输入替换文本</code>
<code class="example">                        等等。</code>

                                                        <b class="vimtag">*<a name="%2F%2F;">//;</a>*</b> <b class="vimtag">*<a name="E386">E386</a>*</b>
一个很特别的偏移是 ';' 后面接另一个查找命令。例如:
<code class="example"></code>
<code class="example">   /test 1/;/test</code>
<code class="example">   /test.*/+1;?ing?</code>
<code class="example"></code>
其中第一例会先找到下一个出现 "test 1" 的地方，然后寻找在它之后 "test" 的第一次
出现之处。

这就好象接连执行两次查找命令，不同之处在于:
- 它可以被当作操作符之后的单个移动命令。
- 以后的 "n" 或 "N" 命令基于第一个查找操作。
- 当有错误时光标原地不动。

                                                        <b class="vimtag">*<a name="last-pattern">last-pattern</a>*</b>
最近使用的模式和偏移会被记住。它们可以用来重复查找，而且查找的方向和计数都可以
修改。<code class="note">注意</code> Vim 会记住两个模式：一个是普通模式下查找命令用的，另一个是替代命令
":s" 用的。每次给出一个空白的模式时，都将用到前次使用模式。

'magic' 选项的值是和最近使用模式本身绑定的。如果你改变了 'magic'，最近使用模式
的解释方法不会改变。'ignorecase' 选项就不同。当 'ignorecase' 的值改变时，该模
式会匹配另外的文本。

如果你设定了 'hlsearch' 选项，所有最近使用的查找模式的匹配点都会高亮。

要清除最近使用的查找模式:
<code class="example">        :let @/ = ""</code>
这不会把该模式设置为空串，因为那样会匹配所有的东西。该模式是真的清除了，就象
Vim 刚刚启动一样。

查找通常会跳过那些不移动光标位置的匹配。下一次匹配是开始于下一个字符还是在跳过
那些匹配之后取决于 'cpoptions' 选项中的 'c' 标志位。见 |<code class="badlink">cpo-c</code>|。
             带 'c' 标志位:   "/..." 前进 1 至 3 个字符
           不带 'c' 标志位:   "/..." 前进 1 个字符
带 'c' 标志位对应结果难以完全确定，因为查找可以从第一列开始，忽略任何匹配，直
到找到超过光标位置的匹配为止。

如果反向寻找，要是如上所述 'cpoptions' 里包含了 'c' 标志位的话，从行首开始搜
索，使用光标位置之前的最后一个匹配。

在 Vi 里 ":tag" 命令会将最近查找模式设定为要搜索的标签。除非 'cpoptions' 选项
中包括 't' 标志位，Vim 不会这样做，前次查找模式仍然被记住。查找模式总被存入查
找历史记录。

如果 'wrapscan' 选项的值为真 (缺省) 的话，查找会在缓冲区的结尾折返到首部。如果
不为真，反向查找会在开始处停止；正向查找会在结尾处停止。如果该选项为真但找不到
该模式，会给出一个错误信息："pattern not found"，光标原地不动。如果不为真，取
决于查找的方向是正向还是反向，给出的信息是："search hit BOTTOM without match"
或者 "search hit TOP without match"。如果该选项为真，当查找折返时会分别显示：
"search hit TOP, continuing at BOTTOM" 或 "search hit BOTTOM, continuing at
TOP"。此时，消息可以用设定 'shortmess' 选项里的 's' 标志位来关闭。该信息的显示
会使用 'w' 的高亮方法 (缺省: 突出)。

                                                        <b class="vimtag">*<a name="search-range">search-range</a>*</b>
用 \%&gt;l 项目，你可以限定 "/" 命令查找的范围。例如，要在行 199 之下行 300 之上
搜索单词 "limit":
<code class="example">        /\%&gt;199l\%&lt;300llimit</code>
另见 |<code class="badlink">/\%&gt;l</code>|。

另一个方法是使用 ":substitute" 命令并与 'c' 联用。例:
<code class="example">   :.,300s/Pattern//gc</code>
这个命令会从光标所在处开始查找 "Pattern"，直到第 300 行。在匹配处，你会被提示
键入一个字符。键入 'q' 终止；键入 'n' 找下一个匹配。

"*"，"#"，"g*" 和 "g#" 命令依照以下的次序查找在光标附近的一个单词，使用以下最
先找到的那个:
- 光标所在的关键字。
- 同行的光标右侧的第一个关键字。
- 光标下的第一个字串 (WORD)。
- 同行的光标右侧的第一个字串 (WORD)。
关键字只能包括字母和 'iskeyword' 中的字符。字串 (WORD) 可以包括任何非空白
(<code class="special">&lt;Tab&gt;</code> 和／或 <code class="special">&lt;Space&gt;</code>)。
<code class="note">备注</code> 如果你用十个指头打字的话，这些字符是很容易记住的：
"#" 在你的左手中指上 (向左上查找)；"*" 在你的右手中指上 (向右下查找)。
(不过，这取决于你的键盘布局)。

</pre><hr class="doubleline" /><pre>
<h4>2. 模式的定义                           <b class="vimtag">*<a name="search-pattern">search-pattern</a>*</b> <b class="vimtag">*<a name="pattern">pattern</a>*</b> <b class="vimtag">*<a name="[pattern]">[pattern]</a>*</b></h4>                                        <b class="vimtag">*<a name="regular-expression">regular-expression</a>*</b> <b class="vimtag">*<a name="regexp">regexp</a>*</b> <b class="vimtag">*<a name="Pattern">Pattern</a>*</b>
                                        <b class="vimtag">*<a name="E76">E76</a>*</b> <b class="vimtag">*<a name="E383">E383</a>*</b> <b class="vimtag">*<a name="E476">E476</a>*</b>

头一道菜已经在用户手册的第 27 章 |<a class="vim-doc" href="usr_27.html">usr_27.txt</a>| 上过了。

                                                <b class="vimtag">*<a name="%2Fbar">/bar</a>*</b> <b class="vimtag">*<a name="%2F\bar">/\bar</a>*</b> <b class="vimtag">*<a name="%2Fpattern">/pattern</a>*</b>
1. 一个模式 (pattern) 是由 "\|" 分隔开的一个或多个分支 (branch)。它可以匹配其
   中的任何一个分支匹配的文本。例如："foo\|beep" 可以匹配 "foo" 或 "beep"。如
   果超过一个分支可以匹配，选用其中的第一个。

   pattern ::=      branch
                或  branch \| branch
                或  branch \| branch \| branch
                等。

                                                <b class="vimtag">*<a name="%2Fbranch">/branch</a>*</b> <b class="vimtag">*<a name="%2F\&">/\&amp;</a>*</b>
2. 一个分支是一个或多个被 "\&amp;" 分隔的邻接。它匹配最后一个邻接，但仅仅当前面所
   的邻接也在同样位置匹配。例:
        "foobeep\&amp;..." 匹配 "foobeep" 中的 "foo"。
        ".<b class="vimtag">*<a name="Peter\&.">Peter\&amp;.</a>*</b>Bob" 匹配同时包括 "Peter" 和 "Bob" 的一行

   branch ::=       concat
                或  concat \&amp; concat
                或  concat \&amp; concat \&amp; concat
                等。

                                                <b class="vimtag">*<a name="%2Fconcat">/concat</a>*</b>
3. 一个邻接 (concat) 是一或多个相邻的组件 (piece)。它匹配第一个组件，后接第二
   个组件的匹配，等等。例如: "f[0-9]b"，先匹配 "f"，然后是一个数位，接着 "b"。

   concat  ::=      piece
                或  piece piece
                或  piece piece piece
                等。

                                                <b class="vimtag">*<a name="%2Fpiece">/piece</a>*</b>
4. 一个组件是一个匹配原 (atom)，后面可能带一个倍数 (multi)，用来表示该匹配原匹
   配的次数。例如："a*" 匹配任意个 "a" 组成的序列: ""，"a"，"aa" 等。参见
   |<code class="badlink">/multi</code>|。

   piece   ::=      atom
                或  atom  multi

                                                <b class="vimtag">*<a name="%2Fatom">/atom</a>*</b>
5. 一个匹配原可以是一个很长的条目列表中的一个。许多匹配原用来匹配文本中的一个
   字符，通常是一个普通的字符或字符类。也可以用圆括号来将一个模式变成一个匹配
   原。下面的 "\z(\)" 构造仅用在语法高亮中。

   atom    ::=      ordinary-atom               |<code class="badlink">/ordinary-atom</code>|
                或  \( pattern \)               |<code class="badlink">/\(</code>|
                或  \%( pattern \)              |<code class="badlink">/\%(</code>|
                或  \z( pattern \)              |<code class="badlink">/\z(</code>|


</pre><hr class="doubleline" /><pre>
<h4>3. 魔术                                                         <b class="vimtag">*<a name="%2Fmagic">/magic</a>*</b></h4>
某些字符在模式中是按本义出现的。它们匹配自身。然而，当前面有一个反斜杠时，这些
字符具有特殊的含义。

另外一些字符即使没有反斜杠也代表特殊的意思。它们反而需要一个反斜杠来匹配按本义
出现的自身。

一个字符是否按本义出现取决于 'magic' 选项以及下面将解释的条目。
                                                        <b class="vimtag">*<a name="%2F\m">/\m</a>*</b> <b class="vimtag">*<a name="%2F\M">/\M</a>*</b>
使用 "\m" 会使得其后的模式的解释方式就如同设定了 'magic' 选项一样。而且将忽略
'magic' 选项的实际值。
使用 "\M" 会使得其后的模式的解释方式就如同设定了 'nomagic' 选项一样。
                                                        <b class="vimtag">*<a name="%2F\v">/\v</a>*</b> <b class="vimtag">*<a name="%2F\V">/\V</a>*</b>
使用 "\v" 会使得其后的模式中所有 '0'-'9'，'a'-'z'，'A'-'Z' 和 '_' 之外的字符都
当作特殊字符解释。"very magic"

使用 "\V" 会使得其后的模式中只有反斜杠有特殊的意义。"very nomagic"

示例:
<code class="section">在这之后: \v       \m       \M       \V         匹配 </code>
                'magic' 'nomagic'
          $        $        $        \$         匹配行尾
          .        .        \.       \.         匹配任何字符
          *        *        \*       \*         前面匹配原的任意次重复
          ()       \(\)     \(\)     \(\)       组成为单个匹配原
          |        \|       \|       \|         分隔可选分支
          \a       \a       \a       \a         字母字符
          \\       \\       \\       \\         反斜杠 (按本义)
          \.       \.       .        .          英文句号 (按本义)
          \{       {        {        {          '{'  (按本义)
          a        a        a        a          'a'  (按本义)

<code class="special"><code class="special">{仅 Vim 支持 \m，\M，\v 和 \V}</code></code>

建议始终将 'magic' 选项保持在缺省值 －  'magic'。这可以避免移植性的麻烦。要使
模式不受该选项值的影响，在模式前面加上 "\m" 或 "\M"。

</pre><hr class="doubleline" /><pre>
<h4>4. 模式项总览                                           <b class="vimtag">*<a name="pattern-overview">pattern-overview</a>*</b></h4>
倍数总览。                                              <b class="vimtag">*<a name="%2Fmulti">/multi</a>*</b> <b class="vimtag">*<a name="E61">E61</a>*</b> <b class="vimtag">*<a name="E62">E62</a>*</b>
更多解释和示例见下，点击链接即可。                                      <b class="vimtag">*<a name="E64">E64</a>*</b>

<code class="section">          倍数 </code>
<code class="section">     'magic' 'nomagic'  匹配前面的匹配原 </code>
|<code class="badlink">/star</code>| *       \*      0 或更多        尽可能多
|<code class="badlink">/\+</code>|   \+      \+      1 或更多        尽可能多 (*)
|<code class="badlink">/\=</code>|   \=      \=      0 或 1          尽可能多 (*)
|<code class="badlink">/\?</code>|   \?      \?      0 或 1          尽可能多 (*)

|<code class="badlink">/\{</code>|   \<code class="special">{n,m}</code>  \<code class="special">{n,m}</code>  n 到 m          尽可能多 (*)
        \<code class="special">{n}</code>    \<code class="special">{n}</code>    n               准确 (*)
        \<code class="special">{n,}</code>   \<code class="special">{n,}</code>   最少 n          尽可能多 (*)
        \<code class="special">{,m}</code>   \<code class="special">{,m}</code>   0 到 m          尽可能多 (*)
        \<code class="special">{}</code>     \<code class="special">{}</code>     0 或更多        尽可能多 (和 * 相同) (*)

|<code class="badlink">/\{-</code>|  \<code class="special">{-n,m}</code> \<code class="special">{-n,m}</code> n 到 m          尽可能少 (*)
        \<code class="special">{-n}</code>   \<code class="special">{-n}</code>   n               准确 (*)
        \<code class="special">{-n,}</code>  \<code class="special">{-n,}</code>  最少 n          尽可能少 (*)
        \<code class="special">{-,m}</code>  \<code class="special">{-,m}</code>  0 到 m          尽可能少 (*)
        \<code class="special">{-}</code>    \<code class="special">{-}</code>    0 或更多        尽可能少 (*)

                                                        <b class="vimtag">*<a name="E59">E59</a>*</b>
|<code class="badlink">/\@&gt;</code>|  \@&gt;     \@&gt;     1，要求完整的模式匹配 (不能回溯) (*)
|<code class="badlink">/\@=</code>|  \@=     \@=     无，但要求匹配 |<code class="badlink">/zero-width</code>| (*)
|<code class="badlink">/\@!</code>|  \@!     \@!     无，但要求_不_匹配 |<code class="badlink">/zero-width</code>| (*)
|<code class="badlink">/\@&lt;=</code>| \@&lt;=    \@&lt;=    无，但要求反向匹配 |<code class="badlink">/zero-width</code>| (*)
|<code class="badlink">/\@&lt;!</code>| \@&lt;!    \@&lt;!    无，但要其反向_不_匹配 |<code class="badlink">/zero-width</code>| (*)

(*) <code class="special"><code class="special">{Vi 无此功能}</code></code>


普通匹配原总览。                                        <b class="vimtag">*<a name="%2Fordinary-atom">/ordinary-atom</a>*</b>
更多解释和示例见下，点击链接即可。

<code class="section">          普通匹配原 </code>
<code class="section">      magic   nomagic   匹配 </code>
|<code class="badlink">/^</code>|    ^       ^       行首 (在模式起始) |<code class="badlink">/zero-width</code>|
|<code class="badlink">/\^</code>|   \^      \^      按本义出现的 '^'
|<code class="badlink">/\_^</code>|  \_^     \_^     行首 (用于任何地方) |<code class="badlink">/zero-width</code>|
|<code class="badlink">/$</code>|    $       $       行尾 (在模式结尾) |<code class="badlink">/zero-width</code>|
|<code class="badlink">/\$</code>|   \$      \$      按本义出现的 '$'
|<code class="badlink">/\_$</code>|  \_$     \_$     行尾 (用于任何地方) |<code class="badlink">/zero-width</code>|
|<code class="badlink">/.</code>|    .       \.      任何单个字符 (不包括换行)
|<code class="badlink">/\_.</code>|  \_.     \_.     任何单个字符，包括换行
|<code class="badlink">/\&lt;</code>|   \&lt;      \&lt;      单词的起始 |<code class="badlink">/zero-width</code>|
|<code class="badlink">/\&gt;</code>|   \&gt;      \&gt;      单词的结尾 |<code class="badlink">/zero-width</code>|
|<code class="badlink">/\zs</code>|  \zs     \zs     任何字符，设定匹配部分起始
|<code class="badlink">/\ze</code>|  \ze     \ze     任何字符，设定匹配部分结束
|<code class="badlink">/\%^</code>|  \%^     \%^     文件首 |<code class="badlink">/zero-width</code>|            <b class="vimtag">*<a name="E71">E71</a>*</b>
|<code class="badlink">/\%$</code>|  \%$     \%$     文件尾 |<code class="badlink">/zero-width</code>|
|<code class="badlink">/\%V</code>|  \%V     \%V     可视区域内 |<code class="badlink">/zero-width</code>|
|<code class="badlink">/\%#</code>|  \%#     \%#     光标位置 |<code class="badlink">/zero-width</code>|
|<code class="badlink">/\%'m</code>| \%'m    \%'m    位置标记 m 的位置 |<code class="badlink">/zero-width</code>|
|<code class="badlink">/\%l</code>|  \%23l   \%23l   在第 23 行 |<code class="badlink">/zero-width</code>|
|<code class="badlink">/\%c</code>|  \%23c   \%23c   在第 23 列 |<code class="badlink">/zero-width</code>|
|<code class="badlink">/\%v</code>|  \%23v   \%23v   在虚拟第 23 列 |<code class="badlink">/zero-width</code>|

字符类 <code class="special"><code class="special">{Vi 无此功能}</code></code>:                           <b class="vimtag">*<a name="%2Fcharacter-classes">/character-classes</a>*</b>
|<code class="badlink">/\i</code>|   \i      \i      标识符字符 (见 'isident' 选项)
|<code class="badlink">/\I</code>|   \I      \I      同 "\i"，但不包括数字字符
|<code class="badlink">/\k</code>|   \k      \k      关键字字符 (见 'iskeyword' 选项)
|<code class="badlink">/\K</code>|   \K      \K      同 "\k"，但不包括数字字符
|<code class="badlink">/\f</code>|   \f      \f      文件名字符 (见 'isfname' 选项)
|<code class="badlink">/\F</code>|   \F      \F      同 "\f"，但不包括数字字符
|<code class="badlink">/\p</code>|   \p      \p      可显示字符 (见 'isprint' 选项)
|<code class="badlink">/\P</code>|   \P      \P      同 "\p"，但不包括数字字符
|<code class="badlink">/\s</code>|   \s      \s      空白字符； <code class="special">&lt;Space&gt;</code> 和 <code class="special">&lt;Tab&gt;</code>
|<code class="badlink">/\S</code>|   \S      \S      非空白字符：\s 之反
|<code class="badlink">/\d</code>|   \d      \d      数位:                   [0-9]
|<code class="badlink">/\D</code>|   \D      \D      非数位:                 [^0-9]
|<code class="badlink">/\x</code>|   \x      \x      十六进制数位:           [0-9A-Fa-f]
|<code class="badlink">/\X</code>|   \X      \X      非十六进制数位:         [^0-9A-Fa-f]
|<code class="badlink">/\o</code>|   \o      \o      八进制数位:             [0-7]
|<code class="badlink">/\O</code>|   \O      \O      非八进制数位:           [^0-7]
|<code class="badlink">/\w</code>|   \w      \w      单词字符:               [0-9A-Za-z_]
|<code class="badlink">/\W</code>|   \W      \W      非单词字符:             [^0-9A-Za-z_]
|<code class="badlink">/\h</code>|   \h      \h      单词首字符:             [A-Za-z_]
|<code class="badlink">/\H</code>|   \H      \H      非单词首字符:           [^A-Za-z_]
|<code class="badlink">/\a</code>|   \a      \a      英文字母字符:           [A-Za-z]
|<code class="badlink">/\A</code>|   \A      \A      非英文字母字符:         [^A-Za-z]
|<code class="badlink">/\l</code>|   \l      \l      小写字符:               [a-z]
|<code class="badlink">/\L</code>|   \L      \L      非小写字符:             [^a-z]
|<code class="badlink">/\u</code>|   \u      \u      大写字符:               [A-Z]
|<code class="badlink">/\U</code>|   \U      \U      非大写字符              [^A-Z]
|<code class="badlink">/\_</code>|   \_x     \_x     其中 x 可以是以上任意一个字符：对应字符类加上换行
 (字符类结束)

|<code class="badlink">/\e</code>|   \e      \e      <code class="special">&lt;Esc&gt;</code>
|<code class="badlink">/\t</code>|   \t      \t      <code class="special">&lt;Tab&gt;</code>
|<code class="badlink">/\r</code>|   \r      \r      <code class="special">&lt;CR&gt;</code>
|<code class="badlink">/\b</code>|   \b      \b      <code class="special">&lt;BS&gt;</code>
|<code class="badlink">/\n</code>|   \n      \n      行尾符
|<code class="badlink">/~</code>|    ~       \~      上次给出的替代字符串
|<code class="badlink">/\1</code>|   \1      \1      第一个 \(\) 匹配的字符 <code class="special"><code class="special">{Vi 无此功能}</code></code>
|<code class="badlink">/\2</code>|   \2      \2      如 "\1"，但用第二个 \(\)
           ...
|<code class="badlink">/\9</code>|   \9      \9      如 "\1"，但用第九个 \(\)
                                                                <b class="vimtag">*<a name="E68">E68</a>*</b>
|<code class="badlink">/\z1</code>|  \z1     \z1     仅用于语法高亮，见 |<code class="badlink">:syn-ext-match</code>|
           ...
|<code class="badlink">/\z1</code>|  \z9     \z9     仅用于语法高亮，见 |<code class="badlink">:syn-ext-match</code>|

        x       x       一个没有特殊含义的字符匹配其自身

|<code class="badlink">/[]</code>|   []      \[]     [] 内指定的任何字符之一
|<code class="badlink">/\%[]</code>| \%[]    \%[]    一个可选匹配原的序列

|<code class="badlink">/\c</code>|   \c      \c      忽略大小写，不使用 'ignorecase' 选项
|<code class="badlink">/\C</code>|   \C      \C      匹配大小写，不使用 'ignorecase' 选项
|<code class="badlink">/\m</code>|   \m      \m      对之后模式中字符打开 'magic' 选项
|<code class="badlink">/\M</code>|   \M      \M      对之后模式中字符关闭 'magic' 选项
|<code class="badlink">/\v</code>|   \v      \v      对之后模式中字符设定 'magic' 选项为 "very magic"
|<code class="badlink">/\V</code>|   \V      \V      对之后模式中字符设定 'magic' 选项为 "very nomagic"
|<code class="badlink">/\Z</code>|   \Z      \Z      忽略 Unicode 中的 "组合用字符"，对于搜索带元音的希伯来
                        和阿拉伯文本有用。

|<code class="badlink">/\%d</code>|  \%d     \%d     匹配用十进制指定的字符 (如 \%d123)
|<code class="badlink">/\%x</code>|  \%x     \%x     匹配用十六进制指定的字符 (如 \%x2a)
|<code class="badlink">/\%o</code>|  \%o     \%o     匹配用八进制指定的字符 (如 \%o040)
|<code class="badlink">/\%u</code>|  \%u     \%u     匹配指定的多字节字符 (如 \%u20ac)
|<code class="badlink">/\%U</code>|  \%U     \%U     匹配指定的巨大多字节字符 (如 \%U12345678)

<code class="section">示例                    匹配 </code>
\&lt;\I\i*         或
\&lt;\h\w*
\&lt;[a-zA-Z_][a-zA-Z0-9_]*
                        一个标识符 (例如，在一个 C 程序里)。

\(\.$\|\. \)            一个英文句号后跟 <code class="special">&lt;EOL&gt;</code> 或一个空格。

[.!?][])"']*\($\|[ ]\)  一个匹配英文句子结尾的模式。几乎和 ")" 的定义相同。

cat\Z                   匹配 "cat" 和 "càt" ("a" 后跟 0x0300)
                        不匹配 "càt" (字符 0x00e0)，即使它们看起来可能一样。


</pre><hr class="doubleline" /><pre>
<h4>5. 倍数项                                       <b class="vimtag">*<a name="pattern-multi-items">pattern-multi-items</a>*</b></h4>
一个匹配原后面可以跟一个表示该匹配原匹配次数和方式的修饰。这个修饰称为倍数。
在 |<code class="badlink">/multi</code>| 可以看到一个综述。

                                                <b class="vimtag">*<a name="%2Fstar">/star</a>*</b> <b class="vimtag">*<a name="%2F\star">/\star</a>*</b> <b class="vimtag">*<a name="E56">E56</a>*</b>
*       (在没有设定 'magic' 时使用 \*)
        匹配 0 或更多个前面的匹配原，尽可能多地匹配。
<code class="section">        示例     'nomagic'      匹配 </code>
        a*         a\*          ""、"a"、"aa"、"aaa" 等。
        .*         \.\*         任意，包括空串，不包括行尾符
        \_.*       \_.\*        匹配至缓冲区结束
        \_.*END    \_.\*END     匹配至缓冲区中最后一次出现 "END" 处，包括该
                                "END"

        特例: 当 "*" 用在模式的开头或者紧跟在 "^" 之后时，它匹配星号字符。

        要当心，重复匹配 "\_." 会包括大量的文本，因而可能会花很长时间。例如，
        "\_.*END" 匹配从当前位置开始到文件中最后一次出现 "END" 的地方。因为
        "*" 会尽可能多的匹配，它会先跳过到文件结束前的所有行，然后一次退一个字
        符以查找 "END"。

                                                        <b class="vimtag">*<a name="%2F\+">/\+</a>*</b> <b class="vimtag">*<a name="E57">E57</a>*</b>
\+      匹配一个或更多前面的匹配原。尽可能多。<code class="special"><code class="special">{Vi 无此功能}</code></code>
<code class="section">        例              匹配 </code>
        ^.\+$           任意空行
        \s\+            一个以上的空白字符

                                                        <b class="vimtag">*<a name="%2F\%20">/\=</a>*</b>
\=      匹配 0 或 1 个前面的匹配原。尽可能多。<code class="special"><code class="special">{Vi 无此功能}</code></code>
<code class="section">        例              匹配 </code>
        foo\=           "fo" 和 "foo"

                                                        <b class="vimtag">*<a name="%2F\?">/\?</a>*</b>
\?      和 \= 一样。不能和反向查找的 "?" 命令中使用。<code class="special"><code class="special">{Vi 无此功能}</code></code>

                                                <b class="vimtag">*<a name="%2F\{">/\{</a>*</b> <b class="vimtag">*<a name="E58">E58</a>*</b> <b class="vimtag">*<a name="E60">E60</a>*</b> <b class="vimtag">*<a name="E554">E554</a>*</b>
\<code class="special">{n,m}</code>  匹配 n 至 m 个前面的匹配原。尽可能多
\<code class="special">{n}</code>    匹配 n 个前面的匹配原
\<code class="special">{n,}</code>   匹配至少 n 个前面的匹配原。尽可能多
\<code class="special">{,m}</code>   匹配 0 至 m 个前面的匹配原。尽可能多
\<code class="special">{}</code>     匹配 0 个以上前面的匹配原。尽可能多 (和 * 等价)
                                                        <b class="vimtag">*<a name="%2F\{-">/\{-</a>*</b>
\<code class="special">{-n,m}</code> 匹配 n 至 m 个前面的匹配原。尽可能少
\<code class="special">{-n}</code>   匹配 n 个前面的匹配原
\<code class="special">{-n,}</code>  匹配至少 n 个前面的匹配原。尽可能少
\<code class="special">{-,m}</code>  匹配 0 至 m 个前面的匹配原。尽可能少
\<code class="special">{-}</code>    匹配 0 个以上前面的匹配原。尽可能少
        <code class="special"><code class="special">{Vi 没有这些}</code></code>

        n 和 m 是正的十进制数或零
                                                                <b class="vimtag">*<a name="non-greedy">non-greedy</a>*</b>
        如果一个 "-" 紧接在 "{" 之后，那么最短匹配优先算法将启用 (见下面的例
        子)。特别的，"\<code class="special">{-}</code>" 和 "*" 一样，但使用最短匹配优先算法。_不过_，更早
        开始的匹配比更短的匹配优先: "a\<code class="special">{-}</code>b" 匹配 "xaaab" 中的 "aaab"。

<code class="section">        示例                    匹配 </code>
        ab\<code class="special">{2,3}</code>c               "abbc" 或 "abbbc"
        a\<code class="special">{5}</code>                   "aaaaa"
        ab\<code class="special">{2,}</code>c                "abbc"、"abbbc"、"abbbbc" 等
        ab\<code class="special">{,3}</code>c                "ac"、"abc"、"abbc" 或 "abbbc"
        a[bc]\<code class="special">{3}</code>d              "abbbd"、"abbcd"、"acbcd"、"acccd" 等。
        a\(bc\)\<code class="special">{1,2}</code>d          "abcd" 或 "abcbcd"
        a[bc]\<code class="special">{-}</code>[cd]           "abcd" 中的 "abc"
        a[bc]*[cd]              "abcd" 中的 "abcd"

        } 之前可以加 (也可以不加) 一个反斜杠: \<code class="special">{n,m\}</code>。

                                                        <b class="vimtag">*<a name="%2F\@%20">/\@=</a>*</b>
\@=     零宽度匹配前面的匹配原。<code class="special"><code class="special">{Vi 无此功能}</code></code>
        类似于 Perl 中的 "(?=pattern)"。
<code class="section">        示例                    匹配 </code>
        foo\(bar\)\@=           "foobar" 中的 "foo"
        foo\(bar\)\@=foo        空
                                                        <b class="vimtag">*<a name="%2Fzero-width">/zero-width</a>*</b>
        "\@=" (或 "^"，"$"，"\<code class="special">&lt;"，"\&gt;</code>") 的匹配不包括任何字符。这些字符仅仅是用
        来检查匹配是否存在。这很容易搞错，因为后续的项会在同样位置作匹配。上面
        的最后一个例子不会匹配 "foobarfoo"，因为 Vim 会尝试在 "bar" 匹配的同样
        地方匹配 "foo"。

        <code class="note">注意</code> 使用 "\&amp;" 同使用 "\@=" 是一样的: "foo\&amp;.." 等于 "\(foo\)\@=.."。
        但用 "\&amp;" 容易些，你可以省了那些括号。


                                                        <b class="vimtag">*<a name="%2F\@!">/\@!</a>*</b>
\@!     零宽度否匹配，亦即，要求前面的匹配原在当前位置_不_匹配。
        |<code class="badlink">/zero-width</code>| <code class="special"><code class="special">{Vi 无此功能}</code></code>
        类似于 Perl 中的 '(?!pattern)"。
<code class="section">        示例                    匹配 </code>
        foo\(bar\)\@!           任意后面不带 "bar" 的 "foo"
        a.\<code class="special">{-}</code>p\@!              "a"，"ap"，"app" 等。后面不带 "p"
        if \(\(then\)\@!.\)*$   "if " 后面无跟随 "then"

        使用 "\@!" 要小心，因为很多地方一个模式可以不匹配。"a.*p\@!" 会匹配一
        个 "a" 直到行尾，因为 ".*" 匹配所有行内的字符，而 "p" 不在行尾匹配。
        "a.\<code class="special">{-}</code>p\@!" 则可以匹配 "a"，"ap"，"aap" 等中的一项，只要它们不再紧跟
        另外一个 "p"，这是因为 "." 可以匹配 "p" 而 "p\@!" 不匹配这个 "p" 的后
        面。

        你不能用 "\@!" 去寻找匹配所在位置之前的否匹配。"\(foo\)\@!bar" 会匹配
        "foobar" 中的 "bar"，因为在 "bar" 匹配的位置上，"foo" 并不匹配。如果
        不想匹配 "foobar"，你可以尝试 "\(foo\)\@!...bar"，但它不能匹配在行首出
        现的 "bar"。最好的方法是用 "\(foo\)\@&lt;!bar"。

                                                        <b class="vimtag">*<a name="%2F\@%3C%20">/\@&lt;=</a>*</b>
\@&lt;=    零宽度反向匹配。要求前面的匹配原紧贴在后面的模式之前匹配。
        |<code class="badlink">/zero-width</code>| <code class="special"><code class="special">{Vi 无此功能}</code></code>
        类似于 Perl 的 '(?&lt;=pattern)"，但是 Vim 允许使用非固定宽度的模式。
<code class="section">        示例                    匹配 </code>
        \(an\_s\+\)\@&lt;=file     在 "an" 和若干个空白或者行尾符之后的 "file"。
        为了提高性能，最好避免这个倍数项。可以用 "\zs" 替代 |<code class="badlink">/\zs</code>|。要匹配
        上述的示例：
<code class="example">                an\_s\+\zsfile</code>
<code class="example"></code>
        "\@&lt;=" 和 "\@&lt;!" 检查刚好在其后模式匹配点之前出现的匹配文本。理论上，
        这些匹配可以从当前位置之前的任何地方开始，为了限制所需的时间，只有其后
        匹配所在的行和它上一行 (如果有上一行的话) 会被检索。这对大多数的应用来
        说已经足够，而且也不会减慢速度太多。
        在 "\@&lt;=" 和 "\@&lt;!" 之后的模式其实先被匹配，所以不能用 "\1" 之类的结构
        来引用零宽度匹配原中的 \(\)。反过来倒是可以的。
<code class="section">        示例                    匹配 </code>
        \1\@&lt;=,\([a-z]\+\)      ",abc" in "abc,abc"

                                                        <b class="vimtag">*<a name="%2F\@%3C!">/\@&lt;!</a>*</b>
\@&lt;!    零宽度反向否匹配，要求前面的匹配原_不_紧贴在其后的模式之前匹配。换而言
        之，如果在当前行或之前的一行中没有任何位置这个匹配原可以匹配而且它的匹
        配文本刚好紧贴在其后模式的匹配点之前。|<code class="badlink">/zero-width</code>| <code class="special"><code class="special">{Vi 无此功能}</code></code>
        类似于 Perl 的 '(?&lt;!pattern)"，但是 Vim 允许使用非固定宽度的模式。
        该倍数所引用的匹配原必须紧贴在其后匹配之前，所以这个匹配原可以用 ".*"
        结尾。警告：该倍数项可能会很慢 (因为在匹配之前的许多位置都要被检查)。
<code class="section">        示例                    匹配 </code>
        \(foo\)\@&lt;!bar          任何不在 "foobar" 中的 "bar"
        \(\/\/.*\)\@&lt;!in        不在 "//" 之后 (中间可以有间隔) 的 "in"

                                                        <b class="vimtag">*<a name="%2F\@%3E">/\@&gt;</a>*</b>
\@&gt;     匹配前面的匹配原时要求完整匹配 (不能回溯)。<code class="special"><code class="special">{Vi 无此功能}</code></code>
        类似于 Perl 中的 "(?&gt;pattern)"。
<code class="section">        示例            匹配 </code>
        \(a*\)\@&gt;a      无 ("a*" 用尽了所有的 "a"，后面不可能再有)

        试图匹配前面的匹配原，就如同匹配一个完整的模式那样。如果以后无法匹配，
        不会用较短的子模式或者任何其它的方法来重试该匹配原。<code class="note">注意</code>观察以下两者的
        不同: "a*b" 和 "a*ab" 都匹配 "aaab"，但是后者中的 "a*" 仅仅匹配前两个
        "a"。"\(a*\)\@&gt;ab" 不会匹配 "aaab"，因为 "a*" 匹配了 "aaa" (尽可能多
        的 "a")，导致 "ab" 无法匹配。


</pre><hr class="doubleline" /><pre>
<h4>6.  普通匹配原                                  <b class="vimtag">*<a name="pattern-atoms">pattern-atoms</a>*</b></h4>
一个普通匹配原可能是:

                                                        <b class="vimtag">*<a name="%2F^">/^</a>*</b>
^       在模式起点或在 "\|"，"\("，"\%("，"\n" 之后: 匹配行首；在其它位置匹配
        按本义出现的 '^' 字符。|<code class="badlink">/zero-width</code>|
<code class="section">        示例            匹配 </code>
        ^beep(          C 函数 "beep" 开始的地方 (很可能)。

                                                        <b class="vimtag">*<a name="%2F\^">/\^</a>*</b>
\^      匹配按本义出现的 '^' 字符。可以用于任何位置。

                                                        <b class="vimtag">*<a name="%2F\_^">/\_^</a>*</b>
\_^     匹配行首。|<code class="badlink">/zero-width</code>| 可以用于任何位置。
<code class="section">        示例            匹配 </code>
        \_s*\_^foo      空白字符及空行，后接行首的 "foo"。

                                                        <b class="vimtag">*<a name="%2F$">/$</a>*</b>
$       在模式终点或 "\|"、"\)" 或 "\n" (打开 'magic' 的话) 之前: 匹配行尾
        <code class="special">&lt;EOL&gt;</code>；其它位置，匹配按本义出现的 '$' 字符。|<code class="badlink">/zero-width</code>|

                                                        <b class="vimtag">*<a name="%2F\$">/\$</a>*</b>
\$      匹配按本义出现的 '$' 字符。可以用于任何位置。

                                                        <b class="vimtag">*<a name="%2F\_$">/\_$</a>*</b>
\_$     匹配行尾。|<code class="badlink">/zero-width</code>|  可以用于任何位置。<code class="note">注意</code>："a\_$b" 永远无法匹
        配，因为 "b" 不能匹配行尾符。可以使用 "a\nb" 代替 |<code class="badlink">/\n</code>|。
<code class="section">        示例            匹配 </code>
        foo\_$\_s*      "foo" 在行尾，后接空白字符及空行

.       ('nomagic' 的情形: \.)                          <b class="vimtag">*<a name="%2F.">/.</a>*</b> <b class="vimtag">*<a name="%2F\.">/\.</a>*</b>
        匹配任何单个字符，不包括行尾符。

                                                        <b class="vimtag">*<a name="%2F\_.">/\_.</a>*</b>
\_.     匹配任何单个字符或行尾符。当心："\_.*" 会一直匹配到缓冲区结尾！

                                                        <b class="vimtag">*<a name="%2F\%3C">/\&lt;</a>*</b>
\&lt;      匹配单词起点：下一个字符是单词的首字符。'iskeyword' 选项指定哪些是组成
        单词的字符。|<code class="badlink">/zero-width</code>|

                                                        <b class="vimtag">*<a name="%2F\%3E">/\&gt;</a>*</b>
\&gt;      匹配单词终点：前一个字符是单词的尾字符。'iskeyword' 选项指定哪些是组成
        单词的字符。|<code class="badlink">/zero-width</code>|

                                                        <b class="vimtag">*<a name="%2F\zs">/\zs</a>*</b>
\zs     匹配任何位置，并将匹配起始处置于该处: 下一个字符将是整个匹配的第一个字
        符。|<code class="badlink">/zero-width</code>|
        例如:
<code class="example">                "^\s*\zsif"</code>
        匹配行首的 "if"，忽略前导的空白字符。
        可以使用多次，但实际使用最后一次在匹配的分支里遇到的。例如:
<code class="example">                /\(.\<code class="special">{-}</code>\zsFab\)\<code class="special">{3}</code></code>
        找到第三次出现的 "Fab"。
        <code class="special"><code class="special">{Vi 无此功能}</code></code> <code class="special"><code class="special">{仅当编译时加入 +syntax 特性才可用}</code></code>
                                                        <b class="vimtag">*<a name="%2F\ze">/\ze</a>*</b>
\ze     匹配任何位置，并将匹配结尾处置于该处: 前一个字符将是整个匹配的最后一个
        字符。|<code class="badlink">/zero-width</code>|
        可以使用多次，但实际使用最后一次在匹配的分支里遇到的。
        例如: "end\ze\(if\|for\)" 匹配 "endif" 和 "endfor" 中的 "end"。
        <code class="special"><code class="special">{Vi 无此功能}</code></code> <code class="special"><code class="special">{仅当编译时加入 +syntax 特性才可用}</code></code>

                                                <b class="vimtag">*<a name="%2F\%^">/\%^</a>*</b> <b class="vimtag">*<a name="start-of-file">start-of-file</a>*</b>
\%^     匹配文件头。当用于一个字符串时，匹配字符串起始处。<code class="special"><code class="special">{Vi 无此功能}</code></code>
        例如，要查找一个文件中首次出现 "VIM" 的地方:
<code class="example">                /\%^\_.\<code class="special">{-}</code>\zsVIM</code>

                                                <b class="vimtag">*<a name="%2F\%$">/\%$</a>*</b> <b class="vimtag">*<a name="end-of-file">end-of-file</a>*</b>
\%$     匹配文件尾。当用于一个字符串时，匹配字符串结束处。<code class="special"><code class="special">{Vi 无此功能}</code></code>
        <code class="note">注意</code> 下面的模式不匹配文件中的最后一个 "VIM":
<code class="example">                /VIM\_.\<code class="special">{-}</code>\%$</code>
        它会找到下一个 VIM，因为其后的部分总会匹配。这样才能匹配文件中的最后一
        个 "VIM":
<code class="example">                /VIM\ze\(\(VIM\)\@!\_.\)*\%$</code>
        这里使用了 |<code class="badlink">/\@!</code>| 来确定在首个 "VIM" 之后_无法_再次匹配 "VIM"。
        从文件尾部反向搜索会容易些！

                                                <b class="vimtag">*<a name="%2F\%V">/\%V</a>*</b>
\%V     在可视区域内匹配。可视模式停止后，在 |<code class="badlink">gv</code>| 将会重新选择的区域内匹配。
        这是一个零宽度 |<code class="badlink">/zero-width</code>| 匹配。要确保整个模式都在可视区域里，把本
        匹配原放在匹配模式的开始和结尾处，例如:
<code class="example">                /\%Vfoo.*bar\%V</code>
        只能用于当前缓冲区。

                                                <b class="vimtag">*<a name="%2F\%%23">/\%#</a>*</b> <b class="vimtag">*<a name="cursor-position">cursor-position</a>*</b>
\%#     匹配光标位置。仅对显示于窗口内的缓冲区有效。<code class="special"><code class="special">{Vi 无此功能}</code></code>
        警 告: 如果使用了该模式之后光标被移动，结果不再有效，Vim 不会自动更新
        匹配。这对语法高亮和 'hlsearch' 很重要。换言之: 在光标移动时显示并不因
        此而更新。Vim 只对行被修改 (整行被更新) 或用户使用 |<code class="badlink">CTRL-L</code>| 命令时 (整
        个屏幕被更新) 进行更新。例如，要高亮显示光标下的单词:
<code class="example">                /\k<b class="vimtag">*<a name="\%%23\k">\%#\k</a>*</b></code>
        当设定 'hlsearch' 时，移动光标并作若干更改，你就能清楚地看到更新在何时
        进行。

                                                <b class="vimtag">*<a name="%2F\%'m">/\%'m</a>*</b> <b class="vimtag">*<a name="%2F\%%3C'm">/\%&lt;'m</a>*</b> <b class="vimtag">*<a name="%2F\%%3E'm">/\%&gt;'m</a>*</b>
\%'m    匹配位置标记 m 的位置。
\%&lt;'m   匹配位置标记 m 之前的位置。
\%&gt;'m   匹配位置标记 m 之后的位置。
        例如，高亮位置标记 's 到 'e 的文本:
<code class="example">                /.\%&gt;'s.*\%&lt;'e..</code>
        <code class="note">注意</code> 在匹配里需要两个句号来包含位置标记 'e。这是因为 "\%&lt;'e" 匹配 'e
        位置标记之前的字符，而既然它是零宽度匹配 |<code class="badlink">/zero-width</code>|，它并不真正包含
        该字符。
        <code class="special"><code class="special">{Vi 无此功能}</code></code>
        警 告: 如果使用模式后移动了位置标记，结果不再有效。Vim 并不自动更新匹
        配。这和 "\%#" 里移动光标的情形类似 |<code class="badlink">/\%#</code>|。

                                                <b class="vimtag">*<a name="%2F\%l">/\%l</a>*</b> <b class="vimtag">*<a name="%2F\%%3El">/\%&gt;l</a>*</b> <b class="vimtag">*<a name="%2F\%%3Cl">/\%&lt;l</a>*</b>
\%23l   匹配指定的行。
\%&lt;23l  匹配指定行的上方 (行号更小)。
\%&gt;23l  匹配指定行的下方 (行号更大)。
        这三个匹配原可以用来匹配缓冲区内的特定行。"23" 可以是任何行号。第一行
        为 1。 <code class="special"><code class="special">{Vi 无此功能}</code></code>
        警 告：当插入和删除行时 Vim 不会自动更新匹配。这意味着语法高亮很快就会
        有问题。
        例如，要高亮显示光标所在行:
<code class="example">                :exe '/\%' . line(".") . 'l.*'</code>
        当设定 'hlsearch' 时，移动光标并作若干更改，你就能清楚地看到更新在何时
        进行。

                                                <b class="vimtag">*<a name="%2F\%c">/\%c</a>*</b> <b class="vimtag">*<a name="%2F\%%3Ec">/\%&gt;c</a>*</b> <b class="vimtag">*<a name="%2F\%%3Cc">/\%&lt;c</a>*</b>
\%23c   匹配指定的列。
\%&lt;23c  匹配指定列之前。
\%&gt;23c  匹配指定列之后。
        这三个匹配原可以用来匹配缓冲区或字符串中的特定列。"23" 可以是任何列
        号。第一列为 1。事实上，列以字节计算 (因此对多字节字符来说是不准确
        的)。 <code class="special"><code class="special">{Vi 无此功能}</code></code>
        警 告：当插入和删除字符时 Vim 并不自动更新匹配。这意味着语法高亮很快就
        会有问题。
        例如，要高亮显示光标所在列:
<code class="example">                :exe '/\%' . col(".") . 'c'</code>
        当设定 'hlsearch' 时，移动光标并作若干更改，你就能清楚地看到更新在何时
        进行。
        一个匹配第 44 列单个字节的例子:
<code class="example">                /\%&gt;43c.\%&lt;46c</code>
        <code class="note">注意</code>："\%&lt;46c" 匹配第 45 列，而 "." 匹配 44 列的一个字节。

                                                <b class="vimtag">*<a name="%2F\%v">/\%v</a>*</b> <b class="vimtag">*<a name="%2F\%%3Ev">/\%&gt;v</a>*</b> <b class="vimtag">*<a name="%2F\%%3Cv">/\%&lt;v</a>*</b>
\%23v   匹配指定虚拟列。
\%&lt;23v  匹配指定虚拟列之前。
\%&gt;23v  匹配指定虚拟列之后。
        这三个匹配原可以用来匹配缓冲区或字符串中指定的虚拟列。如果不是在匹配窗
        口内的缓冲区，使用当前窗口的选项值 (如 'tabstop')。
        "23" 可以是任何列号。第一列为 1。
        <code class="note">注意</code> 某些虚拟列位置永远无法被匹配，因为它们在制表符或其它占用超过一个
        屏幕位置的特殊字符的中间某处。<code class="special"><code class="special">{Vi 无此功能}</code></code>
        警 告：当插入和删除字符时 Vim 并不自动更新高亮的匹配。这意味着语法高亮
        很快就会有问题。
        例如，要高亮显示所有位于虚拟第 72 列之后的字符:
<code class="example">                /\%&gt;72v.*</code>
        当设定 'hlsearch' 时，移动光标并作若干更改，你就能清楚地看到更新在何时
        进行。
        要匹配直到第 17 列的文本:
<code class="example">                /.*\%17v</code>
        这里包括第 17 列，因为那是 "\%17v" 匹配的地方，即使这是一个零宽度
        |<code class="badlink">/zero-width</code>| 匹配。加上一个句号来匹配下一字符的效果完全一样:
<code class="example">                /.*\%17v.</code>
        下例同上，但如果第 17 列没有字符也同样匹配:
<code class="example">                /.*\%&lt;18v.</code>


字符类: <code class="special"><code class="special">{Vi 无此功能}</code></code>
\i      标识符字符 (见 'isident' 选项)                  <b class="vimtag">*<a name="%2F\i">/\i</a>*</b>
\I      同 "\i"，但不包括数字字符                       <b class="vimtag">*<a name="%2F\I">/\I</a>*</b>
\k      关键字字符 (见 'iskeyword' 选项)                <b class="vimtag">*<a name="%2F\k">/\k</a>*</b>
\K      同 "\k"，但不包括数字字符                       <b class="vimtag">*<a name="%2F\K">/\K</a>*</b>
\f      文件名字符 (见 'isfname' 选项)                  <b class="vimtag">*<a name="%2F\f">/\f</a>*</b>
\F      同 "\f"，但不包括数字字符                       <b class="vimtag">*<a name="%2F\F">/\F</a>*</b>
\p      可显示字符 (见 'isprint' 选项)                  <b class="vimtag">*<a name="%2F\p">/\p</a>*</b>
\P      同 "\p"，但不包括数字字符                       <b class="vimtag">*<a name="%2F\P">/\P</a>*</b>

<code class="note">备注</code>: 上面这些适用于多字节字符，而下面只匹配 ASCII 字符，因为它们由范围限定。

                                                <b class="vimtag">*<a name="whitespace">whitespace</a>*</b> <b class="vimtag">*<a name="white-space">white-space</a>*</b>
\s      空白字符； <code class="special">&lt;Space&gt;</code> 和 <code class="special">&lt;Tab&gt;</code>                     <b class="vimtag">*<a name="%2F\s">/\s</a>*</b>
\S      非空白字符：\s 之反                             <b class="vimtag">*<a name="%2F\S">/\S</a>*</b>
\d      数位:                           [0-9]           <b class="vimtag">*<a name="%2F\d">/\d</a>*</b>
\D      非数位:                         [^0-9]          <b class="vimtag">*<a name="%2F\D">/\D</a>*</b>
\x      十六进制数位:                   [0-9A-Fa-f]     <b class="vimtag">*<a name="%2F\x">/\x</a>*</b>
\X      非十六进制数位:                 [^0-9A-Fa-f]    <b class="vimtag">*<a name="%2F\X">/\X</a>*</b>
\o      八进制数位:                     [0-7]           <b class="vimtag">*<a name="%2F\o">/\o</a>*</b>
\O      非八进制数位:                   [^0-7]          <b class="vimtag">*<a name="%2F\O">/\O</a>*</b>
\w      单词字符:                       [0-9A-Za-z_]    <b class="vimtag">*<a name="%2F\w">/\w</a>*</b>
\W      非单词字符:                     [^0-9A-Za-z_]   <b class="vimtag">*<a name="%2F\W">/\W</a>*</b>
\h      单词首字符:                     [A-Za-z_]       <b class="vimtag">*<a name="%2F\h">/\h</a>*</b>
\H      非单词首字符:                   [^A-Za-z_]      <b class="vimtag">*<a name="%2F\H">/\H</a>*</b>
\a      英文字母字符:                   [A-Za-z]        <b class="vimtag">*<a name="%2F\a">/\a</a>*</b>
\A      非英文字母字符:                 [^A-Za-z]       <b class="vimtag">*<a name="%2F\A">/\A</a>*</b>
\l      小写字符:                       [a-z]           <b class="vimtag">*<a name="%2F\l">/\l</a>*</b>
\L      非小写字符:                     [^a-z]          <b class="vimtag">*<a name="%2F\L">/\L</a>*</b>
\u      大写字符:                       [A-Z]           <b class="vimtag">*<a name="%2F\u">/\u</a>*</b>
\U      非大写字符                      [^A-Z]          <b class="vimtag">*<a name="%2F\U">/\U</a>*</b>

        <code class="note">备注</code>: 使用匹配原比使用 [] 构造要快。

        <code class="note">备注</code>: 字符类不使用 'ignorecase'，"\c" 和 "\C" 的设定。

                <b class="vimtag">*<a name="%2F\_">/\_</a>*</b> <b class="vimtag">*<a name="E63">E63</a>*</b> <b class="vimtag">*<a name="%2F\_i">/\_i</a>*</b> <b class="vimtag">*<a name="%2F\_I">/\_I</a>*</b> <b class="vimtag">*<a name="%2F\_k">/\_k</a>*</b> <b class="vimtag">*<a name="%2F\_K">/\_K</a>*</b> <b class="vimtag">*<a name="%2F\_f">/\_f</a>*</b> <b class="vimtag">*<a name="%2F\_F">/\_F</a>*</b>
                <b class="vimtag">*<a name="%2F\_p">/\_p</a>*</b> <b class="vimtag">*<a name="%2F\_P">/\_P</a>*</b> <b class="vimtag">*<a name="%2F\_s">/\_s</a>*</b> <b class="vimtag">*<a name="%2F\_S">/\_S</a>*</b> <b class="vimtag">*<a name="%2F\_d">/\_d</a>*</b> <b class="vimtag">*<a name="%2F\_D">/\_D</a>*</b> <b class="vimtag">*<a name="%2F\_x">/\_x</a>*</b> <b class="vimtag">*<a name="%2F\_X">/\_X</a>*</b>
                <b class="vimtag">*<a name="%2F\_o">/\_o</a>*</b> <b class="vimtag">*<a name="%2F\_O">/\_O</a>*</b> <b class="vimtag">*<a name="%2F\_w">/\_w</a>*</b> <b class="vimtag">*<a name="%2F\_W">/\_W</a>*</b> <b class="vimtag">*<a name="%2F\_h">/\_h</a>*</b> <b class="vimtag">*<a name="%2F\_H">/\_H</a>*</b> <b class="vimtag">*<a name="%2F\_a">/\_a</a>*</b> <b class="vimtag">*<a name="%2F\_A">/\_A</a>*</b>
                <b class="vimtag">*<a name="%2F\_l">/\_l</a>*</b> <b class="vimtag">*<a name="%2F\_L">/\_L</a>*</b> <b class="vimtag">*<a name="%2F\_u">/\_u</a>*</b> <b class="vimtag">*<a name="%2F\_U">/\_U</a>*</b>
\_x     其中 x 为上面列出的可用字符之一：结果为对应字符类加上行尾符
(字符类结束)

\e      匹配 <code class="special">&lt;Esc&gt;</code>                                      <b class="vimtag">*<a name="%2F\e">/\e</a>*</b>
\t      匹配 <code class="special">&lt;Tab&gt;</code>                                      <b class="vimtag">*<a name="%2F\t">/\t</a>*</b>
\r      匹配 <code class="special">&lt;CR&gt;</code>                                       <b class="vimtag">*<a name="%2F\r">/\r</a>*</b>
\b      匹配 <code class="special">&lt;BS&gt;</code>                                       <b class="vimtag">*<a name="%2F\b">/\b</a>*</b>
\n      匹配行尾符                                      <b class="vimtag">*<a name="%2F\n">/\n</a>*</b>
        当对字符串而不是缓冲区进行匹配时，匹配一个按本义出现的换行字符。

~       匹配上次给出的替代字符串                        <b class="vimtag">*<a name="%2F%7E">/~</a>*</b> <b class="vimtag">*<a name="%2F\%7E">/\~</a>*</b>

\(\)    一个由转义的括号括起来的模式。                  <b class="vimtag">*<a name="%2F\(">/\(</a>*</b> <b class="vimtag">*<a name="%2F\(\)">/\(\)</a>*</b> <b class="vimtag">*<a name="%2F\)">/\)</a>*</b>
        例："\(^a\)" 匹配行首的 'a'。                   <b class="vimtag">*<a name="E51">E51</a>*</b> <b class="vimtag">*<a name="E54">E54</a>*</b> <b class="vimtag">*<a name="E55">E55</a>*</b>

\1      匹配和第一个 \( 和 \) 之间的子表达式的匹配文本  <b class="vimtag">*<a name="%2F\1">/\1</a>*</b> <b class="vimtag">*<a name="E65">E65</a>*</b>
        相同的字符串。 <code class="special"><code class="special">{Vi 无此功能}</code></code>
        例如: "\([a-z]\).\1" 匹配 "ata"，"ehe"，"tot" 等。
\2      类似于 "\1"，但使用第二子表达式，               <b class="vimtag">*<a name="%2F\2">/\2</a>*</b>
   ...                                                  <b class="vimtag">*<a name="%2F\3">/\3</a>*</b>
\9      类似于 "\1"，但使用第三子表达式。               <b class="vimtag">*<a name="%2F\9">/\9</a>*</b>
        <code class="note">备注</code>: 各组的标号是基于哪一个 "\(" 先出现 (自左至右)，而_非_哪一个先匹
        配。

\%(\)   一个由转义的括号括起来的模式。                  <b class="vimtag">*<a name="%2F\%(\)">/\%(\)</a>*</b> <b class="vimtag">*<a name="%2F\%(">/\%(</a>*</b> <b class="vimtag">*<a name="E53">E53</a>*</b>
        类似 \(\)，但不算作一个子表达式。这样做允许使用更多的群组，并且处理时
        会稍快些。
        <code class="special"><code class="special">{Vi 无此功能}</code></code>

x       一个没有特殊含义的单个字符，匹配其自身

                                                        <b class="vimtag">*<a name="%2F\">/\</a>*</b> <b class="vimtag">*<a name="%2F\\">/\\</a>*</b>
\x      一个反斜杠带一个没有特殊含义的单个字符，保留作将来的扩展

[]      ('nomagic' 的情形: \[])         <b class="vimtag">*<a name="%2F[]">/[]</a>*</b> <b class="vimtag">*<a name="%2F\[]">/\[]</a>*</b> <b class="vimtag">*<a name="%2F\_[]">/\_[]</a>*</b> <b class="vimtag">*<a name="%2Fcollection">/collection</a>*</b>
\_[]
        一个集合。一组由方括号括起来的字符。匹配集合中的任何一个字符。
<code class="section">        示例            匹配 </code>
        [xyz]           'x'、'y' 或 'z' 之一
        [a-zA-Z]$       出现在行尾的字母字符
        \c[a-z]$        同上
                                                                <b class="vimtag">*<a name="%2F[\n]">/[\n]</a>*</b>
        如果在集合前加上 "\_" 的话，同时匹配行尾符，这等价于给集合加上 "\n"。
        即使该模式以 "^" 开始，也能匹配行尾符！因此 "\_[^ab]" 将匹配行尾符以及
        所有非 "a" 或 "b" 的字符。
        这使其与 Vi 兼容：没有 "\_" 或 "\n" 时，集合不匹配行尾符。
                                                                <b class="vimtag">*<a name="E769">E769</a>*</b>
        如果没有 ']'，Vim 不会给出错误信息，而是假设不使用集合。可用于直接搜索
        '['。不过内部搜索会得到 E769。

        如果集合以 "^" 开始，它匹配所有_不在_集合内的字符："[^xyz]" 匹配任何不
        是 'x'、'y' 和 'z' 的字符。
        - 如果集合中的两个字符以 '-' 隔开，表示它们之间的所有 ASCII 字符。例
          如，"[0-9]" 匹配任何十进制数位。可以使用非 ASCII 字符，但字符值的距
          离不能超过 256.
        - 字符类表达式被解释为该字符类代表的字符集合。支持以下字符类：
<code class="section">                          名称          内容 </code>
<b class="vimtag">*<a name="[:alnum:]">[:alnum:]</a>*</b>               [:alnum:]     字母和数位
<b class="vimtag">*<a name="[:alpha:]">[:alpha:]</a>*</b>               [:alpha:]     字母
<b class="vimtag">*<a name="[:blank:]">[:blank:]</a>*</b>               [:blank:]     空格和制表字符
<b class="vimtag">*<a name="[:cntrl:]">[:cntrl:]</a>*</b>               [:cntrl:]     控制字符
<b class="vimtag">*<a name="[:digit:]">[:digit:]</a>*</b>               [:digit:]     十进制数位
<b class="vimtag">*<a name="[:graph:]">[:graph:]</a>*</b>               [:graph:]     可显示字符，不包括空格
<b class="vimtag">*<a name="[:lower:]">[:lower:]</a>*</b>               [:lower:]     小写字母 (使用 'ignorecase' 时代表所有
                                        字母)
<b class="vimtag">*<a name="[:print:]">[:print:]</a>*</b>               [:print:]     可显示字符，包括空格
<b class="vimtag">*<a name="[:punct:]">[:punct:]</a>*</b>               [:punct:]     标点字符
<b class="vimtag">*<a name="[:space:]">[:space:]</a>*</b>               [:space:]     空白字符
<b class="vimtag">*<a name="[:upper:]">[:upper:]</a>*</b>               [:upper:]     大写字母 (使用 'ignorecase' 时代表所有
                                        字母)
<b class="vimtag">*<a name="[:xdigit:]">[:xdigit:]</a>*</b>              [:xdigit:]    十六进制数位
<b class="vimtag">*<a name="[:return:]">[:return:]</a>*</b>              [:return:]    <code class="special">&lt;CR&gt;</code> 字符
<b class="vimtag">*<a name="[:tab:]">[:tab:]</a>*</b>                 [:tab:]       <code class="special">&lt;Tab&gt;</code> 字符
<b class="vimtag">*<a name="[:escape:]">[:escape:]</a>*</b>              [:escape:]    <code class="special">&lt;Esc&gt;</code> 字符
<b class="vimtag">*<a name="[:backspace:]">[:backspace:]</a>*</b>           [:backspace:] <code class="special">&lt;BS&gt;</code> 字符
          方括号括起的字符类表达式是对于方括号定界的集合的扩充。例如，下面的模
          式是一个 UNIX 文件名: "[-./[:alnum:]_~]\+"。即至少有一个字符的字符列
          表，其中字符可以是 '-'，'.'，'/'，字母，数位，'_' 或 '~' 中的一个。
          这些项仅对 8 位字符有效。
                                                        <b class="vimtag">*<a name="%2F[[%20">/[[=</a>*</b> <b class="vimtag">*<a name="[%20%20]">[==]</a>*</b>
        - 等价类 (equivalence class)。匹配的字符和被比较的字符 "几乎" 相同，但
          重音的区别可以忽略，兹举一例。形式是:
                [=a=]
          目前只提供 latin1 的实现，也能用于 utf-8 和 latin9 的 latin1 字符。
                                                        <b class="vimtag">*<a name="%2F[[.">/[[.</a>*</b> <b class="vimtag">*<a name="[..]">[..]</a>*</b>
        - 排序规则元素 (collation element)。目前只能简单地接受如下形式的单个字
          符:
                [.a.]
                                                          <b class="vimtag">*<a name="%2F\]">/\]</a>*</b>
        - 要在集合之内包括字符 ']'，^'，'-' 或 '\'，只需在该字符前加上反斜杠：
          "[xyz\]]"，"[\^xyz]"，"[xy\-z]" 和 "[xyz\\]"。
          (<code class="note">备注</code>: POSIX 不支持这种反斜杠的用法)。
          对于 ']' 你也可以将其作为第一个字符 (但可能在 "^" 之后) 而无须转义：
          "[]xyz]" 或 "[^]xyz]"  <code class="special"><code class="special">{Vi 无此功能}</code></code>。
          对于 '-' 你也可以将其作为第一个或最后一个字符："[-xyz]"，"[^-xyz]"
          或 "[xyz-]"。
          对于 '\' 你也可以将其放置在除了 "^]-\bdertnoUux" 以外的任何一个字符
          之前而无须转义："[\xyz]" 匹配 '\'，'x'，'y' 及 'z'。但是用 "\\" 好
          些，因为将来的扩展可能会在 '\' 之后使用其它字符。
        - 当 'cpoptions' 中不包括 'l' 标志位时，以下转义可用 <code class="special"><code class="special">{Vi 无此功能}</code></code>：
                \e      <code class="special">&lt;Esc&gt;</code>
                \t      <code class="special">&lt;Tab&gt;</code>
                \r      <code class="special">&lt;CR&gt;</code>    (_不是_行尾符！)
                \b      <code class="special">&lt;BS&gt;</code>
                \n      换行符，见上 |<code class="badlink">/[\n]</code>|
                \d123   字符的十进制表示
                \o40    字符的八进制表示，最大值为 0377
                \x20    字符的十六进制表示，最大值为 0xff
                \u20AC  多字节字符的十六进制表示，最大值为 0xffff
                \U1234  多字节字符的十六进制表示，最大值为 0xffffffff
          <code class="note">备注</code>: 其它曾在前面提到的反斜杠转义码 (<code class="vim">译者注</code>: 如 \s、\d 等)
                在方括号 [] 之内是不起作用的！
        - 用集合来匹配可能会很慢。因为每个字符都要和集合中的每一个字符作比较。
          尽可能使用上面提到的其它匹配原。例如：同样是匹配一个数位，"\d" 要比
          "[0-9]" 快的多。

                                                <b class="vimtag">*<a name="%2F\%[]">/\%[]</a>*</b> <b class="vimtag">*<a name="E69">E69</a>*</b> <b class="vimtag">*<a name="E70">E70</a>*</b> <b class="vimtag">*<a name="E369">E369</a>*</b>
\%[]    一个可选匹配原的序列。它总能匹配，但试图匹配尽量多的列出的匹配原，而在
        第一个不匹配的地方终止。例如：
<code class="example">                /r\%[ead]</code>
        匹配 "r"，"re"，"rea" 或者 "read"。采用最长可能的匹配。下面例子可以用
        来匹配 Ex 命令 "function"，其中 "fu" 是必须的而 "nction" 是可选的:
<code class="example">                /\<code class="special">&lt;fu\%[nction]\&gt;</code></code>
        这里用到了单词结尾匹配原 "\&gt;" 来避免匹配 "full" 中的 "fu"。
        当要匹配的不是普通字符时，问题就变得更复杂了。你不一定会经常这样，但可
        以这么做。例如:
<code class="example">                /\<code class="special">&lt;r\%[[eo]ad]\&gt;</code></code>
        匹配 "r"，"re"，"ro"，"rea"，"roa"，"read" 及 "road"。
        [] 里不能有 \(\)、\%(\) 或 \z(\) 项，\%[] 也不能嵌套。
        要包含 "["，用 "[[]" 而 "]" 则可用 "[]]"，例如:
<code class="example">                /index\%[[[]0[]]]</code>
        匹配 "index"、"index["、"index[0" 和 "index[0]"。
        <code class="special"><code class="special">{仅当编译时加入 +syntax 特性才有效}</code></code>

                                <b class="vimtag">*<a name="%2F\%d">/\%d</a>*</b> <b class="vimtag">*<a name="%2F\%x">/\%x</a>*</b> <b class="vimtag">*<a name="%2F\%o">/\%o</a>*</b> <b class="vimtag">*<a name="%2F\%u">/\%u</a>*</b> <b class="vimtag">*<a name="%2F\%U">/\%U</a>*</b> <b class="vimtag">*<a name="E678">E678</a>*</b>

\%d123  匹配十进制指定的字符。后面必须跟着非数位。
\%o40   匹配八进制指定的字符，至多 0377。
        小于 040 的数必须后面跟着非八进制的数位或非数位。
\%x2a   匹配不超过两位十六进制数位指定的字符。
\%u20AC 匹配不超过四位十六进制数位指定的字符。
\%U1234abcd     匹配不超过八位十六进制数位指定的字符。

</pre><hr class="doubleline" /><pre>
<h4>7. 忽略大小写                                           <b class="vimtag">*<a name="%2Fignorecase">/ignorecase</a>*</b></h4>
如果选项 'ignorecase' 打开的话，忽略正常字母的大小写。设定 'smartcase' 会在模
式只包含小写字母时才忽略大小写。
                                                        <b class="vimtag">*<a name="%2F\c">/\c</a>*</b> <b class="vimtag">*<a name="%2F\C">/\C</a>*</b>
如果模式的任何位置出现了 "\c"，整个模式会象打开 'ignorecase' 一样处理。真正的
'ignorecase' 和 'smartcase' 的值会被忽略。"\C" 的效果恰好相反: 强制对整个模式
匹配大小写。
<code class="special"><code class="special">{仅 Vim 支持 \c 和 \C}</code></code>
<code class="note">注意</code> 'ignorecase'，"\c" 和 "\C" 对字符类无效。

例如:
<code class="section">        模式    'ignorecase'  'smartcase'       匹配 </code>
        foo       关            -               foo
        foo       开            -               foo Foo FOO
        Foo       开            关              foo Foo FOO
        Foo       开            开                  Foo
        \cfoo     -             -               foo Foo FOO
        foo\C     -             -               foo

技术细节:                                               <b class="vimtag">*<a name="NL-used-for-Nul">NL-used-for-Nul</a>*</b>
文件中的 <code class="special">&lt;Nul&gt;</code> 字符在内存中存储为 <code class="special">&lt;NL&gt;</code>。显示为 "^@"。翻译是在读写文件时完成
的。为了在查找模式中匹配 <code class="special">&lt;Nul&gt;</code> 你可以使用 <code class="keystroke">CTRL-@</code> 或 "<code class="keystroke">CTRL-V</code> 000"。这应该不出你
的所料。在内部，该字符被替换为 <code class="special">&lt;NL&gt;</code>。不寻常的是键入 <code class="keystroke">CTRL-V</code> <code class="keystroke">CTRL-J</code> 同样插入一个
<code class="special">&lt;NL&gt;</code>，因此也搜索文件中的 <code class="special">&lt;Nul&gt;</code>。<code class="special">{Vi 则完全不能处理文件中的 <code class="special">&lt;Nul&gt;</code> 字符}</code>

                                                        <b class="vimtag">*<a name="CR-used-for-NL">CR-used-for-NL</a>*</b>
当 'fileformat' 为 "mac" 时，<code class="special">&lt;NL&gt;</code> 字符在内部储存为 <code class="special">&lt;CR&gt;</code>。在文本里显示为 "^J"。
除此以外，和 <code class="special">&lt;NL&gt;</code> 作为 <code class="special">&lt;Nul&gt;</code> 的用法类似。

在作表达式求值时，模式中的 <code class="special">&lt;NL&gt;</code> 字符匹配字符串中的 <code class="special">&lt;NL&gt;</code>。用 "\n" (反斜杠 n) 来
匹配 <code class="special">&lt;NL&gt;</code> 在这里是行不通的，它仅对缓冲区内的文本有效。

                                                        <b class="vimtag">*<a name="pattern-multi-byte">pattern-multi-byte</a>*</b>
模式匹配对于多字节字符同样适用。大体上使用并无区别，不过要<code class="note">注意</code>无效字节可能引起
的问题，一个包含无效字节的模式永远不会得到匹配。

</pre><hr class="doubleline" /><pre>
<h4>8. 合成用字符                                           <b class="vimtag">*<a name="patterns-composing">patterns-composing</a>*</b></h4>
                                                        <b class="vimtag">*<a name="%2F\Z">/\Z</a>*</b>
如果模式的任何位置出现了 "\Z"，合成用字符将被忽略。这时，只比较基本字符，合成
用字符可以不同，其数量也可以不同。这一功能只在 'encoding' 为 'utf-8' 时有意
义。

如果一个合成用字符出现在模式的开始处或在不包含合成用字符的项目之后出现，它匹配
任何包含该合成用字符的字符。

句号和合成用字符联用和合成用字符本身的效果相同，但是你不用担心该字符前面出现的
是什么项目。

合成用字符出现的顺序是重要的，虽然对一个字符而言，其上多个合成用字符的顺序调换
并不影响它的外观。将来这一点可能会改变。

</pre><hr class="doubleline" /><pre>
<h4>9. 与 Perl 模式的比较                                   <b class="vimtag">*<a name="perl-patterns">perl-patterns</a>*</b></h4>
Vim 中的正则表达式和 Perl 的在功能上来说非常相似。它们之间的区别基本上只是在表
示方法上。这里给出一个它们之间的区别的总结:

<code class="section">功能                            Vim 方言        Perl 方言 </code>
</pre><hr class="singleline" /><pre>
强制不区分大小写                \c              (?i)
强制区分大小写                  \C              (?-i)
不须被引用的群组                \%(atom\)       (?:atom)
保守的倍数描述                  \<code class="special">{-n,m}</code>         *?，+?，??，<code class="special">{}</code>?
零宽度匹配                      atom\@=         (?=atom)
零宽度否匹配                    atom\@!         (?!atom)
零宽度反向匹配                  atom\@&lt;=        (?&lt;=atom)
零宽度反向否匹配                atom\@&lt;!        (?&lt;!atom)
无重试匹配                      atom\@&gt;         (?&gt;atom)

Vim 和 Perl 匹配一个字符串中的换行符时有所不同:

在 Perl 里，^ 和 $ 缺省只匹配文本的开始和结尾。但是你也可以设定 'm' 标志位来使
它们匹配内嵌的换行符。你还可以设定 's' 标志位使句号 (.) 可以也用来匹配换行符。
(顺便提一下，使用类似上面 i 标志位的用法，可以在在模式内部改变这两个标志位。)

另一方面，Vim 中的 ^ 和 $ 永远匹配内嵌的换行符。但另外有两个匹配原： \%^ 和
\%$，可以分别用来匹配 (且只匹配) 文本的起始和结尾。对第二个问题，Vim 用 \_ "修
饰符" 来解决：把它放在一个句号或字符类之前，对应的模式就可以同时匹配换行字符。

最后，以下这些结构是 Perl 独有的：
- 在正则表达式内执行任意代码:  (?<code class="special">{perl 代码}</code>)
- 条件表达式:  (?(条件)真值表达式|假值表达式)

... 而这些是 Vim 独有的：
- 改变模式的 'magic' 属性:  \v \V \m \M (对于避免反斜杠非常有用)
- 可选匹配原的序列:  \%[atoms]
- \&amp; (\&amp; 之于 \| 就像 "与" 之于 "或"；它强迫多个模式在同一个位置匹配)
- 通过行/列号匹配:  \%5l \%5c \%5v
- 设置匹配的开始和结束位置:  \zs \ze

</pre><hr class="doubleline" /><pre>
<h4>10. 高亮显示匹配                                        <b class="vimtag">*<a name="match-highlight">match-highlight</a>*</b></h4>
                                                        <b class="vimtag">*<a name=":mat">:mat</a>*</b> <b class="vimtag">*<a name=":match">:match</a>*</b>
:mat[ch] <code class="special">{group}</code> /<code class="special">{pattern}</code>/
                定义一个在当前窗口高亮显示的模式。它会以 <code class="special">{group}</code> 高亮。例:
<code class="example">                        :highlight MyGroup ctermbg=green guibg=green</code>
<code class="example">                        :match MyGroup /TODO/</code>
                除了 // 以外，任何字符都可以用来标识一个 <code class="special">{pattern}</code> 的开始和结
                束。要当心某些特殊的字符，例如 '"' 和 '|'。

                该命令执行时，<code class="special">{group}</code> 必须已经定义。

                对于 'hlsearch' 要高亮的字符，仍然适用 <code class="special">{group}</code> 高亮，因为匹配
                高亮的优先级比 'hlsearch' 要高。同样的，语法高亮 (见 'syntax')
                也被匹配否决。

                <code class="note">注意</code> 使用 'hlsearch' 高亮显示最近使用的查找模式对所有窗口都有
                效，而以 ":match" 定义的模式仅仅对当前窗口生效。当切换至另一个
                缓冲区时，该设定被保留。

                'ignorecase' 不起作用。在模式中使用 |<code class="badlink">/\c</code>| 来忽略大小写，否则，
                大小写总是区分的。

                'redrawtime' 定义搜索模式匹配的最大时间。

                匹配行尾而 Vim 只重绘部分显示时，结果可能会令你意想不到。这是
                因为 Vim 在重绘开始的行上寻找匹配的缘故。

                另见 |<code class="badlink">matcharg()</code>| 和 |<code class="badlink">getmatches()</code>|。前者返回上次 |<code class="badlink">:match</code>| 命
                令使用的高亮组和模式。后者返回 |<code class="badlink">matchadd()</code>| 和 |<code class="badlink">:match</code>| 两者定
                义的所有高亮组和模式的列表。

                |<code class="badlink">:match</code>| 定义的高亮匹配仅限于三个 (除了 |<code class="badlink">:match</code>| 以外，还有
                |<code class="badlink">:2match</code>| 和 |<code class="badlink">:3match</code>|)。而 |<code class="badlink">matchadd()</code>| 无此限制，而且还能排
                定匹配的优先级。

                另一个例子，高亮显示虚拟第 72 列之后的所有文本:
<code class="example">                        :highlight rightMargin term=bold ctermfg=blue guifg=blue</code>
<code class="example">                        :match rightMargin /.\%&gt;72v/</code>
                要高亮显示所有位于虚拟第 7 列的文本:
<code class="example">                        :highlight col8 ctermbg=grey guibg=grey</code>
<code class="example">                        :match col8 /\%<code class="special">&lt;8v.\%&gt;</code>7v/</code>
                <code class="note">注意</code> 用两个项目是为了匹配那些占用了超过一个虚拟列的字符，例如
                TAB。

:mat[ch]
:mat[ch] none
                清除上次定义的匹配模式。


:2mat[ch] <code class="special">{group}</code> /<code class="special">{pattern}</code>/                                   <b class="vimtag">*<a name=":2match">:2match</a>*</b>
:2mat[ch]
:2mat[ch] none
:3mat[ch] <code class="special">{group}</code> /<code class="special">{pattern}</code>/                                   <b class="vimtag">*<a name=":3match">:3match</a>*</b>
:3mat[ch]
:3mat[ch] none
                和上面的 |<code class="badlink">:match</code>| 完全类似，但设置不同的匹配。这样，同时可以有
                三组激活的匹配。如果不同匹配在相同位置出现，最小编号的匹配优
                先。
                ":3match" 命令用于 |<code class="badlink">matchparen</code>| 插件。建议使用 ":match" 进行手
                动的搜索，而 ":2match" 用于其它的插件。


 vim:tw=78:ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html on Fri Dec 11 21:56:50 CST 2015</i> - <a href="http://www.4e00.com/">www.4e00.com</a></p>
</body>
</html>
