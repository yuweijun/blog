<!doctype html>




<html class="theme-next mist">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">


















  

<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">






  <link rel="alternate" href="/blog/atom.xml" title="一" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/blog/favicon.ico?v=5.0.1">






<meta name="description" content="Java内存模型下面这篇关于java内存模型的文章写得简单易懂，配图也非常的好，虽然没有深入细节如内存屏障，volatile/final/synchronized的内存语义和实现说明，以及happens-before规则等，但对于入门理解java内存模型还是不错的，英文原文如下： The Java memory model specifies how the Java virtual machin">
<meta property="og:type" content="article">
<meta property="og:title" content="java memory model">
<meta property="og:url" content="http://www.4e00.com/java/2016/10/13/java-memory-model.html">
<meta property="og:site_name" content="一">
<meta property="og:description" content="Java内存模型下面这篇关于java内存模型的文章写得简单易懂，配图也非常的好，虽然没有深入细节如内存屏障，volatile/final/synchronized的内存语义和实现说明，以及happens-before规则等，但对于入门理解java内存模型还是不错的，英文原文如下： The Java memory model specifies how the Java virtual machin">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/java-concurrency/java-memory-model-1.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/java-concurrency/java-memory-model-2.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/java-concurrency/java-memory-model-3.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/java-concurrency/java-memory-model-4.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/java-concurrency/java-memory-model-5.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/java-concurrency/java-memory-model-6.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/java-concurrency/java-memory-model-7.png">
<meta property="og:updated_time" content="2020-03-06T01:24:26.112Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java memory model">
<meta name="twitter:description" content="Java内存模型下面这篇关于java内存模型的文章写得简单易懂，配图也非常的好，虽然没有深入细节如内存屏障，volatile/final/synchronized的内存语义和实现说明，以及happens-before规则等，但对于入门理解java内存模型还是不错的，英文原文如下： The Java memory model specifies how the Java virtual machin">
<meta name="twitter:image" content="http://www.4e00.com/blog/img/java/java-concurrency/java-memory-model-1.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide"},
    fancybox: false,
    motion: false,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://www.4e00.com/blog/java/2016/10/13/java-memory-model.html">

  <title> java memory model | 一 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/blog/" class="brand" rel="start">
      <span class="site-title">一</span>
    </a>
  </div>
  <p class="site-subtitle">{"type":"编程笔记"}</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      <li class="menu-item menu-item-search">
        <a href="https://www.google.com.hk/search?q=site%3Ahttp://www.4e00.com/blog/" class="popup-trigger">
          <i class="menu-item-icon fa fa-search fa-fw"></i>Search
        </a>
      </li>
    </ul>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                java memory model
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-10-13T21:07:19+08:00" content="2016-10-13">
              2016-10-13
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="//schema.org/Thing">
                  <a href="/blog/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>下面这篇关于<a href="http://tutorials.jenkov.com/java-concurrency/java-memory-model.html" target="_blank" rel="noopener">java内存模型</a>的文章写得简单易懂，配图也非常的好，虽然没有深入细节如内存屏障，<code>volatile/final/synchronized</code>的内存语义和实现说明，以及<code>happens-before</code>规则等，但对于入门理解java内存模型还是不错的，英文原文如下：</p>
<p>The Java memory model specifies how the Java virtual machine works with the computer&#39;s memory (RAM). The Java virtual machine is a model of a whole computer so this model naturally includes a memory model - AKA the <code>Java Memory Model</code>.</p>
<p>It is very important to understand the Java memory model if you want to design correctly behaving concurrent programs. The Java memory model specifies how and when different threads can see values written to shared variables by other threads, and how to synchronize access to shared variables when necessary.</p>
<p>The original Java memory model was insufficient, so the Java memory model was revised in Java 1.5. This version of the Java memory model is still in use in Java 8.</p>
<h3 id="The-Internal-Java-Memory-Model"><a href="#The-Internal-Java-Memory-Model" class="headerlink" title="The Internal Java Memory Model"></a>The Internal Java Memory Model</h3><p>The Java memory model used internally in the JVM divides memory between thread stacks and the heap. This diagram illustrates the Java memory model from a logic perspective:</p>
<img src="/blog/img/java/java-concurrency/java-memory-model-1.png" title="[java-memory-model-1]">
<a id="more"></a>
<h3 id="The-Java-Memory-Model-From-a-Logic-Perspective"><a href="#The-Java-Memory-Model-From-a-Logic-Perspective" class="headerlink" title="The Java Memory Model From a Logic Perspective"></a>The Java Memory Model From a Logic Perspective</h3><p>Each thread running in the Java virtual machine has its own thread stack. The thread stack contains information about what methods the thread has called to reach the current point of execution. I will refer to this as the &quot;call stack&quot;. As the thread executes its code, the call stack changes.</p>
<p>The thread stack also contains all local variables for each method being executed (all methods on the call stack). A thread can only access it&#39;s own thread stack. Local variables created by a thread are invisible to all other threads than the thread who created it. Even if two threads are executing the exact same code, the two threads will still create the local variables of that code in each their own thread stack. Thus, each thread has its own version of each local variable.</p>
<p>All local variables of primitive types ( boolean, byte, short, char, int, long, float, double) are fully stored on the thread stack and are thus not visible to other threads. One thread may pass a copy of a pritimive variable to another thread, but it cannot share the primitive local variable itself.</p>
<p>The heap contains all objects created in your Java application, regardless of what thread created the object. This includes the object versions of the primitive types (e.g. Byte, Integer, Long etc.). It does not matter if an object was created and assigned to a local variable, or created as a member variable of another object, the object is still stored on the heap.</p>
<p>Here is a diagram illustrating the call stack and local variables stored on the thread stacks, and objects stored on the heap:</p>
<img src="/blog/img/java/java-concurrency/java-memory-model-2.png" title="[java-memory-model-2]">
<p>The Java Memory Model showing where local variables and objects are stored in memory:</p>
<ol>
<li>A local variable may be of a primitive type, in which case it is totally kept on the thread stack.</li>
<li>A local variable may also be a reference to an object. In that case the reference (the local variable) is stored on the thread stack, but the object itself if stored on the heap.</li>
<li>An object may contain methods and these methods may contain local variables. These local variables are also stored on the thread stack, even if the object the method belongs to is stored on the heap.</li>
<li>An object&#39;s member variables are stored on the heap along with the object itself. That is true both when the member variable is of a primitive type, and if it is a reference to an object.</li>
<li>Static class variables are also stored on the heap along with the class definition.</li>
</ol>
<p>Objects on the heap can be accessed by all threads that have a reference to the object. When a thread has access to an object, it can also get access to that object&#39;s member variables. If two threads call a method on the same object at the same time, they will both have access to the object&#39;s member variables, but each thread will have its own copy of the local variables.</p>
<p>Here is a diagram illustrating the points above:</p>
<img src="/blog/img/java/java-concurrency/java-memory-model-3.png" title="[java-memory-model-3]">
<p>The Java Memory Model showing references from local variables to objects, and from object to other objects.<br>Two threads have a set of local variables. One of the local variables (<code>localVariable2</code>) point to a shared object on the heap (<code>Object3</code>). The two threads each have a different reference to the same object. Their references are local variables and are thus stored in each thread&#39;s thread stack (on each). The two different references point to the same object on the heap, though.</p>
<p>Notice how the shared object (<code>Object3</code>) has a reference to <code>Object2</code> and <code>Object4</code> as member variables (illustrated by the arrows from <code>Object3</code> to <code>Object2</code> and <code>Object4</code>). Via these member variable references in <code>Object3</code> the two threads can access <code>Object2</code> and <code>Object4</code>.</p>
<p>The diagram also shows a local variable which point to two different objects on the heap. In this case the references point to two different objects (<code>Object1</code> and <code>Object5</code>), not the same object. In theory both threads could access both <code>Object1</code> and <code>Object5</code>, if both threads had references to both objects. But in the diagram above each thread only has a reference to one of the two objects.</p>
<p>So, what kind of Java code could lead to the above memory graph? Well, code as simple as the code below:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><span class="line">        methodOne();</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</span><span class="line">        <span class="keyword">int</span> localVariable1 = <span class="number">45</span>;</span><span class="line"></span><span class="line">        MySharedObject localVariable2 = MySharedObject.sharedInstance;</span><span class="line"></span><span class="line">        <span class="comment">//... do more with local variables.</span></span><span class="line"></span><span class="line">        methodTwo();</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodTwo</span><span class="params">()</span> </span>&#123;</span><span class="line">        Integer localVariable1 = <span class="keyword">new</span> Integer(<span class="number">99</span>);</span><span class="line"></span><span class="line">        <span class="comment">//... do more with local variable.</span></span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySharedObject</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="comment">//static variable pointing to instance of MySharedObject</span></span><span class="line"></span><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MySharedObject sharedInstance = <span class="keyword">new</span> MySharedObject();</span><span class="line"></span><span class="line"></span><span class="line">    <span class="comment">//member variables pointing to two objects on the heap</span></span><span class="line"></span><span class="line">    <span class="keyword">public</span> Integer object2 = <span class="keyword">new</span> Integer(<span class="number">22</span>);</span><span class="line">    <span class="keyword">public</span> Integer object4 = <span class="keyword">new</span> Integer(<span class="number">44</span>);</span><span class="line"></span><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> member1 = <span class="number">12345</span>;</span><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> member1 = <span class="number">67890</span>;</span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>If two threads were executing the <code>run()</code> method then the diagram shown earlier would be the outcome. The <code>run()</code> method calls <code>methodOne()</code> and <code>methodOne()</code> calls <code>methodTwo()</code>.</p>
<p>methodOne() declares a primitive local variable (<code>localVariable1</code> of type int) and an local variable which is an object reference (<code>localVariable2</code>).</p>
<p>Each thread executing <code>methodOne()</code> will create its own copy of <code>localVariable1</code> and <code>localVariable2</code> on their respective thread stacks. The <code>localVariable1</code> variables will be completely separated from each other, only living on each thread&#39;s thread stack. One thread cannot see what changes another thread makes to its copy of <code>localVariable1</code>.</p>
<p>Each thread executing <code>methodOne()</code> will also create their own copy of <code>localVariable2</code>. However, the two different copies of <code>localVariable2</code> both end up pointing to the same object on the heap. The code sets <code>localVariable2</code> to point to an object referenced by a static variable. There is only one copy of a static variable and this copy is stored on the heap. Thus, both of the two copies of <code>localVariable2</code> end up pointing to the same instance of <code>MySharedObject</code> which the static variable points to. The <code>MySharedObject</code> instance is also stored on the heap. It corresponds to <code>Object3</code> in the diagram above.</p>
<p>Notice how the <code>MySharedObject</code> class contains two member variables too. The member variables themselves are stored on the heap along with the object. The two member variables point to two other Integer objects. These Integer objects correspond to <code>Object2</code> and <code>Object4</code> in the diagram above.</p>
<p>Notice also how <code>methodTwo()</code> creates a local variable named <code>localVariable1</code>. This local variable is an object reference to an Integer object. The method sets the <code>localVariable1</code> reference to point to a new Integer instance. The <code>localVariable1</code> reference will be stored in one copy per thread executing methodTwo(). The two Integer objects instantiated will be stored on the heap, but since the method creates a new Integer object every time the method is executed, two threads executing this method will create separate Integer instances. The Integer objects created inside <code>methodTwo()</code> correspond to <code>Object1</code> and <code>Object5</code> in the diagram above.</p>
<p>Notice also the two member variables in the class <code>MySharedObject</code> of type long which is a primitive type. Since these variables are member variables, they are still stored on the heap along with the object. Only local variables are stored on the thread stack.</p>
<h3 id="Hardware-Memory-Architecture"><a href="#Hardware-Memory-Architecture" class="headerlink" title="Hardware Memory Architecture"></a>Hardware Memory Architecture</h3><p>Modern hardware memory architecture is somewhat different from the internal Java memory model. It is important to understand the hardware memory architecture too, to understand how the Java memory model works with it. This section describes the common hardware memory architecture, and a later section will describe how the Java memory model works with it.</p>
<p>Here is a simplified diagram of modern computer hardware architecture:</p>
<img src="/blog/img/java/java-concurrency/java-memory-model-4.png" title="[java-memory-model-4]">
<h3 id="Modern-hardware-memory-architecture"><a href="#Modern-hardware-memory-architecture" class="headerlink" title="Modern hardware memory architecture."></a>Modern hardware memory architecture.</h3><p>A modern computer often has 2 or more CPUs in it. Some of these CPUs may have multiple cores too. The point is, that on a modern computer with 2 or more CPUs it is possible to have more than one thread running simultaneously. Each CPU is capable of running one thread at any given time. That means that if your Java application is multithreaded, one thread per CPU may be running simultaneously (concurrently) inside your Java application.</p>
<p>Each CPU contains a set of registers which are essentially in-CPU memory. The CPU can perform operations much faster on these registers than it can perform on variables in main memory. That is because the CPU can access these registers much faster than it can access main memory.</p>
<p>Each CPU may also have a CPU cache memory layer. In fact, most modern CPUs have a cache memory layer of some size. The CPU can access its cache memory much faster than main memory, but typically not as fast as it can access its internal registers. So, the CPU cache memory is somewhere in between the speed of the internal registers and main memory. Some CPUs may have multiple cache layers (Level 1 and Level 2), but this is not so important to know to understand how the Java memory model interacts with memory. What matters is to know that CPUs can have a cache memory layer of some sort.</p>
<p>A computer also contains a main memory area (RAM). All CPUs can access the main memory. The main memory area is typically much bigger than the cache memories of the CPUs.</p>
<p>Typically, when a CPU needs to access main memory it will read part of main memory into its CPU cache. It may even read part of the cache into its internal registers and then perform operations on it. When the CPU needs to write the result back to main memory it will flush the value from its internal register to the cache memory, and at some point flush the value back to main memory.</p>
<p>The values stored in the cache memory is typically flushed back to main memory when the CPU needs to store something else in the cache memory. The CPU cache can have data written to part of its memory at a time, and flush part of its memory at a time. It does not have to read / write the full cache each time it is updated. Typically the cache is updated in smaller memory blocks called &quot;cache lines&quot;. One or more cache lines may be read into the cache memory, and one or mor cache lines may be flushed back to main memory again.</p>
<h3 id="Bridging-The-Gap-Between-The-Java-Memory-Model-And-The-Hardware-Memory-Architecture"><a href="#Bridging-The-Gap-Between-The-Java-Memory-Model-And-The-Hardware-Memory-Architecture" class="headerlink" title="Bridging The Gap Between The Java Memory Model And The Hardware Memory Architecture"></a>Bridging The Gap Between The Java Memory Model And The Hardware Memory Architecture</h3><p>As already mentioned, the Java memory model and the hardware memory architecture are different. The hardware memory architecture does not distinguish between thread stacks and heap. On the hardware, both the thread stack and the heap are located in main memory. Parts of the thread stacks and heap may sometimes be present in CPU caches and in internal CPU registers. This is illustrated in this diagram:</p>
<img src="/blog/img/java/java-concurrency/java-memory-model-5.png" title="[java-memory-model-5]">
<p>The division of thread stack and heap among CPU internal registers, CPU cache and main memory.</p>
<p>When objects and variables can be stored in various different memory areas in the computer, certain problems may occur. The two main problems are:</p>
<ol>
<li>Visibility of thread updates (writes) to shared variables.</li>
<li>Race conditions when reading, checking and writing shared variables.</li>
</ol>
<p>Both of these problems will be explained in the following sections.</p>
<h3 id="Visibility-of-Shared-Objects"><a href="#Visibility-of-Shared-Objects" class="headerlink" title="Visibility of Shared Objects"></a>Visibility of Shared Objects</h3><p>If two or more threads are sharing an object, without the proper use of either <code>volatile</code> declarations or synchronization, updates to the shared object made by one thread may not be visible to other threads.</p>
<p>Imagine that the shared object is initially stored in main memory. A thread running on CPU one then reads the shared object into its CPU cache. There it makes a change to the shared object. As long as the CPU cache has not been flushed back to main memory, the changed version of the shared object is not visible to threads running on other CPUs. This way each thread may end up with its own copy of the shared object, each copy sitting in a different CPU cache.</p>
<p>The following diagram illustrates the sketched situation. One thread running on the left CPU copies the shared object into its CPU cache, and changes its count variable to <code>2</code>. This change is not visible to other threads running on the right CPU, because the update to count has not been flushed back to main memory yet.</p>
<img src="/blog/img/java/java-concurrency/java-memory-model-6.png" title="[java-memory-model-6]">
<h3 id="Visibility-Issues-in-the-Java-Memory-Model"><a href="#Visibility-Issues-in-the-Java-Memory-Model" class="headerlink" title="Visibility Issues in the Java Memory Model."></a>Visibility Issues in the Java Memory Model.</h3><p>To solve this problem you can use Java&#39;s <code>volatile</code> keyword. The <code>volatile</code> keyword can make sure that a given variable is read directly from main memory, and always written back to main memory when updated.</p>
<h3 id="Race-Conditions"><a href="#Race-Conditions" class="headerlink" title="Race Conditions"></a>Race Conditions</h3><p>If two or more threads share an object, and more than one thread updates variables in that shared object, race conditions may occur.</p>
<p>Imagine if thread A reads the variable count of a shared object into its CPU cache. Imagine too, that thread B does the same, but into a different CPU cache. Now thread A adds one to count, and thread B does the same. Now <code>var1</code> has been incremented two times, once in each CPU cache.</p>
<p>If these increments had been carried out sequentially, the variable count would be been incremented twice and had the original value <code>+2</code> written back to main memory.</p>
<p>However, the two increments have been carried out concurrently without proper synchronization. Regardless of which of thread A and B that writes its updated version of count back to main memory, the updated value will only be <code>1</code> higher than the original value, despite the two increments.</p>
<p>This diagram illustrates an occurrence of the problem with race conditions as described above:</p>
<img src="/blog/img/java/java-concurrency/java-memory-model-7.png" title="[java-memory-model-7]">
<h3 id="Race-Condition-Issues-in-the-Java-Memory-Model"><a href="#Race-Condition-Issues-in-the-Java-Memory-Model" class="headerlink" title="Race Condition Issues in the Java Memory Model"></a>Race Condition Issues in the Java Memory Model</h3><p>To solve this problem you can use a Java <code>synchronized</code> block. A synchronized block guarantees that only one thread can enter a given critical section of the code at any given time. Synchronized blocks also guarantee that all variables accessed inside the synchronized block will be read in from main memory, and when the thread exits the synchronized block, all updated variables will be flushed back to main memory again, regardless of whether the variable is declared <code>volatile</code> or not.</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a href="http://tutorials.jenkov.com/java-concurrency/java-memory-model.html" target="_blank" rel="noopener">Java Memory Model</a></li>
<li><a href="http://ifeve.com/java-memory-model-6/" target="_blank" rel="noopener">Java内存模型</a></li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/linux/2016/10/01/hello-world.html" rel="next" title="hello world">
                <i class="fa fa-chevron-left"></i>
                hello world
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/java/2016/10/13/java-memory-model-notes.html" rel="prev" title="java memory model 学习笔记">
                <i class="fa fa-chevron-right"></i>
                java memory model 学习笔记
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/blog/images/avatar.jpg" alt="yuweijun">
          <p class="site-author-name" itemprop="name">yuweijun</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/blog/archives">
              <span class="site-state-item-count">492</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">categories</span>
              
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/blog/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yuweijun" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/yuweijun" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java内存模型"><span class="nav-number">1.</span> <span class="nav-text">Java内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Internal-Java-Memory-Model"><span class="nav-number">1.1.</span> <span class="nav-text">The Internal Java Memory Model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Java-Memory-Model-From-a-Logic-Perspective"><span class="nav-number">1.2.</span> <span class="nav-text">The Java Memory Model From a Logic Perspective</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hardware-Memory-Architecture"><span class="nav-number">1.3.</span> <span class="nav-text">Hardware Memory Architecture</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Modern-hardware-memory-architecture"><span class="nav-number">1.4.</span> <span class="nav-text">Modern hardware memory architecture.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bridging-The-Gap-Between-The-Java-Memory-Model-And-The-Hardware-Memory-Architecture"><span class="nav-number">1.5.</span> <span class="nav-text">Bridging The Gap Between The Java Memory Model And The Hardware Memory Architecture</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Visibility-of-Shared-Objects"><span class="nav-number">1.6.</span> <span class="nav-text">Visibility of Shared Objects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Visibility-Issues-in-the-Java-Memory-Model"><span class="nav-number">1.7.</span> <span class="nav-text">Visibility Issues in the Java Memory Model.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Race-Conditions"><span class="nav-number">1.8.</span> <span class="nav-text">Race Conditions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Race-Condition-Issues-in-the-Java-Memory-Model"><span class="nav-number">1.9.</span> <span class="nav-text">Race Condition Issues in the Java Memory Model</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#References"><span class="nav-number">2.</span> <span class="nav-text">References</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-github"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yuweijun</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist.KISS
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>











  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.0.0/jquery.min.js"></script>

  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>

  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>

  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.3.1/velocity.min.js"></script>

  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.3.1/velocity.ui.min.js"></script>


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/blog/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/blog/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
