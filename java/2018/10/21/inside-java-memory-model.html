<!doctype html>




<html class="theme-next mist">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">


















  

<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">






  <link rel="alternate" href="/blog/atom.xml" title="一" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/blog/favicon.ico?v=5.0.1">






<meta name="description" content="深入理解 Java 内存模型一：基础Doug Lea 关于JSR-133内存模型的说明 The JSR-133 Cookbook for Compiler Writers。 并发编程模型的分类在并发编程中，我们需要处理两个关键问题：  线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。  通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：  共享">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解 java 内存模型">
<meta property="og:url" content="http://www.4e00.com/java/2018/10/21/inside-java-memory-model.html">
<meta property="og:site_name" content="一">
<meta property="og:description" content="深入理解 Java 内存模型一：基础Doug Lea 关于JSR-133内存模型的说明 The JSR-133 Cookbook for Compiler Writers。 并发编程模型的分类在并发编程中，我们需要处理两个关键问题：  线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。  通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：  共享">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-11.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-12.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-13.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-14.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/ordering-by-a-happens-beforerelationship.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-15.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-21.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-22.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-23.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-24.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/pipeline-functionality.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/cpu-stage-pipeline.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-31.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-32.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-33.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-34.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-35.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-36.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/write-buffers-with-bypassing-capability.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/overlapping-write-operations.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/non-blocking-read-operations.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-41.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-42.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-43.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-reorder-rules.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-barriers-ordering-rule.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-memory-fence-placements.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-44.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-45.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-46.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-47.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/mesi-protocal.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/caches-with-invalidate-queues.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/cpu-caches-intel-i7.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/cache-structure-of-the-intel-core-i7-processors.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-48.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/system-out-println.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/java-volatile-print-assembly.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-51.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-52.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-53.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-54.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-55.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-61.jpg">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-62.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-63.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-64.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-71.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-72.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-73.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-74.png">
<meta property="og:updated_time" content="2019-04-30T12:55:56.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解 java 内存模型">
<meta name="twitter:description" content="深入理解 Java 内存模型一：基础Doug Lea 关于JSR-133内存模型的说明 The JSR-133 Cookbook for Compiler Writers。 并发编程模型的分类在并发编程中，我们需要处理两个关键问题：  线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。  通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：  共享">
<meta name="twitter:image" content="http://www.4e00.com/blog/img/java/jmm/jmm-11.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide"},
    fancybox: false,
    motion: false,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://www.4e00.com/blog/java/2018/10/21/inside-java-memory-model.html">

  <title> 深入理解 java 内存模型 | 一 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/blog/" class="brand" rel="start">
      <span class="site-title">一</span>
    </a>
  </div>
  <p class="site-subtitle">{"type":"编程笔记"}</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      <li class="menu-item menu-item-search">
        <a href="https://www.google.com.hk/search?q=site%3Ahttp://www.4e00.com/blog/" class="popup-trigger">
          <i class="menu-item-icon fa fa-search fa-fw"></i>Search
        </a>
      </li>
    </ul>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                深入理解 java 内存模型
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2018-10-21T19:24:35+08:00" content="2018-10-21">
              2018-10-21
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="//schema.org/Thing">
                  <a href="/blog/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="深入理解-Java-内存模型一：基础"><a href="#深入理解-Java-内存模型一：基础" class="headerlink" title="深入理解 Java 内存模型一：基础"></a>深入理解 Java 内存模型一：基础</h2><p>Doug Lea 关于<code>JSR-133</code>内存模型的说明 <a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html" target="_blank" rel="noopener">The JSR-133 Cookbook for Compiler Writers</a>。</p>
<h3 id="并发编程模型的分类"><a href="#并发编程模型的分类" class="headerlink" title="并发编程模型的分类"></a>并发编程模型的分类</h3><p>在并发编程中，我们需要处理两个关键问题：</p>
<blockquote>
<p>线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。</p>
</blockquote>
<p>通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：</p>
<blockquote>
<p>共享内存和消息传递。</p>
</blockquote>
<p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过<code>写-读</code>内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</p>
<p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p>
<p>Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的 Java 程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p>
<h3 id="Java-内存模型的抽象"><a href="#Java-内存模型的抽象" class="headerlink" title="Java 内存模型的抽象"></a>Java 内存模型的抽象</h3><p>在 java 中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用<strong>共享变量</strong>这个术语代指<code>实例域</code>，<code>静态域</code>和<code>数组元素</code>）。</p>
<p>局部变量（Local variables），方法定义参数（java 语言规范称之为 formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有<strong>内存可见性</strong>问题，也不受内存模型的影响。</p>
<p>Java 线程之间的通信由 Java 内存模型（本文简称为 JMM）控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：</p>
<blockquote>
<p>线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以<code>读/写</code>共享变量的副本。<br>本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了<strong>缓存</strong>，<strong>写缓冲区</strong>，<strong>寄存器</strong>以及其他的硬件和编译器优化。</p>
</blockquote>
<p>Java 内存模型的抽象示意图如下：</p>
<img src="/blog/img/java/jmm/jmm-11.png" class="image-md">
<p>从上图来看，线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤：</p>
<ol>
<li>首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。</li>
<li>然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。</li>
</ol>
<p>下面通过示意图来说明这两个步骤：</p>
<img src="/blog/img/java/jmm/jmm-12.png" class="image-md">
<p>如上图所示，本地内存 A 和 B 有主内存中共享变量 <code>x</code> 的副本。假设初始时，这三个内存中的 <code>x</code> 值都为 0。线程 A 在执行时，把更新后的 <code>x</code> 值（假设值为 1）临时存放在自己的本地内存 A 中。当线程 A 和线程 B 需要通信时，线程 A 首先会把自己本地内存中修改后的 <code>x</code> 值刷新到主内存中，此时主内存中的 <code>x</code> 值变为了 1。随后，线程 B 到主内存中去读取线程 A 更新后的 <code>x</code> 值，此时线程 B 的本地内存的 <code>x</code> 值也变为了 1。</p>
<p>从整体来看，这两个步骤实质上是线程 A 在向线程 B 发送消息，而且这个通信过程必须要经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 java 程序员提供内存可见性保证。</p>
<a id="more"></a>
<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p>
<ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用<strong>缓存</strong>和<strong>读/写缓冲区</strong>，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ol>
<p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p>
<img src="/blog/img/java/jmm/jmm-13.png" class="image-md">
<p>上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p>
<p>JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<h4 id="处理器重排序与内存屏障指令"><a href="#处理器重排序与内存屏障指令" class="headerlink" title="处理器重排序与内存屏障指令"></a>处理器重排序与内存屏障指令</h4><p>现代的处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：</p>
<blockquote>
<p>处理器对内存的<code>读/写</code>操作的执行顺序，不一定与内存实际发生的<code>读/写</code>操作顺序一致！</p>
</blockquote>
<p>为了具体说明，请看下面示例：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Processor A</th>
<th style="text-align:left">Processor B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a = 1; //A1</td>
<td style="text-align:left">b = 2; //B1</td>
</tr>
<tr>
<td style="text-align:left">x = b; //A2</td>
<td style="text-align:left">y = a; //B2</td>
</tr>
</tbody>
</table>
<blockquote>
<p>初始状态：a = b = 0<br>处理器允许执行后得到结果：x = y = 0</p>
</blockquote>
<p>假设处理器 A 和处理器 B 按程序的顺序并行执行内存访问，最终却可能得到<code>x = y = 0</code>的结果。具体的原因如下图所示：</p>
<img src="/blog/img/java/jmm/jmm-14.png" class="image-md">
<p>这里处理器 A 和处理器 B 可以同时把共享变量写入自己的写缓冲区<code>A1/B1</code>，然后从内存中读取另一个共享变量<code>A2/B2</code>，最后才把自己写缓存区中保存的脏数据刷新到内存中<code>A3/B3</code>。当以这种时序执行时，程序就可以得到<code>x = y = 0</code>的结果。</p>
<p>从内存操作实际发生的顺序来看，直到处理器 A 执行 A3 来刷新自己的写缓存区，写操作 A1 才算真正执行了。虽然处理器 A 执行内存操作的顺序为：</p>
<blockquote>
<p><code>A1-&gt;A2</code></p>
</blockquote>
<p>但内存操作实际发生的顺序却是：</p>
<blockquote>
<p><code>A2-&gt;A1</code></p>
</blockquote>
<p>此时，处理器 A 的内存操作顺序被重排序了（处理器 B 的情况和处理器 A 一样，这里就不赘述了）。</p>
<p>这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对<code>写-读</code>操作重排序。</p>
<p>下面是常见处理器允许的重排序类型的列表：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Load-Load</th>
<th style="text-align:center">Load-Store</th>
<th style="text-align:center">Store-Store</th>
<th style="text-align:center">Store-Load</th>
<th style="text-align:center">数据依赖</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">sparc-TSO</td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">x86</td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">ia64</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">PowerPC</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
</tbody>
</table>
<p>上表单元格中的<code>N</code>表示处理器不允许两个操作重排序，<code>Y</code>表示允许重排序。</p>
<p>从上表我们可以看出：</p>
<blockquote>
<p>常见的处理器都允许<code>Store-Load</code>重排序；常见的处理器都不允许对存在数据依赖的操作做重排序。</p>
</blockquote>
<p>sparc-TSO 和 x86 拥有相对较强的处理器内存模型，它们仅允许对<code>写-读</code>操作做重排序（因为它们都使用了写缓冲区）。</p>
<blockquote>
<p>※ 注 1：sparc-TSO 是指以 TSO(Total Store Order)内存模型运行时，sparc 处理器的特性。<br>※ 注 2：上表中的 x86 包括 x64 及 AMD64。<br>※ 注 3：由于 ARM 处理器的内存模型与 PowerPC 处理器的内存模型非常类似，本文将忽略它。<br>※ 注 4：数据依赖性后文会专门说明。</p>
</blockquote>
<p>为了保证内存可见性，java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM 把内存屏障指令分为下列四类：</p>
<table>
<thead>
<tr>
<th style="text-align:left">屏障类型</th>
<th style="text-align:left">指令示例</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">LoadLoad Barriers</td>
<td style="text-align:left">Load1; LoadLoad; Load2</td>
<td style="text-align:left">确保 Load1 数据的装载，之前于 Load2 及所有后续装载指令的装载。</td>
</tr>
<tr>
<td style="text-align:left">StoreStore Barriers</td>
<td style="text-align:left">Store1; StoreStore; Store2</td>
<td style="text-align:left">确保 Store1 数据对其他处理器可见（刷新到内存），之前于 Store2 及所有后续存储指令的存储。</td>
</tr>
<tr>
<td style="text-align:left">LoadStore Barriers</td>
<td style="text-align:left">Load1; LoadStore; Store2</td>
<td style="text-align:left">确保 Load1 数据装载，之前于 Store2 及所有后续的存储指令刷新到内存。</td>
</tr>
<tr>
<td style="text-align:left">StoreLoad Barriers</td>
<td style="text-align:left">Store1; StoreLoad; Load2</td>
<td style="text-align:left">确保 Store1 数据对其他处理器变得可见（指刷新到内存），之前于 Load2 及所有后续装载指令的装载。StoreLoad 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</td>
</tr>
</tbody>
</table>
<p><code>StoreLoad</code>是一个<strong>全能型</strong>的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p>
<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>从 JDK5 开始，java 使用新的<code>JSR-133</code>内存模型（本文除非特别说明，针对的都是<code>JSR-133</code>内存模型）。<code>JSR-133</code>提出了<code>happens-before</code>的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在<code>happens-before</code>关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。 与程序员密切相关的<code>happens-before</code>规则如下：</p>
<ol>
<li>程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。</li>
<li>监视器锁规则：对一个监视器锁的解锁，happens-before 于随后对这个监视器锁的加锁。</li>
<li>volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</li>
<li>传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。</li>
</ol>
<p>注意，两个操作之间具有<code>happens-before</code>关系，并不意味着前一个操作必须要在后一个操作之前执行！<code>happens-before</code>仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。<code>happens-before</code>的定义很微妙，后文会具体说明<code>happens-before</code>为什么要这么定义。</p>
<img src="/blog/img/java/jmm/ordering-by-a-happens-beforerelationship.png" class="image-md" title="[ordering-by-a-happens-beforerelationship]">
<p><code>happens-before</code>与 JMM 的关系如下图所示：</p>
<img src="/blog/img/java/jmm/jmm-15.png" class="image-md">
<p>如上图所示，一个<code>happens-before</code>规则通常对应于多个编译器重排序规则和处理器重排序规则。对于 java 程序员来说，<code>happens-before</code>规则简单易懂，它避免程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li>Programming Language Pragmatics, Third Edition</li>
<li>The Java Language Specification, Third Edition</li>
<li>JSR-133: Java Memory Model and Thread Specification</li>
<li>Java theory and practice: Fixing the Java Memory Model, Part 2</li>
<li>Understanding POWER Multiprocessors</li>
<li>Concurrent Programming on Windows</li>
<li>The Art of Multiprocessor Programming</li>
<li>Intel® 64 and IA-32 ArchitecturesvSoftware Developer’s Manual Volume 3A: System Programming Guide, Part 1</li>
<li>Java Concurrency in Practice</li>
<li>The JSR-133 Cookbook for Compiler Writers</li>
</ol>
<h2 id="深入理解-Java-内存模型二：重排序"><a href="#深入理解-Java-内存模型二：重排序" class="headerlink" title="深入理解 Java 内存模型二：重排序"></a>深入理解 Java 内存模型二：重排序</h2><h3 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h3><blockquote>
<p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。</p>
</blockquote>
<p>数据依赖分下列三种类型：</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">代码示例</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">写后读</td>
<td style="text-align:left">a = 1;b = a;</td>
<td style="text-align:left">写一个变量之后，再读这个位置。</td>
</tr>
<tr>
<td style="text-align:left">写后写</td>
<td style="text-align:left">a = 1;a = 2;</td>
<td style="text-align:left">写一个变量之后，再写这个变量。</td>
</tr>
<tr>
<td style="text-align:left">读后写</td>
<td style="text-align:left">a = b;b = 1;</td>
<td style="text-align:left">读一个变量之后，再写这个变量。</td>
</tr>
</tbody>
</table>
<p>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p>
<p>前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p>
<p>注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p>
<h3 id="as-if-serial-语义"><a href="#as-if-serial-语义" class="headerlink" title="as-if-serial 语义"></a>as-if-serial 语义</h3><p><code>as-if-serial</code>语义的意思指：</p>
<blockquote>
<p>不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守<code>as-if-serial</code>语义。</p>
</blockquote>
<p>为了遵守<code>as-if-serial</code>语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> pi  = <span class="number">3.14</span>;    <span class="comment">// A</span></span><span class="line"><span class="keyword">double</span> r   = <span class="number">1.0</span>;     <span class="comment">// B</span></span><span class="line"><span class="keyword">double</span> area = pi * r * r; <span class="comment">// C</span></span></pre></td></tr></table></figure>
<p>上面三个操作的数据依赖关系如下图所示：</p>
<img src="/blog/img/java/jmm/jmm-21.png" class="image-md">
<p>如上图所示，A 和 C 之间存在数据依赖关系，同时 B 和 C 之间也存在数据依赖关系。因此在最终执行的指令序列中，C 不能被重排序到 A 和 B 的前面（C 排到 A 和 B 的前面，程序的结果将会被改变）。但 A 和 B 之间没有数据依赖关系，编译器和处理器可以重排序 A 和 B 之间的执行顺序。下图是该程序的两种执行顺序：</p>
<img src="/blog/img/java/jmm/jmm-22.png" class="image-md">
<p><code>as-if-serial</code>语义把单线程程序保护了起来，遵守<code>as-if-serial</code>语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：</p>
<blockquote>
<p>单线程程序是按程序的顺序来执行的。<code>as-if-serial</code>语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p>
</blockquote>
<h3 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h3><p>根据<code>happens-before</code>的程序顺序规则，上面计算圆的面积的示例代码存在三个<code>happens-before</code>关系：</p>
<ol>
<li>A happens-before B；</li>
<li>B happens-before C；</li>
<li>A happens-before C；</li>
</ol>
<p>这里的第 3 个<code>happens-before</code>关系，是根据<code>happens-before</code>的传递性推导出来的。</p>
<p>这里 A <code>happens-before</code> B，但实际执行时 B 却可以排在 A 之前执行（看上面的重排序后的执行顺序）。</p>
<p>在第一章提到过，如果 A <code>happens-before</code> B，JMM 并不要求 A 一定要在 B 之前执行。</p>
<p>JMM 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。这里操作 A 的执行结果不需要对操作 B 可见；而且重排序操作 A 和操作 B 后的执行结果，与操作 A 和操作 B 按<code>happens-before</code>顺序执行的结果一致。在这种情况下，JMM 会认为这种重排序并不非法（not illegal），JMM 允许这种重排序。</p>
<p>在计算机中，软件技术和硬件技术有一个共同的目标：</p>
<blockquote>
<p>在不改变程序执行结果的前提下，尽可能的开发并行度。</p>
</blockquote>
<p>编译器和处理器遵从这一目标，从<code>happens-before</code>的定义我们可以看出，JMM 同样遵从这一目标。</p>
<h3 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h3><p>现在让我们来看看，重排序是否会改变多线程程序的执行结果。请看下面的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReorderExample</span> </span>&#123;</span><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><span class="line">        a = <span class="number">1</span>;              <span class="comment">// 1</span></span><span class="line">        flag = <span class="keyword">true</span>;        <span class="comment">// 2</span></span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="function">Public <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><span class="line">        <span class="keyword">if</span> (flag) &#123;         <span class="comment">// 3</span></span><span class="line">            <span class="keyword">int</span> i =  a * a; <span class="comment">// 4</span></span><span class="line">            <span class="comment">// ......</span></span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><code>flag</code> 变量是个标记，用来标识变量 <code>a</code> 是否已被写入。这里假设有两个线程 A 和 B，A 首先执行<code>writer()</code>方法，随后 B 线程接着执行<code>reader()</code>方法。线程 B 在执行操作 4 时，能否看到线程 A 在操作 1 对共享变量 <code>a</code> 的写入？</p>
<blockquote>
<p>答案是：不一定能看到。</p>
</blockquote>
<p>由于操作 1 和操作 2 没有数据依赖关系，编译器和处理器可以对这两个操作重排序；同样，操作 3 和操作 4 没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。让我们先来看看，当操作 1 和操作 2 重排序时，可能会产生什么效果？</p>
<p>请看下面的程序执行时序图：</p>
<img src="/blog/img/java/jmm/jmm-23.png" class="image-md">
<p>如上图所示，操作 1 和操作 2 做了重排序。程序执行时，线程 A 首先写标记变量 <code>flag</code>，随后线程 B 读这个变量。由于条件判断为真，线程 B 将读取变量 <code>a</code>。此时，变量 <code>a</code> 还根本没有被线程 A 写入，在这里多线程程序的语义被重排序破坏了！</p>
<blockquote>
<p>※ 注：本文统一用红色的虚箭线表示错误的读操作，用绿色的虚箭线表示正确的读操作。</p>
</blockquote>
<p>下面再让我们看看，当操作 3 和操作 4 重排序时会产生什么效果（借助这个重排序，可以顺便说明控制依赖性）。下面是操作 3 和操作 4 重排序后，程序的执行时序图：</p>
<img src="/blog/img/java/jmm/jmm-24.png" class="image-md">
<p>在程序中，操作 3 和操作 4 存在控制依赖关系。当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程 B 的处理器可以提前读取并计算<code>a * a</code>，然后把计算结果临时保存到一个名为重排序缓冲（reorder buffer ROB）的硬件缓存中。当接下来操作 3 的条件判断为真时，就把该计算结果写入变量 <code>i</code> 中。</p>
<p>从图中我们可以看出，猜测执行实质上对操作 3 和 4 做了重排序。重排序在这里破坏了多线程程序的语义！</p>
<p>在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是<code>as-if-serial</code>语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p>
<h4 id="Out-Of-Order-Execution-Core"><a href="#Out-Of-Order-Execution-Core" class="headerlink" title="Out-Of-Order Execution Core"></a>Out-Of-Order Execution Core</h4><blockquote>
<p>The out-of-order execution core’s ability to execute instructions out of order is a key factor in enabling parallelism. This feature enables the processor to reorder instructions so that if one micro-op is delayed, other micro-ops may proceed around it. The processor employs several buffers to smooth the flow of micro-ops.</p>
<p>The core is designed to facilitate parallel execution. It can dispatch up to six micro-ops per cycle (this exceeds trace cache and retirement micro-op bandwidth). Most pipelines can start executing a new micro-op every cycle, so several instructions can be in flight at a time for each pipeline. A number of arithmetic logical unit (ALU) instructions can start at two per cycle; many floating-point instructions can start once every two cycles.</p>
</blockquote>
<h4 id="Retirement-Unit"><a href="#Retirement-Unit" class="headerlink" title="Retirement Unit"></a>Retirement Unit</h4><blockquote>
<p>The retirement unit receives the results of the executed micro-ops from the out-of-order execution core and processes the results so that the architectural state updates according to the original program order.</p>
<p>When a micro-op completes and writes its result, it is retired. Up to three micro-ops may be retired per cycle. The Reorder Buffer (ROB) is the unit in the processor which buffers completed micro-ops, updates the architectural state in order, and manages the ordering of exceptions. The retirement section also keeps track of branches and sends updated branch target information to the BTB. The BTB then purges pre-fetched traces that are no longer needed.</p>
</blockquote>
<img src="/blog/img/java/jmm/pipeline-functionality.png" class="image-md" title="[The Intel Core Microarchitecture Pipeline Functionality]">
<img src="/blog/img/java/jmm/cpu-stage-pipeline.png" class="image-md" title="[cpu-stage-pipeline]">
<blockquote>
<p>RISC 机器的五层流水线示意图（IF：读取指令，ID：指令解码，EX：运行，MEM：存储器访问，WB：写回寄存器）</p>
</blockquote>
<h4 id="CPU-乱序执行示例"><a href="#CPU-乱序执行示例" class="headerlink" title="CPU 乱序执行示例"></a>CPU 乱序执行示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutOfOrderExecution</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><span class="line"></span><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><span class="line">        <span class="keyword">boolean</span> z = <span class="keyword">false</span>;</span><span class="line">        <span class="keyword">boolean</span> t = <span class="keyword">false</span>;</span><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><span class="line">            x = y = a = b = <span class="number">0</span>;</span><span class="line"></span><span class="line">            CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><span class="line">            Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><span class="line">                <span class="keyword">try</span> &#123; countDownLatch.await(); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><span class="line">                a = <span class="number">1</span>;</span><span class="line">                x = b;</span><span class="line">            &#125;);</span><span class="line">            Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><span class="line">                <span class="keyword">try</span> &#123; countDownLatch.await(); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><span class="line">                b = <span class="number">1</span>;</span><span class="line">                y = a;</span><span class="line">            &#125;);</span><span class="line"></span><span class="line">            t1.start();</span><span class="line">            t2.start();</span><span class="line"></span><span class="line">            countDownLatch.countDown();</span><span class="line"></span><span class="line">            t1.join();</span><span class="line">            t2.join();</span><span class="line"></span><span class="line">            <span class="keyword">int</span> s = x + y;</span><span class="line">            <span class="keyword">if</span> (s == <span class="number">0</span>) &#123;</span><span class="line">                z = <span class="keyword">true</span>;</span><span class="line">                System.out.println(<span class="string">"("</span> + x + <span class="string">","</span> + y + <span class="string">")"</span>);</span><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">2</span>) &#123;</span><span class="line">                t = <span class="keyword">true</span>;</span><span class="line">                System.out.println(<span class="string">"("</span> + x + <span class="string">","</span> + y + <span class="string">")"</span>);</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="keyword">if</span> (z &amp;&amp; t) &#123;</span><span class="line">                <span class="keyword">return</span>;</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>上述程序运行可能输出的结果如下，并且因为 CPU 指令重排，<code>(1,1)</code> 出现的概率极小，如上示例用<code>CyclicBarrier</code>来替代<code>CountDownLatch</code>控制并发执行后<code>(1,1)</code>出现次数会稍多点：</p>
<blockquote>
<p>(0,0)<br>(0,0)<br>...<br>(0,0)<br>(0,0)<br>(0,0)<br>(1,1)</p>
</blockquote>
<h4 id="JCStress-并发压力测试"><a href="#JCStress-并发压力测试" class="headerlink" title="JCStress 并发压力测试"></a>JCStress 并发压力测试</h4><p>下面的代码用 JCStress 压力测试来输出 CPU 指令重排序的输出结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JCStressTest</span></span><span class="line"><span class="meta">@Outcome</span>(id = &#123;<span class="string">"0, 0"</span>, <span class="string">"0, 2"</span>, <span class="string">"1, 0"</span>&#125;, expect = Expect.ACCEPTABLE, desc = <span class="string">"Normal outcome"</span>)</span><span class="line"><span class="meta">@Outcome</span>(id = &#123;<span class="string">"1, 2"</span>&#125;, expect = Expect.ACCEPTABLE_INTERESTING, desc = <span class="string">"Abnormal outcome"</span>)</span><span class="line"><span class="meta">@State</span></span><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaConcurrentStressExample1</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><span class="line"></span><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><span class="line"></span><span class="line">    <span class="meta">@Actor</span></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(IntResult2 r)</span> </span>&#123;</span><span class="line">        r.r2 = a; <span class="comment">// 读写</span></span><span class="line">        b = <span class="number">1</span>;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="meta">@Actor</span></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(IntResult2 r)</span> </span>&#123;</span><span class="line">        r.r1 = b; <span class="comment">// 读写</span></span><span class="line">        a = <span class="number">2</span>;</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>输出内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JVM options: [-server] Iterations: 5 Time: 1000</span><span class="line"></span><span class="line">Observed state Occurrence Expectation            Interpretation</span><span class="line">0,0            210351     ACCEPTABLE             Normal   outcome</span><span class="line">0,2            11442460   ACCEPTABLE             Normal   outcome</span><span class="line">1,0            11560580   ACCEPTABLE             Normal   outcome</span><span class="line">1,2            129        ACCEPTABLE_INTERESTING Abnormal outcome</span><span class="line"></span><span class="line">JVM options: [-server, -XX:-TieredCompilation] Iterations: 5 Time: 1000</span><span class="line"></span><span class="line">Observed state Occurrence Expectation            Interpretation</span><span class="line">0,0            348152     ACCEPTABLE             Normal   outcome</span><span class="line">0,2            11014622   ACCEPTABLE             Normal   outcome</span><span class="line">1,0            14775737   ACCEPTABLE             Normal   outcome</span><span class="line">1,2            259        ACCEPTABLE_INTERESTING Abnormal outcome</span></pre></td></tr></table></figure>
<h3 id="参考文献-1"><a href="#参考文献-1" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li>Computer Architecture: A Quantitative Approach, 4th Edition</li>
<li>Concurrent Programming on Windows</li>
<li>Concurrent Programming in Java™: Design Principles and Pattern</li>
<li>JSR-133: Java Memory Model and Thread Specification</li>
<li>JSR-133 (Java Memory Model) FAQ</li>
</ol>
<h2 id="深入理解-Java-内存模型三：顺序一致性"><a href="#深入理解-Java-内存模型三：顺序一致性" class="headerlink" title="深入理解 Java 内存模型三：顺序一致性"></a>深入理解 Java 内存模型三：顺序一致性</h2><h3 id="数据竞争与顺序一致性保证"><a href="#数据竞争与顺序一致性保证" class="headerlink" title="数据竞争与顺序一致性保证"></a>数据竞争与顺序一致性保证</h3><p>当程序未正确同步时，就会存在数据竞争。java 内存模型规范对数据竞争的定义如下：</p>
<ol>
<li>在一个线程中写一个变量，</li>
<li>在另一个线程读同一个变量，</li>
<li>而且写和读没有通过同步来排序。</li>
</ol>
<p>当代码中包含数据竞争时，程序的执行往往产生违反直觉的结果（前一章的示例正是如此）。如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序。</p>
<p>JMM 对正确同步的多线程程序的内存一致性做了如下保证：</p>
<p>如果程序是正确同步的，程序的执行将具有顺序一致性（sequentially consistent）--即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同（马上我们将会看到，这对于程序员来说是一个极强的保证）。这里的同步是指广义上的同步，包括对常用<code>同步原语</code>（lock，volatile 和 final）的正确使用。</p>
<h3 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h3><p>顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：</p>
<ol>
<li>一个线程中的所有操作必须按照程序的顺序来执行。</li>
<li>（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li>
</ol>
<p>顺序一致性内存模型为程序员提供的视图如下：</p>
<img src="/blog/img/java/jmm/jmm-31.png" class="image-md">
<p>在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程。同时，每一个线程必须按程序的顺序来执行内存<code>读/写</code>操作。从上图我们可以看出，在任意时间点最多只能有一个线程可以连接到内存。当多个线程并发执行时，图中的开关装置能把所有线程的所有内存<code>读/写</code>操作串行化。</p>
<p>为了更好的理解，下面我们通过两个示意图来对顺序一致性模型的特性做进一步的说明。</p>
<p>假设有两个线程 A 和 B 并发执行。其中 A 线程有三个操作，它们在程序中的顺序是：</p>
<blockquote>
<p><code>A1-&gt;A2-&gt;A3</code></p>
</blockquote>
<p>B 线程也有三个操作，它们在程序中的顺序是：</p>
<blockquote>
<p><code>B1-&gt;B2-&gt;B3</code></p>
</blockquote>
<p>假设这两个线程使用监视器来正确同步，A 线程的三个操作执行后释放监视器，随后 B 线程获取同一个<code>监视器</code>。那么程序在顺序一致性模型中的执行效果将如下图所示：</p>
<img src="/blog/img/java/jmm/jmm-32.png" class="image-md">
<p>现在我们再假设这两个线程没有做同步，下面是这个未同步程序在顺序一致性模型中的执行示意图：</p>
<img src="/blog/img/java/jmm/jmm-33.png" class="image-md">
<p>未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序。以上图为例，线程 A 和 B 看到的执行顺序都是：</p>
<blockquote>
<p><code>B1-&gt;A1-&gt;A2-&gt;B2-&gt;A3-&gt;B3</code></p>
</blockquote>
<p>之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见。</p>
<p>但是，在 JMM 中就没有这个保证。未同步程序在 JMM 中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。比如，在当前线程把写过的数据缓存在本地内存中，且还没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，会认为这个写操作根本还没有被当前线程执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才能对其他线程可见。在这种情况下，当前线程和其它线程看到的操作执行顺序将不一致。</p>
<h3 id="同步程序的顺序一致性效果"><a href="#同步程序的顺序一致性效果" class="headerlink" title="同步程序的顺序一致性效果"></a>同步程序的顺序一致性效果</h3><p>下面我们对前面的示例程序 ReorderExample 用监视器来同步，看看正确同步的程序如何具有顺序一致性。</p>
<p>请看下面的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><span class="line">        a = <span class="number">1</span>;</span><span class="line">        flag = <span class="keyword">true</span>;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><span class="line">            <span class="keyword">int</span> i = a;</span><span class="line">            <span class="comment">// ......</span></span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>上面示例代码中，假设 A 线程执行<code>writer()</code>方法后，B 线程执行<code>reader()</code>方法。这是一个正确同步的多线程程序。根据 JMM 规范，该程序的执行结果将与该程序在顺序一致性模型中的执行结果相同。下面是该程序在两个内存模型中的执行时序对比图：</p>
<img src="/blog/img/java/jmm/jmm-34.png" class="image-md">
<p>在顺序一致性模型中，所有操作完全按程序的顺序串行执行。而在 JMM 中，临界区内的代码可以重排序（但 JMM 不允许临界区内的代码<strong>逸出</strong>到临界区之外，那样会破坏监视器的语义）。JMM 会在退出监视器和进入监视器这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图（具体细节后文会说明）。虽然线程 A 在临界区内做了重排序，但由于监视器的互斥执行的特性，这里的线程 B 根本<strong>无法观察</strong>到线程 A 在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</p>
<p>从这里我们可以看到 JMM 在具体实现上的基本方针：</p>
<blockquote>
<p>在不改变（正确同步的）程序执行结果的前提下，尽可能的为编译器和处理器的优化打开方便之门。</p>
</blockquote>
<h3 id="未同步程序的执行特性"><a href="#未同步程序的执行特性" class="headerlink" title="未同步程序的执行特性"></a>未同步程序的执行特性</h3><p>对于未同步或未正确同步的多线程程序，JMM 只提供最小安全性：</p>
<blockquote>
<p>线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false），JMM 保证线程读操作读取到的值不会无中生有（out of thin air）的冒出来。</p>
</blockquote>
<p>为了实现最小安全性，JVM 在堆上分配对象时，首先会清零内存空间，然后才会在上面分配对象（JVM 内部会同步这两个操作）。因此，在以清零的内存空间（pre-zeroed memory）分配对象时，域的默认初始化已经完成了。</p>
<p>JMM 不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。因为未同步程序在顺序一致性模型中执行时，整体上是无序的，其执行结果无法预知。保证未同步程序在两个模型中的执行结果一致毫无意义。</p>
<p>和顺序一致性模型一样，未同步程序在 JMM 中的执行时，整体上也是无序的，其执行结果也无法预知。同时，未同步程序在这两个模型中的执行特性有下面几个差异：</p>
<ol>
<li>顺序一致性模型保证单线程内的操作会按程序的顺序执行，而 JMM 不保证单线程内的操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）。这一点前面已经讲过了，这里就不再赘述。</li>
<li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而 JMM 不保证所有线程能看到一致的操作执行顺序。这一点前面也已经讲过，这里就不再赘述。</li>
<li>JMM 不保证对 64 位的 long 型和 double 型变量的<code>读/写</code>操作具有原子性，而顺序一致性模型保证对所有的内存<code>读/写</code>操作都具有原子性。</li>
</ol>
<p>第 3 个差异与处理器总线的工作机制密切相关。</p>
<p>在计算机中，数据通过总线在处理器和内存之间传递，每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步骤称之为总线事务（bus transaction）。总线事务包括读事务（read transaction）和写事务（write transaction）。读事务从内存传送数据到处理器，写事务从处理器传送数据到内存，每个事务会<code>读/写</code>内存中一个或多个物理上连续的字。</p>
<p>这里的关键是，总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，总线会禁止其它所有的处理器和 I/O 设备执行内存的<code>读/写</code>。</p>
<p>下面让我们通过一个示意图来说明总线的工作机制：</p>
<img src="/blog/img/java/jmm/jmm-35.png" class="image-md">
<p>如上图所示，假设处理器 A，B 和 C 同时向总线发起总线事务，这时总线仲裁（bus arbitration）会对竞争作出裁决，这里我们假设总线在仲裁后判定处理器 A 在竞争中获胜（总线仲裁会确保所有处理器都能公平的访问内存）。此时处理器 A 继续它的总线事务，而其它两个处理器则要等待处理器 A 的总线事务完成后才能开始再次执行内存访问。假设在处理器 A 执行总线事务期间（不管这个总线事务是读事务还是写事务），处理器 D 向总线发起了总线事务，此时处理器 D 的这个请求会被总线禁止。</p>
<p>总线的这些工作机制可以把所有处理器对内存的访问以串行化的方式来执行；在任意时间点，最多只能有一个处理器能访问内存。这个特性确保了单个总线事务之中的内存<code>读/写</code>操作具有原子性。</p>
<p>在一些 32 位的处理器上，如果要求对 64 位数据的<code>读/写</code>操作具有原子性，会有比较大的开销。为了照顾这种处理器，java 语言规范鼓励但不强求 JVM 对 64 位的 long 型变量和 double 型变量的<code>读/写</code>具有原子性。当 JVM 在这种处理器上运行时，会把一个 64 位 long/ double 型变量的<code>读/写</code>操作拆分为两个 32 位的<code>读/写</code>操作来执行。这两个 32 位的<code>读/写</code>操作可能会被分配到不同的总线事务中执行，此时对这个 64 位变量的<code>读/写</code>将不具有原子性。</p>
<p>当单个内存操作不具有原子性，将可能会产生意想不到后果。</p>
<p>请看下面示意图：</p>
<img src="/blog/img/java/jmm/jmm-36.png" class="image-md">
<p>如上图所示，假设处理器 A 写一个 long 型变量，同时处理器 B 要读这个 long 型变量。处理器 A 中 64 位的写操作被拆分为两个 32 位的写操作，且这两个 32 位的写操作被分配到不同的写事务中执行。同时处理器 B 中 64 位的读操作被拆分为两个 32 位的读操作，且这两个 32 位的读操作被分配到同一个的读事务中执行。当处理器 A 和 B 按上图的时序来执行时，处理器 B 将看到仅仅被处理器 A <strong>写了一半</strong>的无效值。</p>
<h3 id="无缓存处理器指令重排序对程序的影响示例图"><a href="#无缓存处理器指令重排序对程序的影响示例图" class="headerlink" title="无缓存处理器指令重排序对程序的影响示例图"></a>无缓存处理器指令重排序对程序的影响示例图</h3><img src="/blog/img/java/jmm/write-buffers-with-bypassing-capability.png" class="image-lg" title="[write-buffers-with-bypassing-capability]">
<img src="/blog/img/java/jmm/overlapping-write-operations.png" class="image-lg" title="[overlapping-write-operations]">
<img src="/blog/img/java/jmm/non-blocking-read-operations.png" class="image-lg" title="[non-blocking-read-operations]">
<p>上面几个图例原文说明参考链接 <a href="https://www.hpl.hp.com/techreports/Compaq-DEC/WRL-95-7.pdf" target="_blank" rel="noopener">Shared Memory Consistency Models: A Tutorial</a>。</p>
<h3 id="参考文献-2"><a href="#参考文献-2" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><a href="https://www.hpl.hp.com/techreports/Compaq-DEC/WRL-95-7.pdf" target="_blank" rel="noopener">https://www.hpl.hp.com/techreports/Compaq-DEC/WRL-95-7.pdf</a></li>
<li>JSR-133: Java Memory Model and Thread Specification</li>
<li>Shared memory consistency models: A tutorial</li>
<li>The JSR-133 Cookbook for Compiler Writers</li>
<li>深入理解计算机系统（原书第 2 版）</li>
<li>UNIX Systems for Modern Architectures: Symmetric Multiprocessing and Caching for Kernel Programmers</li>
<li>The Java Language Specification, Third Edition</li>
</ol>
<h2 id="深入理解-Java-内存模型四：volatile"><a href="#深入理解-Java-内存模型四：volatile" class="headerlink" title="深入理解 Java 内存模型四：volatile"></a>深入理解 Java 内存模型四：volatile</h2><h3 id="volatile-的特性"><a href="#volatile-的特性" class="headerlink" title="volatile 的特性"></a>volatile 的特性</h3><p>当我们声明共享变量为 volatile 后，对这个变量的<code>读/写</code>将会很特别。理解 volatile 特性的一个好方法是：</p>
<blockquote>
<p>把对 volatile 变量的单个<code>读/写</code>，看成是使用同一个监视器锁对这些单个<code>读/写</code>操作做了同步。</p>
</blockquote>
<p>下面我们通过具体的示例来说明，请看下面的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</span><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> vl = <span class="number">0L</span>; <span class="comment">// 使用 volatile 声明 64 位的 long 型变量</span></span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><span class="line">        vl = l;            <span class="comment">// 单个 volatile 变量的写</span></span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span> <span class="params">()</span> </span>&#123;</span><span class="line">        vl++;              <span class="comment">// 复合（多个）volatile 变量的读/写</span></span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><span class="line">        <span class="keyword">return</span> vl;         <span class="comment">// 单个 volatile 变量的读</span></span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>假设有多个线程分别调用上面程序的三个方法，这个程序在语意上和下面程序等价：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</span><span class="line">    <span class="keyword">long</span> vl = <span class="number">0L</span>;               <span class="comment">// 64 位的 long 型普通变量</span></span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;     <span class="comment">// 对单个的普通变量的写用同一个监视器同步</span></span><span class="line">        vl = l;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span> <span class="params">()</span> </span>&#123; <span class="comment">// 普通方法调用</span></span><span class="line">        <span class="keyword">long</span> temp = get();           <span class="comment">// 调用已同步的读方法</span></span><span class="line">        temp += <span class="number">1L</span>;                  <span class="comment">// 普通写操作</span></span><span class="line">        set(temp);                   <span class="comment">// 调用已同步的写方法</span></span><span class="line">    &#125;</span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><span class="line">        <span class="comment">// 对单个的普通变量的读用同一个监视器同步</span></span><span class="line">        <span class="keyword">return</span> vl;</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>如上面示例程序所示，对一个 volatile 变量的单个<code>读/写</code>操作，与对一个普通变量的<code>读/写</code>操作使用同一个监视器锁来同步，它们之间的执行效果相同。</p>
<p>监视器锁的<code>happens-before</code>规则保证释放监视器和获取监视器的两个线程之间的内存可见性，这意味着对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。</p>
<p>监视器锁的语义决定了临界区代码的执行具有原子性。这意味着即使是 64 位的 long 型和 double 型变量，只要它是 volatile 变量，对该变量的读写就将具有原子性。如果是多个 volatile 操作或类似于<strong><code>volatile++</code></strong>这种复合操作，这些操作整体上<strong>不具有原子性</strong>。</p>
<p>简而言之，volatile 变量自身具有下列特性：</p>
<ol>
<li>可见性：对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。</li>
<li>原子性：对任意单个 volatile 变量的<code>读/写</code>具有原子性，但类似于<strong><code>volatile++</code></strong>这种复合操作<strong>不具有原子性</strong>。</li>
</ol>
<h3 id="volatile-写-读-建立的-happens-before-关系"><a href="#volatile-写-读-建立的-happens-before-关系" class="headerlink" title="volatile 写-读 建立的 happens-before 关系"></a>volatile 写-读 建立的 happens-before 关系</h3><p>上面讲的是 volatile 变量自身的特性，对程序员来说，volatile 对线程的内存可见性的影响比 volatile 自身的特性更为重要，也更需要我们去关注。</p>
<p>从<code>JSR-133</code>开始，volatile 变量的<code>写-读</code>可以实现线程之间的通信。</p>
<p>从内存语义的角度来说，volatile 与监视器锁有相同的效果：</p>
<blockquote>
<p>volatile 写和监视器的释放有相同的内存语义；<br>volatile 读与监视器的获取有相同的内存语义。</p>
</blockquote>
<p>请看下面使用 volatile 变量的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><span class="line">        a = <span class="number">1</span>;                     <span class="comment">// 1</span></span><span class="line">        flag = <span class="keyword">true</span>;               <span class="comment">// 2</span></span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><span class="line">        <span class="keyword">if</span> (flag) &#123;                <span class="comment">// 3</span></span><span class="line">            <span class="keyword">int</span> i =  a;            <span class="comment">// 4</span></span><span class="line">            <span class="comment">// ......</span></span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>假设线程 A 执行<code>writer()</code>方法之后，线程 B 执行<code>reader()</code>方法。根据<code>happens-before</code>规则，这个过程建立的<code>happens-before</code>关系可以分为两类：</p>
<ol>
<li>根据程序次序规则，1 happens-before 2; 3 happens-before 4。</li>
<li>根据 volatile 规则，2 happens-before 3。</li>
<li>根据 happens-before 的传递性规则，1 happens-before 4。</li>
</ol>
<p>上述<code>happens-before</code>关系的图形化表现形式如下：</p>
<img src="/blog/img/java/jmm/jmm-41.png" class="image-md">
<p>在上图中，每一个箭头链接的两个节点，代表了一个<code>happens-before</code>关系。</p>
<ol>
<li>黑色箭头表示程序顺序规则；橙色箭头表示 volatile 规则；</li>
<li>蓝色箭头表示组合这些规则后提供的<code>happens-before</code>保证。</li>
</ol>
<p>这里 A 线程写一个 volatile 变量后，B 线程读同一个 volatile 变量。A 线程在写 volatile 变量之前所有可见的共享变量，在 B 线程读同一个 volatile 变量后，将立即变得对 B 线程可见。</p>
<h3 id="volatile-写-读-的内存语义"><a href="#volatile-写-读-的内存语义" class="headerlink" title="volatile 写-读 的内存语义"></a>volatile 写-读 的内存语义</h3><h4 id="普通共享变量并行读的测试代码"><a href="#普通共享变量并行读的测试代码" class="headerlink" title="普通共享变量并行读的测试代码"></a>普通共享变量并行读的测试代码</h4><p>下面测试代码运行时设置 JVM 参数 <code>-XX:-RestrictContended</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><span class="line"><span class="comment"> * Normal Loads are getfield, getstatic, array load of non-volatile fields.</span></span><span class="line"><span class="comment"> * Normal Stores are putfield, putstatic, array store of non-volatile fields</span></span><span class="line"><span class="comment"> * Volatile Loads are getfield, getstatic of volatile fields that are accessible by multiple threads</span></span><span class="line"><span class="comment"> * Volatile Stores are putfield, putstatic of volatile fields that are accessible by multiple threads</span></span><span class="line"><span class="comment"> * MonitorEnters (including entry to synchronized methods) are for lock objects accessible by multiple threads.</span></span><span class="line"><span class="comment"> * MonitorExits (including exit from synchronized methods) are for lock objects accessible by multiple threads.</span></span><span class="line"><span class="comment"> */</span></span><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentWithoutVolatileRead</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> loop = <span class="number">100_000_000</span>;</span><span class="line">        <span class="keyword">final</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><span class="line">        ConcurrentWithoutVolatileRead example = <span class="keyword">new</span> ConcurrentWithoutVolatileRead();</span><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><span class="line">            <span class="keyword">try</span> &#123;</span><span class="line">                cyclicBarrier.await();</span><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><span class="line">                e.printStackTrace();</span><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><span class="line">                e.printStackTrace();</span><span class="line">            &#125;</span><span class="line">            <span class="keyword">int</span> diff = <span class="number">0</span>;</span><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= loop; j++) &#123;</span><span class="line">                example.i = j; <span class="comment">// putfield</span></span><span class="line">                <span class="keyword">if</span> (example.i != j) &#123; <span class="comment">// getfield</span></span><span class="line">                    diff++;</span><span class="line">                &#125;</span><span class="line">            &#125;</span><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": diff = "</span> + diff);</span><span class="line">        &#125;, <span class="string">"t1"</span>);</span><span class="line"></span><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><span class="line">            <span class="keyword">try</span> &#123;</span><span class="line">                cyclicBarrier.await();</span><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><span class="line">                e.printStackTrace();</span><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><span class="line">                e.printStackTrace();</span><span class="line">            &#125;</span><span class="line">            <span class="keyword">int</span> diff = <span class="number">0</span>;</span><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = loop + <span class="number">1</span>; j &lt;= loop * <span class="number">2</span>; j++) &#123;</span><span class="line">                example.i = j;</span><span class="line">                <span class="keyword">if</span> (example.i != j) &#123;</span><span class="line">                    diff++;</span><span class="line">                &#125;</span><span class="line">            &#125;</span><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": diff = "</span> + diff);</span><span class="line">        &#125;, <span class="string">"t2"</span>);</span><span class="line"></span><span class="line">        <span class="keyword">try</span> &#123;</span><span class="line">            thread1.start();</span><span class="line">            thread2.start();</span><span class="line"></span><span class="line">            thread1.join();</span><span class="line">            thread2.join();</span><span class="line"></span><span class="line">            System.out.println(<span class="string">"example.i : "</span> + example.i);</span><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><span class="line">            e.printStackTrace();</span><span class="line">        &#125;</span><span class="line"></span><span class="line">    &#125;</span><span class="line"></span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>上面的代码运行后产生如下输出，没有 volatile 变量读写操作时，不同线程还是有极小的机会<strong>看见</strong>另一个线程对共享变量的修改：</p>
<blockquote>
<p>t1: diff = 11<br>t2: diff = 21<br>example.i : 200000000</p>
</blockquote>
<p><strong>volatile 写</strong>的内存语义如下：</p>
<blockquote>
<p>当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量刷新到主内存。</p>
</blockquote>
<p>以上面示例程序 VolatileExample 为例，假设线程 A 首先执行<code>writer()</code>方法，随后线程 B 执行<code>reader()</code>方法，初始时两个线程的本地内存中的 <code>flag</code> 和 <code>a</code> 都是初始状态。下图是线程 A 执行 volatile 写后，共享变量的状态示意图：</p>
<img src="/blog/img/java/jmm/jmm-42.png" class="image-md">
<p>如上图所示，线程 A 在写 <code>flag</code> 变量后，本地内存 A 中被线程 A 更新过的两个共享变量的值被刷新到主内存中。此时，本地内存 A 和主内存中的共享变量的值是一致的。</p>
<h4 id="volatile-共享变量写操作并行读示例"><a href="#volatile-共享变量写操作并行读示例" class="headerlink" title="volatile 共享变量写操作并行读示例"></a>volatile 共享变量写操作并行读示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><span class="line"><span class="comment"> * http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-November/007309.html</span></span><span class="line"><span class="comment"> *</span></span><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><span class="line"><span class="comment"> * 如果对 t1 线程中的 volatile 变量 example.v 做写操作，共享变量 example.i 和 example.v 都会被刷回主内存，</span></span><span class="line"><span class="comment"> * 同时 volatile 共享变量的写操作相对于读操作要更耗性能更慢一些，所以 t1 线程要比 t2 线程慢才完成这个循环，</span></span><span class="line"><span class="comment"> * 并且将修改刷回主存，因为底层的各种原因有概率工作线程中的缓存失效，重新从主存读回的共享变量 example.i</span></span><span class="line"><span class="comment"> * 与当前循环所在 j 的值相异比较多。</span></span><span class="line"><span class="comment"> *</span></span><span class="line"><span class="comment"> * 而 t2 线程中没有对 volatile 变量 example.v 读操作时，所以基本上对共享变量的变化没有感知，即不可见：</span></span><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><span class="line"><span class="comment"> */</span></span><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentVolatileWrite</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="meta">@Contended</span>(<span class="string">"g0"</span>)</span><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><span class="line"></span><span class="line">    <span class="meta">@Contended</span>(<span class="string">"g1"</span>)</span><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> v = <span class="keyword">true</span>;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> loop = <span class="number">10_000_000</span>;</span><span class="line">        <span class="keyword">final</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><span class="line">        ConcurrentVolatileWrite example = <span class="keyword">new</span> ConcurrentVolatileWrite();</span><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><span class="line">            <span class="keyword">try</span> &#123;</span><span class="line">                cyclicBarrier.await();</span><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><span class="line">                e.printStackTrace();</span><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><span class="line">                e.printStackTrace();</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="keyword">int</span> diff = <span class="number">0</span>;</span><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= loop; j++) &#123;</span><span class="line">                example.i = j;</span><span class="line">                example.v = <span class="keyword">true</span>; <span class="comment">// volatile write</span></span><span class="line">                <span class="comment">// if (example.v) // volatile read</span></span><span class="line">                <span class="keyword">if</span> (example.i != j) &#123;</span><span class="line">                    diff++;</span><span class="line">                &#125;</span><span class="line">            &#125;</span><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": diff = "</span> + diff);</span><span class="line">        &#125;, <span class="string">"t1"</span>);</span><span class="line"></span><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><span class="line">            <span class="keyword">try</span> &#123;</span><span class="line">                cyclicBarrier.await();</span><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><span class="line">                e.printStackTrace();</span><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><span class="line">                e.printStackTrace();</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="keyword">int</span> diff = <span class="number">0</span>;</span><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = loop + <span class="number">1</span>; j &lt;= loop * <span class="number">10</span>; j++) &#123;</span><span class="line">                example.i = j;</span><span class="line">                <span class="comment">// example.v = true; // volatile write</span></span><span class="line">                <span class="comment">// if (example.v) // volatile read</span></span><span class="line">                <span class="keyword">if</span> (example.i != j) &#123;</span><span class="line">                    diff++;</span><span class="line">                &#125;</span><span class="line">            &#125;</span><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": diff = "</span> + diff);</span><span class="line">        &#125;, <span class="string">"t2"</span>);</span><span class="line"></span><span class="line">        <span class="keyword">try</span> &#123;</span><span class="line">            thread1.start();</span><span class="line">            thread2.start();</span><span class="line"></span><span class="line">            thread1.join();</span><span class="line">            thread2.join();</span><span class="line"></span><span class="line">            System.out.println(<span class="string">"example.i : "</span> + example.i);</span><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><span class="line">            e.printStackTrace();</span><span class="line">        &#125;</span><span class="line"></span><span class="line">    &#125;</span><span class="line"></span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>上面示例代码运行之后生成如下结果，其中因为 volatile 共享变量写操作慢，所以 t1 线程结果输出要慢于 t2 线程（t2 线程循环次数也比 t1 线程多），t2 线程中的普通读操作，对 t1 线程中的 volatile 写操作是看不见的，虽然 t1 线程中已经将共享变量同步回缓存了。</p>
<blockquote>
<p>t2: diff = 2<br>t1: diff = 42685<br>example.i : 10000000</p>
</blockquote>
<p><strong>volatile 读</strong>的内存语义如下：</p>
<blockquote>
<p>当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。</p>
</blockquote>
<p>下面是线程 B 读同一个 volatile 变量后，共享变量的状态示意图：</p>
<img src="/blog/img/java/jmm/jmm-43.png" class="image-md">
<p>如上图所示，在读 <code>flag</code> 变量后，本地内存 B 已经被置为无效。此时，线程 B 必须从主内存中读取共享变量。线程 B 的读取操作将导致本地内存 B 与主内存中的共享变量的值也变成一致的了。</p>
<p>如果我们把 volatile 写和 volatile 读这两个步骤综合起来看的话，在读线程 B 读一个 volatile 变量后，写线程 A 在写这个 volatile 变量之前所有可见的共享变量的值都将立即变得对读线程 B 可见。</p>
<h4 id="普通读和-volatile-读并行示例"><a href="#普通读和-volatile-读并行示例" class="headerlink" title="普通读和 volatile 读并行示例"></a>普通读和 volatile 读并行示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><span class="line"><span class="comment"> * http://www.aligelenler.com/2017/02/volatile-variable-false-sharing-and.html</span></span><span class="line"><span class="comment"> *</span></span><span class="line"><span class="comment"> * Cache Lines and False Sharing:</span></span><span class="line"><span class="comment"> *</span></span><span class="line"><span class="comment"> * CPU's read memory in some block of bytes, usually 64 bytes. We call this block of bytes as cache lines. Generally a</span></span><span class="line"><span class="comment"> *maintain consistency on cache line basis, that means if any single byte of a cache line is changed all cache line</span></span><span class="line"><span class="comment"> * is invalited and this invalidation takes place for all cpu's in cluster.</span></span><span class="line"><span class="comment"> *</span></span><span class="line"><span class="comment"> */</span></span><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentVolatileRead</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="meta">@Contended</span>(<span class="string">"g0"</span>)</span><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><span class="line"></span><span class="line">    <span class="meta">@Contended</span>(<span class="string">"g1"</span>)</span><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> v = <span class="keyword">true</span>;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> loop = <span class="number">10_000_000</span>;</span><span class="line">        <span class="keyword">final</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><span class="line"></span><span class="line">        ConcurrentVolatileRead example = <span class="keyword">new</span> ConcurrentVolatileRead();</span><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><span class="line">            <span class="keyword">try</span> &#123;</span><span class="line">                cyclicBarrier.await();</span><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><span class="line">                e.printStackTrace();</span><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><span class="line">                e.printStackTrace();</span><span class="line">            &#125;</span><span class="line">            <span class="keyword">int</span> diff = <span class="number">0</span>;</span><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= loop; j++) &#123;</span><span class="line">                example.i = j;</span><span class="line">                <span class="comment">// example.v = true;</span></span><span class="line">                <span class="keyword">if</span> (example.v) <span class="comment">// volatile read</span></span><span class="line">                    <span class="keyword">if</span> (example.i != j) &#123; <span class="comment">// getfield #2 // Field i:I</span></span><span class="line">                        diff++;</span><span class="line">                    &#125;</span><span class="line">            &#125;</span><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": diff = "</span> + diff);</span><span class="line">        &#125;, <span class="string">"t1"</span>);</span><span class="line"></span><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><span class="line">            <span class="keyword">try</span> &#123;</span><span class="line">                cyclicBarrier.await();</span><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><span class="line">                e.printStackTrace();</span><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><span class="line">                e.printStackTrace();</span><span class="line">            &#125;</span><span class="line">            <span class="keyword">int</span> diff = <span class="number">0</span>;</span><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = loop + <span class="number">1</span>; j &lt;= loop * <span class="number">10</span>; j++) &#123;</span><span class="line">                example.i = j;</span><span class="line">                <span class="comment">// example.v = true;</span></span><span class="line"></span><span class="line">                <span class="comment">// if (example.v) // volatile read</span></span><span class="line">                <span class="keyword">if</span> (example.i != j) &#123;</span><span class="line">                    diff++;</span><span class="line">                &#125;</span><span class="line">            &#125;</span><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": diff = "</span> + diff);</span><span class="line">        &#125;, <span class="string">"t2"</span>);</span><span class="line"></span><span class="line">        <span class="keyword">try</span> &#123;</span><span class="line">            thread1.start();</span><span class="line">            thread2.start();</span><span class="line"></span><span class="line">            thread1.join();</span><span class="line">            thread2.join();</span><span class="line"></span><span class="line">            System.out.println(<span class="string">"example.i : "</span> + example.i);</span><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><span class="line">            e.printStackTrace();</span><span class="line">        &#125;</span><span class="line"></span><span class="line">    &#125;</span><span class="line"></span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>上面示例运行输出类似如下：</p>
<blockquote>
<p>t2: diff = 1<br>t1: diff = 23249<br>example.i : 10000000</p>
</blockquote>
<p>t2 线程因为没有对 volatile 变量<code>example.v</code>读取，所以对<code>example.i</code>变量是否改变不可见，所以基本上<code>example.i != j</code>的情况很少。<br>t1 线程则因为有对 volatile 变量<code>example.v</code>读操作，线程执行速度相比 t2 线程稍慢，并对 t2 线程中的<code>example.i</code>变量改变可见，所以发生<code>example.i != j</code>的情况要比 t2 线程更多。</p>
<h4 id="volatile-读写内存语义总绕结"><a href="#volatile-读写内存语义总绕结" class="headerlink" title="volatile 读写内存语义总绕结"></a>volatile 读写内存语义总绕结</h4><p>下面对 volatile 写和 volatile 读的内存语义做个总结：</p>
<ol>
<li>线程 A 写一个 volatile 变量，实质上是线程 A 向接下来将要读这个 volatile 变量的某个线程发出了（其对共享变量做过修改的）消息。</li>
<li>线程 B 读一个 volatile 变量，实质上是线程 B 接收了之前某个线程发出的（其他线程在写这个 volatile 变量之前对共享变量所做修改的）消息。</li>
<li>线程 A 写一个 volatile 变量，随后线程 B 读这个 volatile 变量，这个过程实质上是线程 A 通过主内存向线程 B 发送消息。</li>
</ol>
<h3 id="volatile-内存语义的实现"><a href="#volatile-内存语义的实现" class="headerlink" title="volatile 内存语义的实现"></a>volatile 内存语义的实现</h3><p>下面，让我们来看看 JMM 如何实现 volatile <code>写-读</code>的内存语义。</p>
<p>前文我们提到过重排序分为编译器重排序和处理器重排序。为了实现 volatile 内存语义，JMM 会分别限制这两种类型的重排序类型。</p>
<p>下面是 JMM 针对编译器制定的 volatile 重排序规则表：</p>
<img src="/blog/img/java/jmm/jmm-reorder-rules.png" class="image-md" title="[jmm-reorder-rules.png]">
<table>    <thead>        <tr>            <th style="text-align:left">是否能重排序</th>            <th style="text-align:center" colspan="3">第二个操作</th>        </tr>    </thead>    <tbody>        <tr>            <td style="text-align:left">第一个操作</td>            <td style="text-align:left">普通读/写</td>            <td style="text-align:left">volatile 读</td>            <td style="text-align:left">volatile 写</td>        </tr>        <tr>            <td style="text-align:left">普通读/写</td>            <td style="text-align:left"></td>            <td style="text-align:left"></td>            <td style="text-align:left">NO</td>        </tr>        <tr>            <td style="text-align:left">volatile 读</td>            <td style="text-align:left">NO</td>            <td style="text-align:left">NO</td>            <td style="text-align:left">NO</td>        </tr>        <tr>            <td style="text-align:left">volatile 写</td>            <td style="text-align:left"></td>            <td style="text-align:left">NO</td>            <td style="text-align:left">NO</td>        </tr>    </tbody></table>

<p>举例来说，第三行最后一个单元格的意思是：</p>
<blockquote>
<p>在程序顺序中，当第一个操作为普通变量的读或写时，如果第二个操作为 volatile 写，则编译器不能重排序这两个操作。</p>
</blockquote>
<p>从上表我们可以看出：</p>
<ol>
<li>当第二个操作是 volatile 写时，不管第一个操作是什么，都不能重排序。这个规则确保 volatile 写之前的操作不会被编译器重排序到 volatile 写之后。</li>
<li>当第一个操作是 volatile 读时，不管第二个操作是什么，都不能重排序。这个规则确保 volatile 读之后的操作不会被编译器重排序到 volatile 读之前。</li>
<li>当第一个操作是 volatile 写，第二个操作是 volatile 读时，不能重排序。</li>
</ol>
<p>为了实现 volatile 的内存语义，编译器在生成字节码时，会在指令序列中插入<strong>内存屏障</strong>来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，JMM 采取保守策略。</p>
<p>下面是基于保守策略的 JMM 内存屏障插入策略：</p>
<ol>
<li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li>
<li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li>
<li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li>
<li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li>
</ol>
<p>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的 volatile 内存语义。</p>
<img src="/blog/img/java/jmm/jmm-barriers-ordering-rule.png" class="image-lg" title="[jmm-barriers-ordering-rule]">
<blockquote>
<p>Plus the special final-field rule requiring a StoreStore barrier in <code>x.finalField = v;</code> StoreStore; <code>sharedRef = x;</code></p>
</blockquote>
<h4 id="volatile-禁止重排序测试"><a href="#volatile-禁止重排序测试" class="headerlink" title="volatile 禁止重排序测试"></a>volatile 禁止重排序测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JCStressTest</span></span><span class="line"><span class="meta">@Outcome</span>(id = &#123;<span class="string">"0, 0"</span>, <span class="string">"0, 2"</span>, <span class="string">"1, 0"</span>&#125;, expect = Expect.ACCEPTABLE, desc = <span class="string">"Normal outcome"</span>)</span><span class="line"><span class="meta">@Outcome</span>(id = &#123;<span class="string">"1, 2"</span>&#125;, expect = Expect.ACCEPTABLE_INTERESTING, desc = <span class="string">"Abnormal outcome"</span>)</span><span class="line"><span class="meta">@State</span></span><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaConcurrentStressExample2</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><span class="line"></span><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> b = <span class="number">0</span>;</span><span class="line"></span><span class="line">    <span class="meta">@Actor</span></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(IntResult2 r)</span> </span>&#123;</span><span class="line">        r.r2 = a;</span><span class="line">        b = <span class="number">1</span>; <span class="comment">// 第二个写操作是 volatile 写</span></span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="meta">@Actor</span></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(IntResult2 r)</span> </span>&#123;</span><span class="line">        r.r1 = b; <span class="comment">// 第一个操作是 volatile 读</span></span><span class="line">        a = <span class="number">2</span>;</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>运行输出报告如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JVM options: [-server] Iterations: 5 Time: 1000</span><span class="line"></span><span class="line">Observed state Occurrence Expectation            Interpretation</span><span class="line">0,0            67954      ACCEPTABLE             Normal   outcome</span><span class="line">0,2            15715991   ACCEPTABLE             Normal   outcome</span><span class="line">1,0            5445985    ACCEPTABLE             Normal   outcome</span><span class="line">1,2            0          ACCEPTABLE_INTERESTING Abnormal outcome</span><span class="line"></span><span class="line">JVM options: [-server, -XX:-TieredCompilation] Iterations: 5 Time: 1000</span><span class="line"></span><span class="line">Observed state Occurrence Expectation            Interpretation</span><span class="line">0,0            272725     ACCEPTABLE             Normal   outcome</span><span class="line">0,2            16361513   ACCEPTABLE             Normal   outcome</span><span class="line">1,0            9323562    ACCEPTABLE             Normal   outcome</span><span class="line">1,2            0          ACCEPTABLE_INTERESTING Abnormal outcome</span></pre></td></tr></table></figure>
<h4 id="volatile-重排序测试"><a href="#volatile-重排序测试" class="headerlink" title="volatile 重排序测试"></a>volatile 重排序测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JCStressTest</span></span><span class="line"><span class="meta">@Outcome</span>(id = &#123;<span class="string">"0, 2"</span>, <span class="string">"1, 0"</span>&#125;, expect = Expect.ACCEPTABLE, desc = <span class="string">"Normal outcome"</span>)</span><span class="line"><span class="meta">@Outcome</span>(id = &#123;<span class="string">"0, 0"</span>&#125;, expect = Expect.ACCEPTABLE_INTERESTING, desc = <span class="string">"Normal outcome"</span>)</span><span class="line"><span class="meta">@Outcome</span>(id = &#123;<span class="string">"1, 2"</span>&#125;, expect = Expect.ACCEPTABLE_INTERESTING, desc = <span class="string">"Normal outcome"</span>)</span><span class="line"><span class="meta">@State</span></span><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaConcurrentStressExample4</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><span class="line"></span><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> b = <span class="number">0</span>;</span><span class="line"></span><span class="line">    <span class="meta">@Actor</span></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(IntResult2 r)</span> </span>&#123;</span><span class="line">        b = <span class="number">1</span>; <span class="comment">// 第一个操作是 volatile 写操作，写读仍然会重排序</span></span><span class="line">        r.r2 = a;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="meta">@Actor</span></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(IntResult2 r)</span> </span>&#123;</span><span class="line">        a = <span class="number">2</span>; <span class="comment">// 写读</span></span><span class="line">        r.r1 = b; <span class="comment">// 第二个操作是 volatile 读操作，写读仍然会重排序</span></span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>运行输出报告如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JVM options: [-server, -XX:-TieredCompilation] Iterations: 5 Time: 1000</span><span class="line"></span><span class="line">Observed state Occurrence Expectation            Interpretation</span><span class="line">0,0            177960     ACCEPTABLE_INTERESTING Normal outcome</span><span class="line">0,2            17203654   ACCEPTABLE             Normal outcome</span><span class="line">1,0            8153691    ACCEPTABLE             Normal outcome</span><span class="line">1,2            1015       ACCEPTABLE_INTERESTING Normal outcome</span><span class="line"></span><span class="line">JVM options: [-server] Iterations: 5 Time: 1000</span><span class="line"></span><span class="line">Observed state Occurrence Expectation            Interpretation</span><span class="line">0,0            66304      ACCEPTABLE_INTERESTING Normal outcome</span><span class="line">0,2            13360900   ACCEPTABLE             Normal outcome</span><span class="line">1,0            5129092    ACCEPTABLE             Normal outcome</span><span class="line">1,2            384        ACCEPTABLE_INTERESTING Normal outcome</span></pre></td></tr></table></figure>
<h4 id="内存屏障插入位置与-java-代码对比示例"><a href="#内存屏障插入位置与-java-代码对比示例" class="headerlink" title="内存屏障插入位置与 java 代码对比示例"></a>内存屏障插入位置与 java 代码对比示例</h4><img src="/blog/img/java/jmm/jmm-memory-fence-placements.png" class="image-md" title="[jmm-memory-fence-placements]">
<p>下面是保守策略下，volatile 写插入内存屏障后生成的指令序列示意图：</p>
<img src="/blog/img/java/jmm/jmm-44.png" class="image-md">
<p>上图中的<code>StoreStore</code>屏障可以保证在 volatile 写之前，其前面的所有普通写操作已经对任意处理器可见了。这是因为<code>StoreStore</code>屏障将保障上面所有的普通写在 volatile 写之前刷新到主内存。</p>
<p>这里比较有意思的是 volatile 写后面的<code>StoreLoad</code>屏障。这个屏障的作用是避免 volatile 写与后面可能有的 volatile <code>读/写</code>操作重排序。因为编译器常常无法准确判断在一个 volatile 写的后面，是否需要插入一个<code>StoreLoad</code>屏障（比如，一个 volatile 写之后方法立即 return）。为了保证能正确实现 volatile 的内存语义，JMM 在这里采取了保守策略：</p>
<blockquote>
<p>在每个 volatile 写的后面或在每个 volatile 读的前面插入一个<code>StoreLoad</code>屏障。</p>
</blockquote>
<p>从整体执行效率的角度考虑，JMM 选择了在每个 volatile 写的后面插入一个<code>StoreLoad</code>屏障。因为 volatile <code>写-读</code>内存语义的常见使用模式是：</p>
<blockquote>
<p>一个写线程写 volatile 变量，多个读线程读同一个 volatile 变量。</p>
</blockquote>
<p>当读线程的数量大大超过写线程时，选择在 volatile 写之后插入<code>StoreLoad</code>屏障将带来可观的执行效率的提升。</p>
<p>从这里我们可以看到 JMM 在实现上的一个特点：</p>
<blockquote>
<p>首先确保正确性，然后再去追求执行效率。</p>
</blockquote>
<p>下面是在保守策略下，volatile 读插入内存屏障后生成的指令序列示意图：</p>
<img src="/blog/img/java/jmm/jmm-45.png" class="image-md">
<p>上图中的<code>LoadLoad</code>屏障用来禁止处理器把上面的 volatile 读与下面的普通读重排序，<code>LoadStore</code>屏障用来禁止处理器把上面的 volatile 读与下面的普通写重排序（下面的普通读写可能重排序，因此多加了一个<code>LoadStore</code>屏障）。</p>
<p>上述 volatile 写和 volatile 读的内存屏障插入策略非常保守。在实际执行时，只要不改变 volatile <code>写-读</code>的内存语义，编译器可以根据具体情况省略不必要的屏障。下面我们通过具体的示例代码来说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileBarrierExample</span> </span>&#123;</span><span class="line">    <span class="keyword">int</span> a;</span><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> v1 = <span class="number">1</span>;</span><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> v2 = <span class="number">2</span>;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readAndWrite</span><span class="params">()</span> </span>&#123;</span><span class="line">        <span class="keyword">int</span> i = v1;           <span class="comment">// 第一个 volatile 读</span></span><span class="line">        <span class="keyword">int</span> j = v2;           <span class="comment">// 第二个 volatile 读</span></span><span class="line">        a = i + j;            <span class="comment">// 普通写</span></span><span class="line">        v1 = i + <span class="number">1</span>;           <span class="comment">// 第一个 volatile 写</span></span><span class="line">        v2 = j * <span class="number">2</span>;           <span class="comment">// 第二个 volatile 写</span></span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="comment">// ......                 // 其他方法</span></span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>针对<code>readAndWrite()</code>方法，编译器在生成字节码时可以做如下的优化：</p>
<img src="/blog/img/java/jmm/jmm-46.png" class="image-md">
<p>注意，最后的<code>StoreLoad</code>屏障不能省略。因为第二个 volatile 写之后，方法立即 return。此时编译器可能无法准确断定后面是否会有 volatile 读或写，为了安全起见，编译器常常会在这里插入一个<code>StoreLoad</code>屏障。</p>
<p>上面的优化是针对任意处理器平台，由于不同的处理器有不同<strong>松紧度</strong>的处理器内存模型，内存屏障的插入还可以根据具体的处理器内存模型继续优化。以 x86 处理器为例，上图中除最后的<code>StoreLoad</code>屏障外，其它的屏障都会被省略。</p>
<p>前面保守策略下的 volatile 读和写，在 x86 处理器平台可以优化成：</p>
<img src="/blog/img/java/jmm/jmm-47.png" class="image-md">
<h3 id="x86-架构的内存屏障"><a href="#x86-架构的内存屏障" class="headerlink" title="x86 架构的内存屏障"></a>x86 架构的内存屏障</h3><p>x86 架构并没有实现全部的内存屏障。</p>
<h4 id="Store-Barrier"><a href="#Store-Barrier" class="headerlink" title="Store Barrier"></a>Store Barrier</h4><p>SFENCE 指令实现了<code>Store Barrier</code>，相当于<code>StoreStore Barriers</code>。</p>
<p>强制所有在 SFENCE 指令之前的 store 指令，都在该 SFENCE 指令执行之前被执行，发送缓存失效信号，并把 store buffer 中的数据刷出到 CPU 的 L1 Cache 中；所有在 SFENCE 指令之后的 store 指令，都在该 SFENCE 指令执行之后被执行。即禁止对 SFENCE 指令前后 store 指令的重排序跨越 SFENCE 指令，使所有<code>Store Barrier</code>之前发生的内存更新都是可见的。</p>
<p>这里的<code>可见</code>，指修改值可见（内存可见性）且操作结果可见（禁用重排序）。</p>
<p>内存屏障的标准中，讨论的是缓存与内存间的相干性，实际上，同样适用于寄存器与缓存、甚至寄存器与内存间等多级缓存之间，寄存器实际也是一种 Memory，只是历史原因，被命名为了寄存器。</p>
<p>x86 架构使用了<code>MESI</code>协议的一个变种（MESIF），由协议保证三层缓存与内存间的相关性，则内存屏障只需要保证 store buffer（可以认为是寄存器与 L1 Cache 间的一层缓存）与 L1 Cache 间的相干性。</p>
<h4 id="Load-Barrier"><a href="#Load-Barrier" class="headerlink" title="Load Barrier"></a>Load Barrier</h4><p>x86 的 LFENCE 指令实现了<code>Load Barrier</code>，相当于<code>LoadLoad Barriers</code>，强制所有在 LFENCE 指令之后的 load 指令，都在该 LFENCE 指令执行之后被执行，并且一直等到 load buffer 被该 CPU 读完才能执行之后的 load 指令（发现缓存失效后发起的刷入）。即禁止对 LFENCE 指令前后 load 指令的重排序跨越 LFENCE 指令，配合<code>Store Barrier</code>，使所有<code>Store Barrier</code>之前发生的内存更新，对<code>Load Barrier</code>之后的 load 操作都是可见的。</p>
<h4 id="Full-Barrier"><a href="#Full-Barrier" class="headerlink" title="Full Barrier"></a>Full Barrier</h4><p>MFENCE 指令实现了<code>Full Barrier</code>，相当于<code>StoreLoad Barriers</code>，MFENCE 指令综合了 SFENCE 指令与 LFENCE 指令的作用，强制所有在 MFENCE 指令之前的 store/load 指令，都在该 MFENCE 指令执行之前被执行；所有在 MFENCE 指令之后的 store/load 指令，都在该 MFENCE 指令执行之后被执行。即禁止对 MFENCE 指令前后 store/load 指令的重排序跨越 MFENCE 指令，使所有<code>Full Barrier</code>之前发生的操作，对所有<code>Full Barrier</code>之后的操作都是可见的。</p>
<h4 id="SSE2-Cacheability-Control-and-Ordering-Instructions"><a href="#SSE2-Cacheability-Control-and-Ordering-Instructions" class="headerlink" title="SSE2 Cacheability Control and Ordering Instructions"></a>SSE2 Cacheability Control and Ordering Instructions</h4><blockquote>
<p>SSE2 cacheability control instructions provide additional operations for caching of non-temporal data when storing data from XMM registers to memory. LFENCE and MFENCE provide additional control of instruction ordering on store operations.</p>
<p>LFENCE: Serializes load operations.<br>MFENCE: Serializes load and store operations.</p>
</blockquote>
<h4 id="LFENCE-Load-Fence"><a href="#LFENCE-Load-Fence" class="headerlink" title="LFENCE - Load Fence"></a>LFENCE - Load Fence</h4><blockquote>
<p>Performs a serializing operation on all load-from-memory instructions that were issued prior the LFENCE instruction. Specifically, LFENCE does not execute until all prior instructions have completed locally, and no later instruction begins execution until LFENCE completes. In particular, an instruction that loads from memory and that precedes an LFENCE receives data from memory prior to completion of the LFENCE. (An LFENCE that follows an instruction that stores to memory might complete before the data being stored have become globally visible.) Instructions following an LFENCE may be fetched from memory before the LFENCE, but they will not execute (even speculatively) until the LFENCE completes.</p>
<p>Weakly ordered memory types can be used to achieve higher processor performance through such techniques as out-of-order issue and speculative reads. The degree to which a consumer of data recognizes or knows that the data is weakly ordered varies among applications and may be unknown to the producer of this data. The LFENCE instruction provides a performance-efficient way of ensuring load ordering between routines that produce weakly-ordered results and routines that consume that data.</p>
<p>Processors are free to fetch and cache data speculatively from regions of system memory that use the WB, WC, and WT memory types. This speculative fetching can occur at any time and is not tied to instruction execution. Thus, it is not ordered with respect to executions of the LFENCE instruction; data can be brought into the caches speculatively just before, during, or after the execution of an LFENCE instruction.</p>
<p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.<br>Specification of the instruction&#39;s opcode above indicates a ModR/M byte of E8. For this instruction, the processor ignores the r/m field of the ModR/M byte. Thus, LFENCE is encoded by any opcode of the form 0F AE Ex, where x is in the range 8-F.</p>
</blockquote>
<h4 id="MFENCE-Memory-Fence"><a href="#MFENCE-Memory-Fence" class="headerlink" title="MFENCE - Memory Fence"></a>MFENCE - Memory Fence</h4><blockquote>
<p>Performs a serializing operation on all load-from-memory and store-to-memory instructions that were issued prior the MFENCE instruction. This serializing operation guarantees that every load and store instruction that precedes the MFENCE instruction in program order becomes globally visible before any load or store instruction that follows the MFENCE instruction.1 The MFENCE instruction is ordered with respect to all load and store instructions, other MFENCE instructions, any LFENCE and SFENCE instructions, and any serializing instructions (such as the CPUID instruction). MFENCE does not serialize the instruction stream.</p>
<p>Weakly ordered memory types can be used to achieve higher processor performance through such techniques as out-of-order issue, speculative reads, write-combining, and write-collapsing. The degree to which a consumer of data recognizes or knows that the data is weakly ordered varies among applications and may be unknown to the producer of this data. The MFENCE instruction provides a performance-efficient way of ensuring load and store ordering between routines that produce weakly-ordered results and routines that consume that data.</p>
<p>Processors are free to fetch and cache data speculatively from regions of system memory that use the WB, WC, and WT memory types. This speculative fetching can occur at any time and is not tied to instruction execution. Thus, it is not ordered with respect to executions of the MFENCE instruction; data can be brought into the caches specula- tively just before, during, or after the execution of an MFENCE instruction.</p>
<p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p>
<p>Specification of the instruction&#39;s opcode above indicates a ModR/M byte of F0. For this instruction, the processor ignores the r/m field of the ModR/M byte. Thus, MFENCE is encoded by any opcode of the form 0F AE Fx, where x is in the range 0-7.</p>
</blockquote>
<h4 id="Memory-Ordering-Instructions"><a href="#Memory-Ordering-Instructions" class="headerlink" title="Memory Ordering Instructions"></a>Memory Ordering Instructions</h4><blockquote>
<p>SSE2 extensions introduce two new fence instructions (LFENCE and MFENCE) as companions to the SFENCE instruction introduced with SSE extensions.</p>
<p>The LFENCE instruction establishes a memory fence for loads. It guarantees ordering between two loads and prevents speculative loads from passing the load fence (that is, no speculative loads are allowed until all loads specified before the load fence have been carried out).</p>
<p>The MFENCE instruction establishes a memory fence for both loads and stores. The processor ensures that no load or store after MFENCE will become globally visible until all loads and stores before MFENCE are globally visible.<br>Note that the sequences <code>LFENCE;SFENCE</code> and <code>SFENCE;LFENCE</code> are not equivalent to MFENCE because neither ensures that older stores are globally observed prior to younger loads.</p>
</blockquote>
<h4 id="x86-架构下-Hotspot-对-volatile-变量的处理"><a href="#x86-架构下-Hotspot-对-volatile-变量的处理" class="headerlink" title="x86 架构下 Hotspot 对 volatile 变量的处理"></a>x86 架构下 Hotspot 对 volatile 变量的处理</h4><p>x86 处理器仅会对 <code>写-读</code> 操作做重排序。</p>
<p>X86 不会对 <code>读-读</code>，<code>读-写</code> 和 <code>写-写</code> 操作做重排序，因此在 x86 处理器中会省略掉这三种操作类型对应的内存屏障。在 x86 中，JMM 仅需在 volatile 写后面插入一个<code>StoreLoad</code>屏障即可正确实现 volatile <code>写-读</code> 的内存语义。</p>
<p>虽然 x86 Intel 有一个 MFENCE 内存屏障指令可以实现 volatile <code>写-读</code> 的内存语义，但在 Hotspot JVM 虚拟机的实现上，HotSpot 是通过指令<code>lock addl $0x0,(%rsp)</code>实现刷缓冲的目的，而非 MFENCE，看源码注释应该是出于性能的考虑，关于 LOCK 前缀更多说明可参考下面 Intel 开发者手册，HotSpot <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/f3108e56b502/src/cpu/x86/vm/assembler_x86.hpp" target="_blank" rel="noopener">源码</a>摘录部分如下：</p>
<figure class="highlight hpp"><figcaption><span>http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/f3108e56b502/src/cpu/x86/vm/assembler_x86.hpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1283</span><span class="line">1284</span><span class="line">1285</span><span class="line">1286</span><span class="line">1287</span><span class="line">1288</span><span class="line">1289</span><span class="line">1290</span><span class="line">1291</span><span class="line">1292</span><span class="line">1293</span><span class="line">1294</span><span class="line">1295</span><span class="line">1296</span><span class="line">1297</span><span class="line">1298</span><span class="line">1299</span><span class="line">1300</span><span class="line">1301</span><span class="line">1302</span><span class="line">1303</span><span class="line">1304</span><span class="line">1305</span><span class="line">1306</span><span class="line">1307</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Membar_mask_bits &#123;</span><span class="line">  StoreStore = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><span class="line">  LoadStore  = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><span class="line">  StoreLoad  = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><span class="line">  LoadLoad   = <span class="number">1</span> &lt;&lt; <span class="number">0</span></span><span class="line">&#125;;</span><span class="line"></span><span class="line"><span class="comment">// Serializes memory and blows flags</span></span><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">membar</span><span class="params">(Membar_mask_bits order_constraint)</span> </span>&#123;</span><span class="line">  <span class="keyword">if</span> (os::is_MP()) &#123;</span><span class="line">    <span class="comment">// We only have to handle StoreLoad</span></span><span class="line">    <span class="keyword">if</span> (order_constraint &amp; StoreLoad) &#123;</span><span class="line">      <span class="comment">// All usable chips support "locked" instructions which suffice</span></span><span class="line">      <span class="comment">// as barriers, and are much faster than the alternative of</span></span><span class="line">      <span class="comment">// using cpuid instruction. We use here a locked add [esp],0.</span></span><span class="line">      <span class="comment">// This is conveniently otherwise a no-op except for blowing</span></span><span class="line">      <span class="comment">// flags.</span></span><span class="line">      <span class="comment">// Any change to this code may need to revisit other places in</span></span><span class="line">      <span class="comment">// the code where this idiom is used, in particular the</span></span><span class="line">      <span class="comment">// orderAccess code.</span></span><span class="line">      lock();</span><span class="line">      addl(Address(rsp, <span class="number">0</span>), <span class="number">0</span>);<span class="comment">// Assert the lock# signal here</span></span><span class="line">    &#125;</span><span class="line">  &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="关于-Memory-Caches-MESI-说明-The-Art-of-Multiprocessor-Programming"><a href="#关于-Memory-Caches-MESI-说明-The-Art-of-Multiprocessor-Programming" class="headerlink" title="关于 Memory/Caches/MESI 说明 (The Art of Multiprocessor Programming)"></a>关于 Memory/Caches/MESI 说明 (The Art of Multiprocessor Programming)</h3><h4 id="Memory-和-Cache-的读写速度比较"><a href="#Memory-和-Cache-的读写速度比较" class="headerlink" title="Memory 和 Cache 的读写速度比较"></a>Memory 和 Cache 的读写速度比较</h4><p>Memory 和 L1 cache 的读写速度分别为<code>0.5 ns</code>和<code>100 ns</code>，二者相差 200 倍，参考如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Latency Comparison Numbers (~2012)</span><span class="line">----------------------------------</span><span class="line">L1 cache reference                           0.5 ns</span><span class="line">Branch mispredict                            5   ns</span><span class="line">L2 cache reference                           7   ns                      14x L1 cache</span><span class="line">Mutex lock/unlock                           25   ns</span><span class="line">Main memory reference                      100   ns                      20x L2 cache, 200x L1 cache</span><span class="line">Compress 1K bytes with Zippy             3,000   ns        3 us</span><span class="line">Send 1K bytes over 1 Gbps network       10,000   ns       10 us</span><span class="line">Read 4K randomly from SSD*             150,000   ns      150 us          ~1GB/sec SSD</span><span class="line">Read 1 MB sequentially from memory     250,000   ns      250 us</span><span class="line">Round trip within same datacenter      500,000   ns      500 us</span><span class="line">Read 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory</span><span class="line">Disk seek                           10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip</span><span class="line">Read 1 MB sequentially from disk    20,000,000   ns   20,000 us   20 ms  80x memory, 20X SSD</span><span class="line">Send packet CA-&gt;Netherlands-&gt;CA    150,000,000   ns  150,000 us  150 ms</span><span class="line"></span><span class="line">Notes</span><span class="line">-----</span><span class="line">1 ns = 10^-9 seconds</span><span class="line">1 us = 10^-6 seconds = 1,000 ns</span><span class="line">1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns</span><span class="line"></span><span class="line">Credit</span><span class="line">------</span><span class="line">By Jeff Dean:               http://research.google.com/people/jeff/</span><span class="line">Originally by Peter Norvig: http://norvig.com/21-days.html#answers</span><span class="line"></span><span class="line">Contributions</span><span class="line">-------------</span><span class="line">&apos;Humanized&apos; comparison:  https://gist.github.com/hellerbarde/2843375</span><span class="line">Visual comparison chart: http://i.imgur.com/k0t1e.png</span></pre></td></tr></table></figure>
<h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><blockquote>
<p>Processors share a main memory, which is a large array of words, indexed by address. Depending on the platform, a word is typically either 32 or 64 bits, and so is an address. Simplifying somewhat, a processor reads a value from memory by sending a message containing the desired address to memory. The response message contains the associated data, that is, the contents of memory at that address. A processor writes a value by sending the address and the new data to memory, and the memory sends back an acknowledgment when the new data has been installed.</p>
</blockquote>
<h4 id="Caches"><a href="#Caches" class="headerlink" title="Caches"></a>Caches</h4><blockquote>
<p>Unfortunately, on modern architectures a main memory access may take hundreds of cycles, so there is a real danger that a processor may spend much of its time just waiting for the memory to respond to requests. We can alleviate this problem by introducing one or more caches: small memories that are situated closer to the processors and are therefore much faster than memory. These caches are logically situated “between” the processor and the memory: when a processor attempts to read a value from a given memory address, it first looks to see if the value is already in the cache, and if so, it does not need to perform the slower access to memory. If the desired address’s value was found, we say the processor hits in the cache, and otherwise it misses. In a similar way, if a processor attempts to write an address that is in the cache, it does not need to perform the slower access to memory. The proportion of requests satisfied in the cache is called the cache hit ratio (or hit rate).</p>
<p>Caches are effective because most programs display a high degree of locality: if a processor reads or writes a memory address (also called a memory location), then it is likely to read or write the same location again soon. Moreover, if a processor reads or writes a memory location, then it is also likely to read or write nearby locations soon. To exploit this second observation, caches typically operate at a granularity larger than a single word: a cache holds a group of neighboring words called cache lines (sometimes called cache blocks).</p>
<p>In practice, most processors have two levels of caches, called the L1 and L2 caches. The L1 cache typically resides on the same chip as the processor, and takes one or two cycles to access. The L2 cache may reside either on or off-chip, and may take tens of cycles to access. Both are significantly faster than the hundreds of cycles required to access the memory. Of course, these times vary from platform to platform, and many multiprocessors have even more elaborate cache structures.</p>
<p>The original proposals for NUMA architectures did not include caches because it was felt that local memory was enough. Later, however, commercial NUMA architectures did include caches. Sometimes the term cc-NUMA (for cachecoherent NUMA) is used to mean NUMA architectures with caches. Here, to avoid ambiguity, we use NUMA to include cache-coherence unless we explicitly state otherwise.</p>
<p>Caches are expensive to build and therefore significantly smaller than the memory: only a fraction of the memory locations will fit in a cache at the same time. We would therefore like the cache to maintain values of the most highly used locations. This implies that when a location needs to be cached and the cache is full, it is necessary to evict a line, discarding it if it has not been modified, and writing it back to main memory if it has. A replacement policy determines which cache line to replace to make room for a given new location. If the replacement policy is free to replace any line then we say the cache is fully associative. If, on the other hand, there is only one line that can be replaced then we say the cache is direct mapped. If we split the difference, allowing any line from a set of size k to be replaced to make room for a given line, then we say the cache is k-way set associative.</p>
</blockquote>
<h4 id="Coherence"><a href="#Coherence" class="headerlink" title="Coherence"></a>Coherence</h4><blockquote>
<p>Sharing (or, less politely, memory contention), occurs when one processor reads or writes a memory address that is cached by another. If both processors are reading the data without modifying it, then the data can be cached at both processors. If, however, one processor tries to update the shared cache line, then the other’s copy must be invalidated to ensure that it does not read an out-of-date value. In its most general form, this problem is called cache coherence. The literature contains a variety of very complex and clever cache coherence protocols. Here we review one of the most commonly used, called the MESI protocol (pronounced <code>messy</code>) after the names of possible cache line states. This protocol has been used in the Pentium and PowerPC processors. Here are the cache line states.</p>
<ol>
<li>Modified: the line has been modified in the cache. and it must eventually be written back to main memory. No other processor has this line cached.</li>
<li>Exclusive: the line has not been modified, and no other processor has this line cached.</li>
<li>Shared: the line has not been modified, and other processors may have this line cached.</li>
<li>Invalid: the line does not contain meaningful data.</li>
</ol>
<p>We illustrate this protocol by a short example depicted in Fig. B.5. For simplicity, we assume processors and memory are linked by a bus.</p>
</blockquote>
<img src="/blog/img/java/jmm/mesi-protocal.png" class="image-lg" title="[mesi-protocal]">
<blockquote>
<p>Processor A reads data from address a, and stores the data in its cache in the exclusive state. When processor B attempts to read from the same address, A detects the address conflict, and responds with the associated data. Now a is cached at both A and B in the shared state. If B writes to the shared address a, it changes its state to modified, and broadcasts a message warning A (and any other processor that might have that data cached) to set its cache line state to invalid. If A then reads from a, it broadcasts a request, and B responds by sending the modified data both to A and to the main memory, leaving both copies in the shared state.</p>
<p>False sharing occurs when processors that are accessing logically distinct data nevertheless conflict because the locations they are accessing lie on the same cache line. This observation illustrates a difficult tradeoff: large cache lines are good for locality, but they increase the likelihood of false sharing. The likelihood of false sharing can be reduced by ensuring that data objects that might be accessed concurrently by independent threads lie far enough apart in memory. For example, having multiple threads share a byte array invites false sharing, but having them share an array of double-precision integers is less dangerous.</p>
</blockquote>
<h4 id="Spinning"><a href="#Spinning" class="headerlink" title="Spinning"></a>Spinning</h4><blockquote>
<p>A processor is spinning if it is repeatedly testing some word in memory, waiting for another processor to change it. Depending on the architecture, spinning can have a dramatic effect on overall system performance.</p>
<p>On an SMP architecture without caches, spinning is a very bad idea. Each time the processor reads the memory, it consumes bus bandwidth without accomplishing any useful work. Because the bus is a broadcast medium, these requests directed to memory may prevent other processors from making progress.</p>
<p>On a NUMA architecture without caches, spinning may be acceptable if the address in question resides in the processor’s local memory. Even though multi-processor architectures without caches are rare, we will still ask when we consider a synchronization protocol that involves spinning, whether it permits each processor to spin on its own local memory.</p>
<p>On an SMP or NUMA architecture with caches, spinning consumes significantly fewer resources. The first time the processor reads the address, it takes a cache miss, and loads the contents of that address into a cache line. Thereafter, as long as that data remains unchanged, the processor simply rereads from its own cache, consuming no interconnect bandwidth, a process known as local spinning. When the cache state changes, the processor takes a single cache miss, observes that the data has changed, and stops spinning.</p>
</blockquote>
<h4 id="Relaxed-Memory-Consistency"><a href="#Relaxed-Memory-Consistency" class="headerlink" title="Relaxed Memory Consistency"></a>Relaxed Memory Consistency</h4><blockquote>
<p>When a processor writes a value to memory, that value is kept in the cache and marked as dirty, meaning that it must eventually be written back to main memory. On most modern processors, write requests are not applied to memory when they are issued. Rather, they are collected in a hardware queue, called a write buffer (or store buffer), and applied to memory together at a later time. A write buffer provides two benefits. First, it is often more efficient to issue a number of requests all at once, a phenomenon called batching. Second, if a thread writes to an address more than once, the earlier request can be discarded, saving a trip to memory, a phenomenon called write absorption.</p>
</blockquote>
<h4 id="x86-架构与内存屏障"><a href="#x86-架构与内存屏障" class="headerlink" title="x86 架构与内存屏障"></a>x86 架构与内存屏障</h4><p>cache 的引入一定程度上缓解了 cpus 与 memory 速度不匹配的问题，MESI 解决了 cache 数据一致性的问题。但是这又出现了新的问题，cpu 之间通信存在延迟，所以在 cpu 与 cache 中间加入了 store buffers，由于 store buffers 非常小，cpu 执行几个 store 操作就会把 buffer 填满, 这时候 CPU 必须等待 invalidation ACK 消息，来释放缓冲区空间 —— invalidation ACK 消息的记录会同步到 cache 中，并从 store buffer 中移除，所以在这里引入 Invalidate Queues。更多说明可参考 Paul Mckenney 的 <a href="http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf" target="_blank" rel="noopener">Memory Barriers: a Hardware View for Software Hackers</a> 和兰州大学 MARS Team 的这个 PPT，<a href="http://lzz5235.github.io/assets/resource/slides.pdf" target="_blank" rel="noopener">Memory Barriers: a Hardware View for Software Hackers</a>，x86 系统架构示意图如下：</p>
<img src="/blog/img/java/jmm/caches-with-invalidate-queues.png" class="image-md" title="[caches-with-invalidate-queues]">
<h4 id="Interconnect"><a href="#Interconnect" class="headerlink" title="Interconnect"></a>Interconnect</h4><blockquote>
<p>The interconnect is the medium by which processors communicate with the memory and with other processors. There are essentially two kinds of interconnect architectures in use: SMP (symmetric multiprocessing) and NUMA (nonuniform memory access).<br>In an SMP architecture, processors and memory are linked by a bus interconnect, a broadcast medium that acts like a tiny Ethernet. Both processors and the main memory have bus controller units in charge of sending and listening for messages broadcast on the bus. (Listening is sometimes called snooping). Today, SMP architectures are the most common, because they are the easiest to build, but they are not scalable to large numbers of processors because eventually the bus becomes overloaded.</p>
</blockquote>
<h4 id="Store-Buffer"><a href="#Store-Buffer" class="headerlink" title="Store Buffer"></a>Store Buffer</h4><blockquote>
<p>Intel 64 and IA-32 processors temporarily store each write (store) to memory in a store buffer. The store buffer improves processor performance by allowing the processor to continue executing instructions without having to wait until a write to memory and/or to a cache is complete. It also allows writes to be delayed for more efficient use of memory-access bus cycles.</p>
<p>In general, the existence of the store buffer is transparent to software, even in systems that use multiple processors. The processor ensures that write operations are always carried out in program order. It also insures that the contents of the store buffer are always drained to memory in the following situations:</p>
<ol>
<li>When an <strong>exception</strong> or <strong>interrupt</strong> is generated.</li>
<li>(P6 and more recent processor families only) When a <strong>serializing</strong> instruction is executed.</li>
<li>When an <strong>I/O</strong> instruction is executed.</li>
<li>When a <strong>LOCK</strong> operation is performed.</li>
<li>(P6 and more recent processor families only) When a <strong>BINIT</strong> operation is performed.</li>
<li>(Pentium III, and more recent processor families only) When using an <strong>SFENCE</strong> instruction to order stores.</li>
<li>(Pentium 4 and more recent processor families only) When using an <strong>MFENCE</strong> instruction to order stores.</li>
</ol>
</blockquote>
<h4 id="CPU-Intel-i7-Shared-L3-Cache"><a href="#CPU-Intel-i7-Shared-L3-Cache" class="headerlink" title="CPU Intel i7 Shared L3 Cache"></a>CPU Intel i7 Shared L3 Cache</h4><img src="/blog/img/java/jmm/cpu-caches-intel-i7.png" class="image-md" title="[cpu-caches-intel-i7]">
<blockquote>
<p>上图中每个核上有两个 L1 Cache, L1-D 存数据, L1-I 存指令。</p>
</blockquote>
<img src="/blog/img/java/jmm/cache-structure-of-the-intel-core-i7-processors.png" class="image-md" title="[cache-structure-of-the-intel-core-i7-processors]">
<p>有了<code>invalidate queue</code>的 CPU，在收到 invalidate 消息的时候首先把它放入<code>invalidate queue</code>，同时立刻回送 acknowledge 消息，无需等到该 cacheline 被真正 invalidate 之后再回应。</p>
<blockquote>
<p>读屏障作用于<code>invalidate queue</code>，每次遇到这个指令都将自己积压已久的<code>invalidate ack</code>处理掉，具体就是使得对应的缓存失效，这样自己再读的时候，能保证读到最新的副本。<br>写屏障作用于<code>store buffer</code>，将处于<code>store buffer</code>中的写操作真正执行掉，具体就是向其他 CPU 发送<code>invalidate cache</code>的消息，写自己的独占缓存。<br>全能型屏障这两件事都做。</p>
</blockquote>
<h3 id="关于为何禁止重排序的说明"><a href="#关于为何禁止重排序的说明" class="headerlink" title="关于为何禁止重排序的说明"></a>关于为何禁止重排序的说明</h3><p>可以从上面<code>VolatileExample</code>例子中对<code>flag = true</code>的写操作示意图可以看到，这个操作之前的另一个写操作<code>a = 1</code>的结果也会因为缓存中的共享变量会被写回主存，而让别的线程一定能看到<code>a</code>的值也发生变化了，如果在 volatile 写之前的其他写操作重排序到 volatile 写之后，那该变量的写操作就不一定能被别的线程所观察到，这是为了保证共享变量的<strong>可见性</strong>。同样 volatile 写之前的普通读操作不能重排序到写之后，可以避免读到别的线程在 volatile 写之后对普通读<strong>共享变量</strong>的修改，读到不应该读到的新值。</p>
<h4 id="普通读和-volatile-写重排序说明"><a href="#普通读和-volatile-写重排序说明" class="headerlink" title="普通读和 volatile 写重排序说明"></a>普通读和 volatile 写重排序说明</h4><p>举例 2 个线程正确的次序如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">执行次序</th>
<th style="text-align:center">线程 A</th>
<th style="text-align:center">线程 B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">load shared a;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">store volatile b;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"></td>
<td style="text-align:center">load volatile b;</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center"></td>
<td style="text-align:center">store shared a;</td>
</tr>
</tbody>
</table>
<p>如果线程 A 中的普通读可以重排序到 volatile 写之后，则可能产生如下的执行次序：</p>
<table>
<thead>
<tr>
<th style="text-align:center">执行次序</th>
<th style="text-align:center">线程 A</th>
<th style="text-align:center">线程 B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">store volatile b;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
<td style="text-align:center">load volatile b;</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"></td>
<td style="text-align:center">store shared a;</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">load shared a; // wrong</td>
<td style="text-align:center">&nbsp;</td>
</tr>
</tbody>
</table>
<h4 id="volatile-读和普通写重排序说明"><a href="#volatile-读和普通写重排序说明" class="headerlink" title="volatile 读和普通写重排序说明"></a>volatile 读和普通写重排序说明</h4><p>volatile 读操作会清空本地<strong>共享变量</strong>的缓存。</p>
<table>
<thead>
<tr>
<th style="text-align:center">执行次序</th>
<th style="text-align:center">线程 A</th>
<th style="text-align:center">线程 B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center">load volatile a;</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
<td style="text-align:center">load shared b;</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">load volatile a;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">store shared b;</td>
<td style="text-align:center">&nbsp;</td>
</tr>
</tbody>
</table>
<p>如果普通写可以重排序到 volatile 写之前的话，另一个线程 B 就可能看到不应该看到的<code>b</code>的新值。</p>
<table>
<thead>
<tr>
<th style="text-align:center">执行次序</th>
<th style="text-align:center">线程 A</th>
<th style="text-align:center">线程 B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">store shared b; // wrong</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center">load volatile a;</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
<td style="text-align:center">load shared b;</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">load volatile a;</td>
<td style="text-align:center">&nbsp;</td>
</tr>
</tbody>
</table>
<h4 id="volatile-读和普通读重排序说明"><a href="#volatile-读和普通读重排序说明" class="headerlink" title="volatile 读和普通读重排序说明"></a>volatile 读和普通读重排序说明</h4><p>普通读重排序到 volatile 读之前也可能会因为别的线程对此<strong>共享变量</strong>有更新而没有正确读到更新的值。举例 2 个线程正确的执行次序如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">执行次序</th>
<th style="text-align:center">线程 A</th>
<th style="text-align:center">线程 B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center">store shared b;</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
<td style="text-align:center">store volatile a;</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">load volatile a;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">load shared b;</td>
<td style="text-align:center">&nbsp;</td>
</tr>
</tbody>
</table>
<p>如果线程 A 中的普通共享变量<code>b</code>的读操作重排序到 volatile 读之前，那可能产生的执行次序：</p>
<table>
<thead>
<tr>
<th style="text-align:center">执行次序</th>
<th style="text-align:center">线程 A</th>
<th style="text-align:center">线程 B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">load shared b; // wrong</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
<td style="text-align:center">store shared b;</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"></td>
<td style="text-align:center">store volatile a;</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">load volatile a;</td>
<td style="text-align:center">&nbsp;</td>
</tr>
</tbody>
</table>
<p>那共享变量<code>b</code>已经把旧值从缓存中加载到 CPU 中，然后 volatile 读清掉缓存，没有重排序情况下会从主存中加载到最新的<code>b</code>值，但上面重排序之后共享变量<code>b</code>没有在正确读到更新后的值。</p>
<p>总结一句话就是：</p>
<blockquote>
<p>重排序会造成共享变量在不同线程之间的可见性问题。</p>
</blockquote>
<h3 id="JSR-133-为什么要增强-volatile-的内存语义"><a href="#JSR-133-为什么要增强-volatile-的内存语义" class="headerlink" title="JSR-133 为什么要增强 volatile 的内存语义"></a>JSR-133 为什么要增强 volatile 的内存语义</h3><p>在<code>JSR-133</code>之前的旧 Java 内存模型中，虽然不允许 volatile 变量之间重排序，但旧的 Java 内存模型允许 volatile 变量与普通变量之间重排序。在旧的内存模型中，VolatileExample 示例程序可能被重排序成下列时序来执行：</p>
<img src="/blog/img/java/jmm/jmm-48.png" class="image-md">
<p>在旧的内存模型中，当 1 和 2 之间没有数据依赖关系时，1 和 2 之间就可能被重排序（3 和 4 类似）。</p>
<p>其结果就是：</p>
<blockquote>
<p>读线程 B 执行 4 时，不一定能看到写线程 A 在执行 1 时对共享变量的修改。</p>
</blockquote>
<p>因此在旧的内存模型中 ，volatile 的<code>写-读</code>没有监视器的<strong>释放/获取</strong>所具有的内存语义。为了提供一种比监视器锁更轻量级的线程之间通信的机制，<code>JSR-133</code>专家组决定增强 volatile 的内存语义：</p>
<blockquote>
<p>严格限制编译器和处理器对 volatile 变量与普通变量的重排序，确保 volatile 的<code>写-读</code>和监视器的<strong>释放/获取</strong>一样，具有相同的内存语义。</p>
</blockquote>
<p>从编译器重排序规则和处理器内存屏障插入策略来看，只要 volatile 变量与普通变量之间的重排序可能会破坏 volatile 的内存语意，这种重排序就会被编译器重排序规则和处理器内存屏障插入策略禁止。</p>
<p>由于 volatile 仅仅保证对单个 volatile 变量的<code>读/写</code>具有原子性，而监视器锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。在功能上，监视器锁比 volatile 更强大；在可伸缩性和执行性能上，volatile 更有优势。如果读者想在程序中用 volatile 代替监视器锁，请一定谨慎。</p>
<h3 id="java-XX-PrintAssembly-查看-volatile-底层实现"><a href="#java-XX-PrintAssembly-查看-volatile-底层实现" class="headerlink" title="java -XX:+PrintAssembly 查看 volatile 底层实现"></a>java -XX:+PrintAssembly 查看 volatile 底层实现</h3><p>使用<code>-XX:PrintAssembly</code>来查看程序运行时输出的反汇编结果，其中在注释里也给了一些文档链接，并且需要下载平台相关的<code>hsdis-xxxxx.xxx</code>文件，更多细节可查看 <a href="https://github.com/yuweijun/hsdis" target="_blank" rel="noopener">https://github.com/yuweijun/hsdis</a> 项目说明，并将此文件放到<code>${JAVA_HOME}/jre/lib/server/</code>目录或者是<code>${JAVA_HOME}/jre/lib/amd64/server/</code>目录下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span><span class="line">27</span><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><span class="line"><span class="comment"> * PrintAssembly 相关的文档参考</span></span><span class="line"><span class="comment"> *</span></span><span class="line"><span class="comment"> * http://psy-lob-saw.blogspot.com/2013/01/java-print-assembly.html</span></span><span class="line"><span class="comment"> *</span></span><span class="line"><span class="comment"> * https://wiki.openjdk.java.net/display/HotSpot/PrintAssembly</span></span><span class="line"><span class="comment"> *</span></span><span class="line"><span class="comment"> * http://www.cs.virginia.edu/~evans/cs216/guides/x86.html</span></span><span class="line"><span class="comment"> *</span></span><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><span class="line"><span class="comment"> * $ sudo cp build/macosx-amd64/hsdis-amd64.dylib $(/usr/libexec/java_home -v 1.8)/jre/lib/server/</span></span><span class="line"><span class="comment"> * ## or</span></span><span class="line"><span class="comment"> * $ sudo cp build/linux-amd64/hsdis-amd64.so /usr/lib/jvm/java-8-oracle/jre/lib/amd64/server/</span></span><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><span class="line"><span class="comment"> *</span></span><span class="line"><span class="comment"> * <span class="doctag">@author</span> yuweijun 2019-03-30.</span></span><span class="line"><span class="comment"> */</span></span><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintAssemblyVolatile</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><span class="line">        PrintAssemblyVolatile example = <span class="keyword">new</span> PrintAssemblyVolatile();</span><span class="line">        example.i++;</span><span class="line">        System.out.println(example.i);</span><span class="line">    &#125;</span><span class="line"></span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>编译上面的代码之后，用如下命令运行此程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><i class="fa fa-usd"></i> <span class="built_in">java</span> -server -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+TraceClassLoading -XX:+PrintAssembly -XX:+LogCompilation -XX:LogFile=jit.log PrintAssemblyVolatile</span></pre></td></tr></table></figure>
<p>程序输出内容比较多，生成的<code>jit.log</code>文件可以使用 <a href="https://github.com/AdoptOpenJDK/jitwatch" target="_blank" rel="noopener">JITWatch</a> 工具进行查看，其中关键部分如下所示，注意其中行号<code>63</code>至<code>70</code>行这部分关于 volatile 共享变量的<code>getfield i</code>和<code>putfield i</code>的操作，<code>x86</code>架构的 CPU 中只在 volatile 写之后加了<code>lock</code>前缀以达到<code>内存屏障</code>效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><span class="line">2</span><span class="line">3</span><span class="line">4</span><span class="line">5</span><span class="line">6</span><span class="line">7</span><span class="line">8</span><span class="line">9</span><span class="line">10</span><span class="line">11</span><span class="line">12</span><span class="line">13</span><span class="line">14</span><span class="line">15</span><span class="line">16</span><span class="line">17</span><span class="line">18</span><span class="line">19</span><span class="line">20</span><span class="line">21</span><span class="line">22</span><span class="line">23</span><span class="line">24</span><span class="line">25</span><span class="line">26</span><span class="line">27</span><span class="line">28</span><span class="line">29</span><span class="line">30</span><span class="line">31</span><span class="line">32</span><span class="line">33</span><span class="line">34</span><span class="line">35</span><span class="line">36</span><span class="line">37</span><span class="line">38</span><span class="line">39</span><span class="line">40</span><span class="line">41</span><span class="line">42</span><span class="line">43</span><span class="line">44</span><span class="line">45</span><span class="line">46</span><span class="line">47</span><span class="line">48</span><span class="line">49</span><span class="line">50</span><span class="line">51</span><span class="line">52</span><span class="line">53</span><span class="line">54</span><span class="line">55</span><span class="line">56</span><span class="line">57</span><span class="line">58</span><span class="line">59</span><span class="line">60</span><span class="line">61</span><span class="line">62</span><span class="line">63</span><span class="line">64</span><span class="line">65</span><span class="line">66</span><span class="line">67</span><span class="line">68</span><span class="line">69</span><span class="line">70</span><span class="line">71</span><span class="line">72</span><span class="line">73</span><span class="line">74</span><span class="line">75</span><span class="line">76</span><span class="line">77</span><span class="line">78</span><span class="line">79</span><span class="line">80</span><span class="line">81</span><span class="line">82</span><span class="line">83</span><span class="line">84</span><span class="line">85</span><span class="line">86</span><span class="line">87</span><span class="line">88</span><span class="line">89</span><span class="line">90</span><span class="line">91</span><span class="line">92</span><span class="line">93</span><span class="line">94</span><span class="line">95</span><span class="line">96</span><span class="line">97</span><span class="line">98</span><span class="line">99</span><span class="line">100</span><span class="line">101</span><span class="line">102</span><span class="line">103</span><span class="line">104</span><span class="line">105</span><span class="line">106</span><span class="line">107</span><span class="line">108</span><span class="line">109</span><span class="line">110</span><span class="line">111</span><span class="line">112</span><span class="line">113</span><span class="line">114</span><span class="line">115</span><span class="line">116</span><span class="line">117</span><span class="line">118</span><span class="line">119</span><span class="line">120</span><span class="line">121</span><span class="line">122</span><span class="line">123</span><span class="line">124</span><span class="line">125</span><span class="line">126</span><span class="line">127</span><span class="line">128</span><span class="line">129</span><span class="line">130</span><span class="line">131</span><span class="line">132</span><span class="line">133</span><span class="line">134</span><span class="line">135</span><span class="line">136</span><span class="line">137</span><span class="line">138</span><span class="line">139</span><span class="line">140</span><span class="line">141</span><span class="line">142</span><span class="line">143</span><span class="line">144</span><span class="line">145</span><span class="line">146</span><span class="line">147</span><span class="line">148</span><span class="line">149</span><span class="line">150</span><span class="line">151</span><span class="line">152</span><span class="line">153</span><span class="line">154</span><span class="line">155</span><span class="line">156</span><span class="line">157</span><span class="line">158</span><span class="line">159</span><span class="line">160</span><span class="line">161</span><span class="line">162</span><span class="line">163</span><span class="line">164</span><span class="line">165</span><span class="line">166</span><span class="line">167</span><span class="line">168</span><span class="line">169</span><span class="line">170</span><span class="line">171</span><span class="line">172</span><span class="line">173</span><span class="line">174</span><span class="line">175</span><span class="line">176</span><span class="line">177</span><span class="line">178</span><span class="line">179</span><span class="line">180</span><span class="line">181</span><span class="line">182</span><span class="line">183</span><span class="line">184</span><span class="line">185</span><span class="line">186</span><span class="line">187</span><span class="line">188</span><span class="line">189</span><span class="line">190</span><span class="line">191</span><span class="line">192</span><span class="line">193</span><span class="line">194</span><span class="line">195</span><span class="line">196</span><span class="line">197</span><span class="line">198</span><span class="line">199</span><span class="line">200</span><span class="line">201</span><span class="line">202</span><span class="line">203</span><span class="line">204</span><span class="line">205</span><span class="line">206</span><span class="line">207</span><span class="line">208</span><span class="line">209</span><span class="line">210</span><span class="line">211</span><span class="line">212</span><span class="line">213</span><span class="line">214</span><span class="line">215</span><span class="line">216</span><span class="line">217</span><span class="line">218</span><span class="line">219</span><span class="line">220</span><span class="line">221</span><span class="line">222</span><span class="line">223</span><span class="line">224</span><span class="line">225</span><span class="line">226</span><span class="line">227</span><span class="line">228</span><span class="line">229</span><span class="line">230</span><span class="line">231</span><span class="line">232</span><span class="line">233</span><span class="line">234</span><span class="line">235</span><span class="line">236</span><span class="line">237</span><span class="line">238</span><span class="line">239</span><span class="line">240</span><span class="line">241</span><span class="line">242</span><span class="line">243</span><span class="line">244</span><span class="line">245</span><span class="line">246</span><span class="line">247</span><span class="line">248</span><span class="line">249</span><span class="line">250</span><span class="line">251</span><span class="line">252</span><span class="line">253</span><span class="line">254</span><span class="line">255</span><span class="line">256</span><span class="line">257</span><span class="line">258</span><span class="line">259</span><span class="line">260</span><span class="line">261</span><span class="line">262</span><span class="line">263</span><span class="line">264</span><span class="line">265</span><span class="line">266</span><span class="line">267</span><span class="line">268</span><span class="line">269</span><span class="line">270</span><span class="line">271</span><span class="line">272</span><span class="line">273</span><span class="line">274</span><span class="line">275</span><span class="line">276</span><span class="line">277</span><span class="line">278</span><span class="line">279</span><span class="line">280</span><span class="line">281</span><span class="line">282</span><span class="line">283</span><span class="line">284</span><span class="line">285</span><span class="line">286</span><span class="line">287</span><span class="line">288</span><span class="line">289</span><span class="line">290</span><span class="line">291</span><span class="line">292</span><span class="line">293</span><span class="line">294</span><span class="line">295</span><span class="line">296</span><span class="line">297</span><span class="line">298</span><span class="line">299</span><span class="line">300</span><span class="line">301</span><span class="line">302</span><span class="line">303</span><span class="line">304</span><span class="line">305</span><span class="line">306</span><span class="line">307</span><span class="line">308</span><span class="line">309</span><span class="line">310</span><span class="line">311</span><span class="line">312</span><span class="line">313</span><span class="line">314</span><span class="line">315</span><span class="line">316</span><span class="line">317</span><span class="line">318</span><span class="line">319</span><span class="line">320</span><span class="line">321</span><span class="line">322</span><span class="line">323</span><span class="line">324</span><span class="line">325</span><span class="line">326</span><span class="line">327</span><span class="line">328</span><span class="line">329</span><span class="line">330</span><span class="line">331</span><span class="line">332</span><span class="line">333</span><span class="line">334</span><span class="line">335</span><span class="line">336</span><span class="line">337</span><span class="line">338</span><span class="line">339</span><span class="line">340</span><span class="line">341</span><span class="line">342</span><span class="line">343</span><span class="line">344</span><span class="line">345</span><span class="line">346</span><span class="line">347</span><span class="line">348</span><span class="line">349</span><span class="line">350</span><span class="line">351</span><span class="line">352</span><span class="line">353</span><span class="line">354</span><span class="line">355</span><span class="line">356</span><span class="line">357</span><span class="line">358</span><span class="line">359</span><span class="line">360</span><span class="line">361</span><span class="line">362</span><span class="line">363</span><span class="line">364</span><span class="line">365</span><span class="line">366</span><span class="line">367</span><span class="line">368</span><span class="line">369</span><span class="line">370</span><span class="line">371</span><span class="line">372</span><span class="line">373</span><span class="line">374</span><span class="line">375</span><span class="line">376</span><span class="line">377</span><span class="line">378</span><span class="line">379</span><span class="line">380</span><span class="line">381</span><span class="line">382</span><span class="line">383</span><span class="line">384</span><span class="line">385</span><span class="line">386</span><span class="line">387</span><span class="line">388</span><span class="line">389</span><span class="line">390</span><span class="line">391</span><span class="line">392</span><span class="line">393</span><span class="line">394</span><span class="line">395</span><span class="line">396</span><span class="line">397</span><span class="line">398</span><span class="line">399</span><span class="line">400</span><span class="line">401</span><span class="line">402</span><span class="line">403</span><span class="line">404</span><span class="line">405</span><span class="line">406</span><span class="line">407</span><span class="line">408</span><span class="line">409</span><span class="line">410</span><span class="line">411</span><span class="line">412</span><span class="line">413</span><span class="line">414</span><span class="line">415</span><span class="line">416</span><span class="line">417</span><span class="line">418</span><span class="line">419</span><span class="line">420</span><span class="line">421</span><span class="line">422</span><span class="line">423</span><span class="line">424</span><span class="line">425</span><span class="line">426</span><span class="line">427</span><span class="line">428</span><span class="line">429</span><span class="line">430</span><span class="line">431</span><span class="line">432</span><span class="line">433</span><span class="line">434</span><span class="line">435</span><span class="line">436</span><span class="line">437</span><span class="line">438</span><span class="line">439</span><span class="line">440</span><span class="line">441</span><span class="line">442</span><span class="line">443</span><span class="line">444</span><span class="line">445</span><span class="line">446</span><span class="line">447</span><span class="line">448</span><span class="line">449</span><span class="line">450</span><span class="line">451</span><span class="line">452</span><span class="line">453</span><span class="line">454</span><span class="line">455</span><span class="line">456</span><span class="line">457</span><span class="line">458</span><span class="line">459</span><span class="line">460</span><span class="line">461</span><span class="line">462</span><span class="line">463</span><span class="line">464</span><span class="line">465</span><span class="line">466</span><span class="line">467</span><span class="line">468</span><span class="line">469</span><span class="line">470</span><span class="line">471</span><span class="line">472</span><span class="line">473</span><span class="line">474</span><span class="line">475</span><span class="line">476</span><span class="line">477</span><span class="line">478</span><span class="line">479</span><span class="line">480</span><span class="line">481</span><span class="line">482</span><span class="line">483</span><span class="line">484</span><span class="line">485</span><span class="line">486</span><span class="line">487</span><span class="line">488</span><span class="line">489</span><span class="line">490</span><span class="line">491</span><span class="line">492</span><span class="line">493</span><span class="line">494</span><span class="line">495</span><span class="line">496</span><span class="line">497</span><span class="line">498</span></pre></td><td class="code"><pre><span class="line">&lt;nmethod compile_id=&apos;1057&apos; compile_kind=&apos;c2n&apos; level=&apos;0&apos; entry=&apos;0x00000001055116c0&apos; size=&apos;832&apos; address=&apos;0x0000000105511550&apos; relocation_offset=&apos;296&apos; consts_offset=&apos;832&apos; insts_offset=&apos;368&apos; method=&apos;java/lang/Class getDeclaringClass0 ()Ljava/lang/Class;&apos; bytes=&apos;0&apos; count=&apos;0&apos; iicount=&apos;0&apos; stamp=&apos;8.649&apos;/&gt;</span><span class="line">&lt;task_queued compile_id=&apos;1058&apos; method=&apos;com/example/lang/PrintAssemblyVolatile main ([Ljava/lang/String;)V&apos; bytes=&apos;29&apos; count=&apos;0&apos; iicount=&apos;0&apos; level=&apos;3&apos; blocking=&apos;1&apos; stamp=&apos;8.649&apos; comment=&apos;must_be_compiled&apos;/&gt;</span><span class="line">&lt;writer thread=&apos;14595&apos;/&gt;</span><span class="line">Decoding compiled method 0x0000000105510e10:</span><span class="line">Code:</span><span class="line">[Entry Point]</span><span class="line">[Verified Entry Point]</span><span class="line">[Constants]</span><span class="line">  # &#123;method&#125; &#123;0x0000000118cff320&#125; &apos;main&apos; &apos;([Ljava/lang/String;)V&apos; in &apos;com/example/lang/PrintAssemblyVolatile&apos;</span><span class="line">  # parm0:    rsi:rsi   = &apos;[Ljava/lang/String;&apos;</span><span class="line">  #           [sp+0x60]  (sp of caller)</span><span class="line">  0x0000000105510fa0: mov    %eax,-0x14000(%rsp)</span><span class="line">  0x0000000105510fa7: push   %rbp</span><span class="line">  0x0000000105510fa8: sub    $0x50,%rsp</span><span class="line">  0x0000000105510fac: movabs $0x118cff448,%rdx  ;   &#123;metadata(method data for &#123;method&#125; &#123;0x0000000118cff320&#125; &apos;main&apos; &apos;([Ljava/lang/String;)V&apos; in &apos;com/example/lang/PrintAssemblyVolatile&apos;)&#125;</span><span class="line">  0x0000000105510fb6: mov    0xdc(%rdx),%edi</span><span class="line">  0x0000000105510fbc: add    $0x8,%edi</span><span class="line">  0x0000000105510fbf: mov    %edi,0xdc(%rdx)</span><span class="line">  0x0000000105510fc5: movabs $0x118cff320,%rdx  ;   &#123;metadata(&#123;method&#125; &#123;0x0000000118cff320&#125; &apos;main&apos; &apos;([Ljava/lang/String;)V&apos; in &apos;com/example/lang/PrintAssemblyVolatile&apos;)&#125;</span><span class="line">  0x0000000105510fcf: and    $0x0,%edi</span><span class="line">  0x0000000105510fd2: cmp    $0x0,%edi</span><span class="line">  0x0000000105510fd5: je     0x0000000105511188</span><span class="line">  0x0000000105510fdb: nopl   0x0(%rax,%rax,1)</span><span class="line">  0x0000000105510fe0: jmpq   0x00000001055111ae  ;   &#123;no_reloc&#125;</span><span class="line">  0x0000000105510fe5: add    %al,(%rax)</span><span class="line">  0x0000000105510fe7: add    %al,(%rax)</span><span class="line">  0x0000000105510fe9: add    %cl,-0x75(%rcx)</span><span class="line">  0x0000000105510fec: rex.RXB (bad)</span><span class="line">  0x0000000105510fee: lea    0x10(%rax),%rdi</span><span class="line">  0x0000000105510ff2: cmp    0x70(%r15),%rdi</span><span class="line">  0x0000000105510ff6: ja     0x00000001055111b8</span><span class="line">  0x0000000105510ffc: mov    %rdi,0x60(%r15)</span><span class="line">  0x0000000105511000: mov    0xa8(%rdx),%rcx</span><span class="line">  0x0000000105511007: mov    %rcx,(%rax)</span><span class="line">  0x000000010551100a: mov    %rdx,%rcx</span><span class="line">  0x000000010551100d: shr    $0x3,%rcx</span><span class="line">  0x0000000105511011: mov    %ecx,0x8(%rax)</span><span class="line">  0x0000000105511014: xor    %rcx,%rcx</span><span class="line">  0x0000000105511017: mov    %ecx,0xc(%rax)</span><span class="line">  0x000000010551101a: xor    %rcx,%rcx          ;*new  ; - com.example.lang.PrintAssemblyVolatile::main@0 (line 21)</span><span class="line"></span><span class="line">  0x000000010551101d: mov    %rax,%rdx</span><span class="line">  0x0000000105511020: movabs $0x118cff448,%rsi  ;   &#123;metadata(method data for &#123;method&#125; &#123;0x0000000118cff320&#125; &apos;main&apos; &apos;([Ljava/lang/String;)V&apos; in &apos;com/example/lang/PrintAssemblyVolatile&apos;)&#125;</span><span class="line">  0x000000010551102a: addq   $0x1,0x108(%rsi)</span><span class="line">  0x0000000105511032: movabs $0x118cff5d0,%rdx  ;   &#123;metadata(method data for &#123;method&#125; &#123;0x0000000118cff258&#125; &apos;&lt;init&gt;&apos; &apos;()V&apos; in &apos;com/example/lang/PrintAssemblyVolatile&apos;)&#125;</span><span class="line">  0x000000010551103c: mov    0xdc(%rdx),%esi</span><span class="line">  0x0000000105511042: add    $0x8,%esi</span><span class="line">  0x0000000105511045: mov    %esi,0xdc(%rdx)</span><span class="line">  0x000000010551104b: movabs $0x118cff258,%rdx  ;   &#123;metadata(&#123;method&#125; &#123;0x0000000118cff258&#125; &apos;&lt;init&gt;&apos; &apos;()V&apos; in &apos;com/example/lang/PrintAssemblyVolatile&apos;)&#125;</span><span class="line">  0x0000000105511055: and    $0x7ffff8,%esi</span><span class="line">  0x000000010551105b: cmp    $0x0,%esi</span><span class="line">  0x000000010551105e: je     0x00000001055111c5</span><span class="line">  0x0000000105511064: mov    %rax,%rdx</span><span class="line">  0x0000000105511067: movabs $0x118cff5d0,%rsi  ;   &#123;metadata(method data for &#123;method&#125; &#123;0x0000000118cff258&#125; &apos;&lt;init&gt;&apos; &apos;()V&apos; in &apos;com/example/lang/PrintAssemblyVolatile&apos;)&#125;</span><span class="line">  0x0000000105511071: addq   $0x1,0x108(%rsi)</span><span class="line">  0x0000000105511079: movabs $0x118a76490,%rdx  ;   &#123;metadata(method data for &#123;method&#125; &#123;0x00000001188ff480&#125; &apos;&lt;init&gt;&apos; &apos;()V&apos; in &apos;java/lang/Object&apos;)&#125;</span><span class="line">  0x0000000105511083: mov    0xdc(%rdx),%esi</span><span class="line">  0x0000000105511089: add    $0x8,%esi</span><span class="line">  0x000000010551108c: mov    %esi,0xdc(%rdx)</span><span class="line">  0x0000000105511092: movabs $0x1188ff480,%rdx  ;   &#123;metadata(&#123;method&#125; &#123;0x00000001188ff480&#125; &apos;&lt;init&gt;&apos; &apos;()V&apos; in &apos;java/lang/Object&apos;)&#125;</span><span class="line">  0x000000010551109c: and    $0x7ffff8,%esi</span><span class="line">  0x00000001055110a2: cmp    $0x0,%esi</span><span class="line">  0x00000001055110a5: je     0x00000001055111dc</span><span class="line">  0x00000001055110ab: mov    0xc(%rax),%edx     ;*getfield i</span><span class="line">                                                ; - com.example.lang.PrintAssemblyVolatile::main@10 (line 22)</span><span class="line"></span><span class="line">  0x00000001055110ae: inc    %edx</span><span class="line">  0x00000001055110b0: mov    %edx,0xc(%rax)</span><span class="line">  0x00000001055110b3: lock addl $0x0,(%rsp)     ;*putfield i</span><span class="line">                                                ; - com.example.lang.PrintAssemblyVolatile::main@15 (line 22)</span><span class="line"></span><span class="line">  0x00000001055110b8: jmpq   0x0000000105511250  ;   &#123;no_reloc&#125;</span><span class="line">  0x00000001055110bd: add    %al,(%rax)</span><span class="line">  0x00000001055110bf: add    %al,(%rax)</span><span class="line">  0x00000001055110c1: add    %ah,0xf(%rsi)</span><span class="line">  0x00000001055110c4: (bad)</span><span class="line">  0x00000001055110c5: add    %r8b,(%rax)</span><span class="line">  0x00000001055110c8: jmpq   0x000000010551126a  ; implicit exception: dispatches to 0x000000010551125a</span><span class="line">  0x00000001055110cd: nop</span><span class="line">  0x00000001055110ce: shl    $0x3,%rsi          ;*getstatic out</span><span class="line">                                                ; - com.example.lang.PrintAssemblyVolatile::main@18 (line 23)</span><span class="line"></span><span class="line">  0x00000001055110d2: mov    0xc(%rax),%edx     ;*getfield i</span><span class="line">                                                ; - com.example.lang.PrintAssemblyVolatile::main@22 (line 23)</span><span class="line"></span><span class="line">  0x00000001055110d5: cmp    (%rsi),%rax        ;*invokevirtual println</span><span class="line">                                                ; - com.example.lang.PrintAssemblyVolatile::main@25 (line 23)</span><span class="line">                                                ; implicit exception: dispatches to 0x0000000105511274</span><span class="line">  0x00000001055110d8: mov    %rsi,%rdi</span><span class="line">  0x00000001055110db: movabs $0x118cff448,%rbx  ;   &#123;metadata(method data for &#123;method&#125; &#123;0x0000000118cff320&#125; &apos;main&apos; &apos;([Ljava/lang/String;)V&apos; in &apos;com/example/lang/PrintAssemblyVolatile&apos;)&#125;</span><span class="line">  0x00000001055110e5: mov    0x8(%rdi),%edi</span><span class="line">  0x00000001055110e8: shl    $0x3,%rdi</span><span class="line">  0x00000001055110ec: cmp    0x120(%rbx),%rdi</span><span class="line">  0x00000001055110f3: jne    0x0000000105511102</span><span class="line">  0x00000001055110f5: addq   $0x1,0x128(%rbx)</span><span class="line">  0x00000001055110fd: jmpq   0x0000000105511168</span><span class="line">  0x0000000105511102: cmp    0x130(%rbx),%rdi</span><span class="line">  0x0000000105511109: jne    0x0000000105511118</span><span class="line">  0x000000010551110b: addq   $0x1,0x138(%rbx)</span><span class="line">  0x0000000105511113: jmpq   0x0000000105511168</span><span class="line">  0x0000000105511118: cmpq   $0x0,0x120(%rbx)</span><span class="line">  0x0000000105511123: jne    0x000000010551113c</span><span class="line">  0x0000000105511125: mov    %rdi,0x120(%rbx)</span><span class="line">  0x000000010551112c: movq   $0x1,0x128(%rbx)</span><span class="line">  0x0000000105511137: jmpq   0x0000000105511168</span><span class="line">  0x000000010551113c: cmpq   $0x0,0x130(%rbx)</span><span class="line">  0x0000000105511147: jne    0x0000000105511160</span><span class="line">  0x0000000105511149: mov    %rdi,0x130(%rbx)</span><span class="line">  0x0000000105511150: movq   $0x1,0x138(%rbx)</span><span class="line">  0x000000010551115b: jmpq   0x0000000105511168</span><span class="line">  0x0000000105511160: addq   $0x1,0x118(%rbx)</span><span class="line">  0x0000000105511168: nop</span><span class="line">  0x0000000105511169: nop</span><span class="line">  0x000000010551116a: nop</span><span class="line">  0x000000010551116b: nop</span><span class="line">  0x000000010551116c: nop</span><span class="line">  0x000000010551116d: movabs $0xffffffffffffffff,%rax</span><span class="line">  0x0000000105511177: callq  0x00000001051442e0  ; OopMap&#123;off=476&#125;</span><span class="line">                                                ;*invokevirtual println</span><span class="line">                                                ; - com.example.lang.PrintAssemblyVolatile::main@25 (line 23)</span><span class="line">                                                ;   &#123;virtual_call&#125;</span><span class="line">  0x000000010551117c: add    $0x50,%rsp</span><span class="line">  0x0000000105511180: pop    %rbp</span><span class="line">  0x0000000105511181: test   %eax,-0x2489087(%rip)        # 0x0000000103088100</span><span class="line">                                                ;   &#123;poll_return&#125;</span><span class="line">  0x0000000105511187: retq</span><span class="line">  0x0000000105511188: mov    %rdx,0x8(%rsp)</span><span class="line">  0x000000010551118d: movq   $0xffffffffffffffff,(%rsp)</span><span class="line">  0x0000000105511195: callq  0x00000001051fc420  ; OopMap&#123;rsi=Oop off=506&#125;</span><span class="line">                                                ;*synchronization entry</span><span class="line">                                                ; - com.example.lang.PrintAssemblyVolatile::main@-1 (line 21)</span><span class="line">                                                ;   &#123;runtime_call&#125;</span><span class="line">  0x000000010551119a: jmpq   0x0000000105510fdb</span><span class="line">  0x000000010551119f: movabs $0x0,%rdx          ;   &#123;metadata(NULL)&#125;</span><span class="line">  0x00000001055111a9: mov    $0xa050f00,%eax</span><span class="line">  0x00000001055111ae: callq  0x00000001051fb2e0  ; OopMap&#123;off=531&#125;</span><span class="line">                                                ;*new  ; - com.example.lang.PrintAssemblyVolatile::main@0 (line 21)</span><span class="line">                                                ;   &#123;runtime_call&#125;</span><span class="line">  0x00000001055111b3: jmpq   0x0000000105510fe0</span><span class="line">  0x00000001055111b8: mov    %rdx,%rdx</span><span class="line">  0x00000001055111bb: callq  0x00000001051f83e0  ; OopMap&#123;off=544&#125;</span><span class="line">                                                ;*new  ; - com.example.lang.PrintAssemblyVolatile::main@0 (line 21)</span><span class="line">                                                ;   &#123;runtime_call&#125;</span><span class="line">  0x00000001055111c0: jmpq   0x000000010551101d</span><span class="line">  0x00000001055111c5: mov    %rdx,0x8(%rsp)</span><span class="line">  0x00000001055111ca: movq   $0xffffffffffffffff,(%rsp)</span><span class="line">  0x00000001055111d2: callq  0x00000001051fc420  ; OopMap&#123;rax=Oop off=567&#125;</span><span class="line">                                                ;*synchronization entry</span><span class="line">                                                ; - com.example.lang.PrintAssemblyVolatile::&lt;init&gt;@-1 (line 16)</span><span class="line">                                                ; - com.example.lang.PrintAssemblyVolatile::main@4 (line 21)</span><span class="line">                                                ;   &#123;runtime_call&#125;</span><span class="line">  0x00000001055111d7: jmpq   0x0000000105511064</span><span class="line">  0x00000001055111dc: mov    %rdx,0x8(%rsp)</span><span class="line">  0x00000001055111e1: movq   $0xffffffffffffffff,(%rsp)</span><span class="line">  0x00000001055111e9: callq  0x00000001051fc420  ; OopMap&#123;rax=Oop off=590&#125;</span><span class="line">                                                ;*synchronization entry</span><span class="line">                                                ; - java.lang.Object::&lt;init&gt;@-1 (line 37)</span><span class="line">                                                ; - com.example.lang.PrintAssemblyVolatile::&lt;init&gt;@1 (line 16)</span><span class="line">                                                ; - com.example.lang.PrintAssemblyVolatile::main@4 (line 21)</span><span class="line">                                                ;   &#123;runtime_call&#125;</span><span class="line">  0x00000001055111ee: jmpq   0x00000001055110ab</span><span class="line">  0x00000001055111f3: movabs $0x0,%rdx          ;   &#123;oop(NULL)&#125;</span><span class="line">  0x00000001055111fd: push   %rax</span><span class="line">  0x00000001055111fe: push   %rbx</span><span class="line">  0x00000001055111ff: mov    0x48(%rdx),%rbx</span><span class="line">  0x0000000105511203: push   %rdi</span><span class="line">  0x0000000105511204: push   %rsi</span><span class="line">  0x0000000105511205: push   %rdx</span><span class="line">  0x0000000105511206: push   %rcx</span><span class="line">  0x0000000105511207: push   %r8</span><span class="line">  0x0000000105511209: push   %r9</span><span class="line">  0x000000010551120b: push   %r10</span><span class="line">  0x000000010551120d: mov    %rsp,%r10</span><span class="line">  0x0000000105511210: and    $0xfffffffffffffff0,%rsp</span><span class="line">  0x0000000105511214: push   %r10</span><span class="line">  0x0000000105511216: push   %r11</span><span class="line">  0x0000000105511218: mov    $0x109,%edi</span><span class="line">  0x000000010551121d: movabs $0x7fff58689992,%r10  ;   &#123;runtime_call&#125;</span><span class="line">  0x0000000105511227: callq  *%r10</span><span class="line">  0x000000010551122a: pop    %r11</span><span class="line">  0x000000010551122c: pop    %rsp</span><span class="line">  0x000000010551122d: pop    %r10</span><span class="line">  0x000000010551122f: pop    %r9</span><span class="line">  0x0000000105511231: pop    %r8</span><span class="line">  0x0000000105511233: pop    %rcx</span><span class="line">  0x0000000105511234: pop    %rdx</span><span class="line">  0x0000000105511235: pop    %rsi</span><span class="line">  0x0000000105511236: pop    %rdi</span><span class="line">  0x0000000105511237: cmp    0x118(%rbx),%rax</span><span class="line">  0x000000010551123e: pop    %rbx</span><span class="line">  0x000000010551123f: pop    %rax</span><span class="line">  0x0000000105511240: jne    0x0000000105511250</span><span class="line">  0x0000000105511246: jmpq   0x00000001055110c2</span><span class="line">  0x000000010551124b: mov    $0xa535d00,%eax</span><span class="line">  0x0000000105511250: callq  0x00000001051fb6e0  ; OopMap&#123;rax=Oop off=693&#125;</span><span class="line">                                                ;*getstatic out</span><span class="line">                                                ; - com.example.lang.PrintAssemblyVolatile::main@18 (line 23)</span><span class="line">                                                ;   &#123;runtime_call&#125;</span><span class="line">  0x0000000105511255: jmpq   0x00000001055110b8</span><span class="line">  0x000000010551125a: callq  0x00000001051f7c80  ; OopMap&#123;rax=Oop rdx=Oop off=703&#125;</span><span class="line">                                                ;*getstatic out</span><span class="line">                                                ; - com.example.lang.PrintAssemblyVolatile::main@18 (line 23)</span><span class="line">                                                ;   &#123;runtime_call&#125;</span><span class="line">  0x000000010551125f: mov    0x0(%rdx),%esi</span><span class="line">  0x0000000105511265: mov    $0x6050b00,%eax</span><span class="line">  0x000000010551126a: callq  0x00000001051faee0  ; OopMap&#123;rax=Oop rdx=Oop off=719&#125;</span><span class="line">                                                ;*getstatic out</span><span class="line">                                                ; - com.example.lang.PrintAssemblyVolatile::main@18 (line 23)</span><span class="line">                                                ;   &#123;runtime_call&#125;</span><span class="line">  0x000000010551126f: jmpq   0x00000001055110c8</span><span class="line">  0x0000000105511274: callq  0x00000001051f7c80  ; OopMap&#123;rsi=Oop off=729&#125;</span><span class="line">                                                ;*invokevirtual println</span><span class="line">                                                ; - com.example.lang.PrintAssemblyVolatile::main@25 (line 23)</span><span class="line">                                                ;   &#123;runtime_call&#125;</span><span class="line">  0x0000000105511279: nop</span><span class="line">  0x000000010551127a: nop</span><span class="line">  0x000000010551127b: mov    0x2a8(%r15),%rax</span><span class="line">  0x0000000105511282: movabs $0x0,%r10</span><span class="line">  0x000000010551128c: mov    %r10,0x2a8(%r15)</span><span class="line">  0x0000000105511293: movabs $0x0,%r10</span><span class="line">  0x000000010551129d: mov    %r10,0x2b0(%r15)</span><span class="line">  0x00000001055112a4: add    $0x50,%rsp</span><span class="line">  0x00000001055112a8: pop    %rbp</span><span class="line">  0x00000001055112a9: jmpq   0x000000010516a6e0  ;   &#123;runtime_call&#125;</span><span class="line">  0x00000001055112ae: hlt</span><span class="line">  0x00000001055112af: hlt</span><span class="line">  0x00000001055112b0: hlt</span><span class="line">  0x00000001055112b1: hlt</span><span class="line">  0x00000001055112b2: hlt</span><span class="line">  0x00000001055112b3: hlt</span><span class="line">  0x00000001055112b4: hlt</span><span class="line">  0x00000001055112b5: hlt</span><span class="line">  0x00000001055112b6: hlt</span><span class="line">  0x00000001055112b7: hlt</span><span class="line">  0x00000001055112b8: hlt</span><span class="line">  0x00000001055112b9: hlt</span><span class="line">  0x00000001055112ba: hlt</span><span class="line">  0x00000001055112bb: hlt</span><span class="line">  0x00000001055112bc: hlt</span><span class="line">  0x00000001055112bd: hlt</span><span class="line">  0x00000001055112be: hlt</span><span class="line">  0x00000001055112bf: hlt</span><span class="line">[Stub Code]</span><span class="line">  0x00000001055112c0: nop                       ;   &#123;no_reloc&#125;</span><span class="line">  0x00000001055112c1: nop</span><span class="line">  0x00000001055112c2: nop</span><span class="line">  0x00000001055112c3: nop</span><span class="line">  0x00000001055112c4: nop</span><span class="line">  0x00000001055112c5: movabs $0x0,%rbx          ;   &#123;static_stub&#125;</span><span class="line">  0x00000001055112cf: jmpq   0x00000001055112cf  ;   &#123;runtime_call&#125;</span><span class="line">[Exception Handler]</span><span class="line">  0x00000001055112d4: callq  0x00000001051f9b20  ;   &#123;runtime_call&#125;</span><span class="line">  0x00000001055112d9: mov    %rsp,-0x28(%rsp)</span><span class="line">  0x00000001055112de: sub    $0x80,%rsp</span><span class="line">  0x00000001055112e5: mov    %rax,0x78(%rsp)</span><span class="line">  0x00000001055112ea: mov    %rcx,0x70(%rsp)</span><span class="line">  0x00000001055112ef: mov    %rdx,0x68(%rsp)</span><span class="line">  0x00000001055112f4: mov    %rbx,0x60(%rsp)</span><span class="line">  0x00000001055112f9: mov    %rbp,0x50(%rsp)</span><span class="line">  0x00000001055112fe: mov    %rsi,0x48(%rsp)</span><span class="line">  0x0000000105511303: mov    %rdi,0x40(%rsp)</span><span class="line">  0x0000000105511308: mov    %r8,0x38(%rsp)</span><span class="line">  0x000000010551130d: mov    %r9,0x30(%rsp)</span><span class="line">  0x0000000105511312: mov    %r10,0x28(%rsp)</span><span class="line">  0x0000000105511317: mov    %r11,0x20(%rsp)</span><span class="line">  0x000000010551131c: mov    %r12,0x18(%rsp)</span><span class="line">  0x0000000105511321: mov    %r13,0x10(%rsp)</span><span class="line">  0x0000000105511326: mov    %r14,0x8(%rsp)</span><span class="line">  0x000000010551132b: mov    %r15,(%rsp)</span><span class="line">  0x000000010551132f: movabs $0x104725c8c,%rdi  ;   &#123;external_word&#125;</span><span class="line">  0x0000000105511339: movabs $0x1055112d9,%rsi  ;   &#123;internal_word&#125;</span><span class="line">  0x0000000105511343: mov    %rsp,%rdx</span><span class="line">  0x0000000105511346: and    $0xfffffffffffffff0,%rsp</span><span class="line">  0x000000010551134a: callq  0x000000010454e8f2  ;   &#123;runtime_call&#125;</span><span class="line">  0x000000010551134f: hlt</span><span class="line">[Deopt Handler Code]</span><span class="line">  0x0000000105511350: movabs $0x105511350,%r10  ;   &#123;section_word&#125;</span><span class="line">  0x000000010551135a: push   %r10</span><span class="line">  0x000000010551135c: jmpq   0x0000000105145500  ;   &#123;runtime_call&#125;</span><span class="line">  0x0000000105511361: hlt</span><span class="line">  0x0000000105511362: hlt</span><span class="line">  0x0000000105511363: hlt</span><span class="line">  0x0000000105511364: hlt</span><span class="line">  0x0000000105511365: hlt</span><span class="line">  0x0000000105511366: hlt</span><span class="line">  0x0000000105511367: hlt</span><span class="line">&lt;nmethod compile_id=&apos;1058&apos; compiler=&apos;C1&apos; level=&apos;3&apos; entry=&apos;0x0000000105510fa0&apos; size=&apos;1824&apos; address=&apos;0x0000000105510e10&apos; relocation_offset=&apos;296&apos; insts_offset=&apos;400&apos; stub_offset=&apos;1200&apos; scopes_data_offset=&apos;1400&apos; scopes_pcs_offset=&apos;1504&apos; dependencies_offset=&apos;1792&apos; nul_chk_table_offset=&apos;1800&apos; oops_offset=&apos;1368&apos; method=&apos;com/example/lang/PrintAssemblyVolatile main ([Ljava/lang/String;)V&apos; bytes=&apos;29&apos; count=&apos;0&apos; iicount=&apos;0&apos; stamp=&apos;8.653&apos;/&gt;</span><span class="line">&lt;writer thread=&apos;9987&apos;/&gt;</span><span class="line">&lt;task_queued compile_id=&apos;1059&apos; method=&apos;com/example/lang/PrintAssemblyVolatile main ([Ljava/lang/String;)V&apos; bytes=&apos;29&apos; count=&apos;1&apos; iicount=&apos;1&apos; blocking=&apos;1&apos; stamp=&apos;8.653&apos; comment=&apos;tiered&apos; hot_count=&apos;1&apos;/&gt;</span><span class="line">&lt;writer thread=&apos;14339&apos;/&gt;</span><span class="line">Decoding compiled method 0x0000000105407090:</span><span class="line">Code:</span><span class="line">[Entry Point]</span><span class="line">[Verified Entry Point]</span><span class="line">[Constants]</span><span class="line">  # &#123;method&#125; &#123;0x0000000118cff320&#125; &apos;main&apos; &apos;([Ljava/lang/String;)V&apos; in &apos;com/example/lang/PrintAssemblyVolatile&apos;</span><span class="line">  # parm0:    rsi:rsi   = &apos;[Ljava/lang/String;&apos;</span><span class="line">  #           [sp+0x20]  (sp of caller)</span><span class="line">  0x00000001054071e0: mov    %eax,-0x14000(%rsp)</span><span class="line">  0x00000001054071e7: push   %rbp</span><span class="line">  0x00000001054071e8: sub    $0x10,%rsp         ;*synchronization entry</span><span class="line">                                                ; - com.example.lang.PrintAssemblyVolatile::main@-1 (line 21)</span><span class="line"></span><span class="line">  0x00000001054071ec: mov    $0x3,%esi</span><span class="line">  0x00000001054071f1: xchg   %ax,%ax</span><span class="line">  0x00000001054071f3: callq  0x00000001051436a0  ; OopMap&#123;off=24&#125;</span><span class="line">                                                ;*new  ; - com.example.lang.PrintAssemblyVolatile::main@0 (line 21)</span><span class="line">                                                ;   &#123;runtime_call&#125;</span><span class="line">  0x00000001054071f8: callq  0x00000001045d1f64  ;*new</span><span class="line">                                                ; - com.example.lang.PrintAssemblyVolatile::main@0 (line 21)</span><span class="line">                                                ;   &#123;runtime_call&#125;</span><span class="line">  0x00000001054071fd: hlt</span><span class="line">  0x00000001054071fe: hlt</span><span class="line">  0x00000001054071ff: hlt</span><span class="line">[Exception Handler]</span><span class="line">[Stub Code]</span><span class="line">  0x0000000105407200: jmpq   0x000000010516a9a0  ;   &#123;no_reloc&#125;</span><span class="line">[Deopt Handler Code]</span><span class="line">  0x0000000105407205: callq  0x000000010540720a</span><span class="line">  0x000000010540720a: subq   $0x5,(%rsp)</span><span class="line">  0x000000010540720f: jmpq   0x0000000105145500  ;   &#123;runtime_call&#125;</span><span class="line">  0x0000000105407214: hlt</span><span class="line">  0x0000000105407215: hlt</span><span class="line">  0x0000000105407216: hlt</span><span class="line">  0x0000000105407217: hlt</span><span class="line">&lt;nmethod compile_id=&apos;1059&apos; compiler=&apos;C2&apos; level=&apos;4&apos; entry=&apos;0x00000001054071e0&apos; size=&apos;520&apos; address=&apos;0x0000000105407090&apos; relocation_offset=&apos;296&apos; insts_offset=&apos;336&apos; stub_offset=&apos;368&apos; scopes_data_offset=&apos;408&apos; scopes_pcs_offset=&apos;432&apos; dependencies_offset=&apos;512&apos; oops_offset=&apos;392&apos; method=&apos;com/example/lang/PrintAssemblyVolatile main ([Ljava/lang/String;)V&apos; bytes=&apos;29&apos; count=&apos;1&apos; iicount=&apos;1&apos; stamp=&apos;8.654&apos;/&gt;</span><span class="line">&lt;make_not_entrant thread=&apos;14339&apos; compile_id=&apos;1058&apos; compiler=&apos;C1&apos; level=&apos;3&apos; stamp=&apos;8.654&apos;/&gt;</span><span class="line">&lt;writer thread=&apos;9987&apos;/&gt;</span><span class="line">&lt;task_queued compile_id=&apos;1060&apos; method=&apos;java/io/PrintStream println (I)V&apos; bytes=&apos;24&apos; count=&apos;0&apos; iicount=&apos;0&apos; level=&apos;3&apos; blocking=&apos;1&apos; stamp=&apos;8.654&apos; comment=&apos;must_be_compiled&apos;/&gt;</span><span class="line">&lt;writer thread=&apos;14595&apos;/&gt;</span><span class="line">Decoding compiled method 0x00000001055170d0:</span><span class="line">Code:</span><span class="line">[Entry Point]</span><span class="line">[Constants]</span><span class="line">  # &#123;method&#125; &#123;0x0000000118a46618&#125; &apos;println&apos; &apos;(I)V&apos; in &apos;java/io/PrintStream&apos;</span><span class="line">  # this:     rsi:rsi   = &apos;java/io/PrintStream&apos;</span><span class="line">  # parm0:    rdx       = int</span><span class="line">  #           [sp+0x70]  (sp of caller)</span><span class="line">  0x0000000105517280: mov    0x8(%rsi),%r10d</span><span class="line">  0x0000000105517284: shl    $0x3,%r10</span><span class="line">  0x0000000105517288: cmp    %rax,%r10</span><span class="line">  0x000000010551728b: jne    0x0000000105143e60  ;   &#123;runtime_call&#125;</span><span class="line">  0x0000000105517291: data16 data16 nopw 0x0(%rax,%rax,1)</span><span class="line">  0x000000010551729c: data16 data16 xchg %ax,%ax</span><span class="line">[Verified Entry Point]</span><span class="line">  0x00000001055172a0: mov    %eax,-0x14000(%rsp)</span><span class="line">  0x00000001055172a7: push   %rbp</span><span class="line">  0x00000001055172a8: sub    $0x60,%rsp</span><span class="line">  0x00000001055172ac: movabs $0x118bcb1b8,%rax  ;   &#123;metadata(method data for &#123;method&#125; &#123;0x0000000118a46618&#125; &apos;println&apos; &apos;(I)V&apos; in &apos;java/io/PrintStream&apos;)&#125;</span><span class="line">  0x00000001055172b6: mov    0xdc(%rax),%edi</span><span class="line">  0x00000001055172bc: add    $0x8,%edi</span><span class="line">  0x00000001055172bf: mov    %edi,0xdc(%rax)</span><span class="line">  0x00000001055172c5: movabs $0x118a46618,%rax  ;   &#123;metadata(&#123;method&#125; &#123;0x0000000118a46618&#125; &apos;println&apos; &apos;(I)V&apos; in &apos;java/io/PrintStream&apos;)&#125;</span><span class="line">  0x00000001055172cf: and    $0x0,%edi</span><span class="line">  0x00000001055172d2: cmp    $0x0,%edi</span><span class="line">  0x00000001055172d5: je     0x0000000105517550  ;*aload_0</span><span class="line">                                                ; - java.io.PrintStream::println@0 (line 735)</span><span class="line"></span><span class="line">  0x00000001055172db: lea    0x48(%rsp),%rdi</span><span class="line">  0x00000001055172e0: mov    %rsi,0x8(%rdi)</span><span class="line">  0x00000001055172e4: mov    (%rsi),%rax</span><span class="line">  0x00000001055172e7: mov    %rax,%rbx</span><span class="line">  0x00000001055172ea: and    $0x7,%rbx</span><span class="line">  0x00000001055172ee: cmp    $0x5,%rbx</span><span class="line">  0x00000001055172f2: jne    0x0000000105517379</span><span class="line">  0x00000001055172f8: mov    0x8(%rsi),%ebx</span><span class="line">  0x00000001055172fb: shl    $0x3,%rbx</span><span class="line">  0x00000001055172ff: mov    0xa8(%rbx),%rbx</span><span class="line">  0x0000000105517306: or     %r15,%rbx</span><span class="line">  0x0000000105517309: xor    %rax,%rbx</span><span class="line">  0x000000010551730c: and    $0xffffffffffffff87,%rbx</span><span class="line">  0x0000000105517310: je     0x00000001055173a1</span><span class="line">  0x0000000105517316: test   $0x7,%rbx</span><span class="line">  0x000000010551731d: jne    0x0000000105517366</span><span class="line">  0x000000010551731f: test   $0x300,%rbx</span><span class="line">  0x0000000105517326: jne    0x0000000105517345</span><span class="line">  0x0000000105517328: and    $0x37f,%rax</span><span class="line">  0x000000010551732f: mov    %rax,%rbx</span><span class="line">  0x0000000105517332: or     %r15,%rbx</span><span class="line">  0x0000000105517335: lock cmpxchg %rbx,(%rsi)</span><span class="line">  0x000000010551733a: jne    0x0000000105517567</span><span class="line">  0x0000000105517340: jmpq   0x00000001055173a1</span><span class="line">  0x0000000105517345: mov    0x8(%rsi),%ebx</span><span class="line">  0x0000000105517348: shl    $0x3,%rbx</span><span class="line">  0x000000010551734c: mov    0xa8(%rbx),%rbx</span><span class="line">  0x0000000105517353: or     %r15,%rbx</span><span class="line">  0x0000000105517356: lock cmpxchg %rbx,(%rsi)</span><span class="line">  0x000000010551735b: jne    0x0000000105517567</span><span class="line">  0x0000000105517361: jmpq   0x00000001055173a1</span><span class="line">  0x0000000105517366: mov    0x8(%rsi),%ebx</span><span class="line">  0x0000000105517369: shl    $0x3,%rbx</span><span class="line">  0x000000010551736d: mov    0xa8(%rbx),%rbx</span><span class="line">  0x0000000105517374: lock cmpxchg %rbx,(%rsi)</span><span class="line">  0x0000000105517379: mov    (%rsi),%rax</span><span class="line">  0x000000010551737c: or     $0x1,%rax</span><span class="line">  0x0000000105517380: mov    %rax,(%rdi)</span><span class="line">  0x0000000105517383: lock cmpxchg %rdi,(%rsi)</span><span class="line">  0x0000000105517388: je     0x00000001055173a1</span><span class="line">  0x000000010551738e: sub    %rsp,%rax</span><span class="line">  0x0000000105517391: and    $0xfffffffffffff007,%rax</span><span class="line">  0x0000000105517398: mov    %rax,(%rdi)</span><span class="line">  0x000000010551739b: jne    0x0000000105517567  ;*monitorenter</span><span class="line">                                                ; - java.io.PrintStream::println@3 (line 735)</span><span class="line"></span><span class="line">  0x00000001055173a1: mov    %rsi,%rdi</span><span class="line">  0x00000001055173a4: movabs $0x118bcb1b8,%rbx  ;   &#123;metadata(method data for &#123;method&#125; &#123;0x0000000118a46618&#125; &apos;println&apos; &apos;(I)V&apos; in &apos;java/io/PrintStream&apos;)&#125;</span><span class="line">  0x00000001055173ae: movabs $0x7c0027950,%r10  ;   &#123;metadata(&apos;java/io/PrintStream&apos;)&#125;</span><span class="line">  0x00000001055173b8: mov    %r10,0x110(%rbx)</span><span class="line">  0x00000001055173bf: addq   $0x1,0x118(%rbx)</span><span class="line">  0x00000001055173c7: movabs $0x118bcb360,%rdi  ;   &#123;metadata(method data for &#123;method&#125; &#123;0x0000000118a45fa8&#125; &apos;print&apos; &apos;(I)V&apos; in &apos;java/io/PrintStream&apos;)&#125;</span><span class="line">  0x00000001055173d1: mov    0xdc(%rdi),%ebx</span><span class="line">  0x00000001055173d7: add    $0x8,%ebx</span><span class="line">  0x00000001055173da: mov    %ebx,0xdc(%rdi)</span><span class="line">  0x00000001055173e0: movabs $0x118a45fa8,%rdi  ;   &#123;metadata(&#123;method&#125; &#123;0x0000000118a45fa8&#125; &apos;print&apos; &apos;(I)V&apos; in &apos;java/io/PrintStream&apos;)&#125;</span><span class="line">  0x00000001055173ea: and    $0x7ffff8,%ebx</span><span class="line">  0x00000001055173f0: cmp    $0x0,%ebx</span><span class="line">  0x00000001055173f3: je     0x000000010551757a</span><span class="line">  0x00000001055173f9: movabs $0x118bcb360,%rdi  ;   &#123;metadata(method data for &#123;method&#125; &#123;0x0000000118a45fa8&#125; &apos;print&apos; &apos;(I)V&apos; in &apos;java/io/PrintStream&apos;)&#125;</span><span class="line">  0x0000000105517403: addq   $0x1,0x108(%rdi)</span><span class="line">  0x000000010551740b: movabs $0x118bcb4d0,%rdi  ;   &#123;metadata(method data for &#123;method&#125; &#123;0x0000000118906500&#125; &apos;valueOf&apos; &apos;(I)Ljava/lang/String;&apos; in &apos;java/lang/String&apos;)&#125;</span><span class="line">  0x0000000105517415: mov    0xdc(%rdi),%ebx</span><span class="line">  0x000000010551741b: add    $0x8,%ebx</span><span class="line">  0x000000010551741e: mov    %ebx,0xdc(%rdi)</span><span class="line">  0x0000000105517424: movabs $0x118906500,%rdi  ;   &#123;metadata(&#123;method&#125; &#123;0x0000000118906500&#125; &apos;valueOf&apos; &apos;(I)Ljava/lang/String;&apos; in &apos;java/lang/String&apos;)&#125;</span><span class="line">  0x000000010551742e: and    $0x7ffff8,%ebx</span><span class="line">  0x0000000105517434: cmp    $0x0,%ebx</span><span class="line">  0x0000000105517437: je     0x0000000105517591</span><span class="line">  0x000000010551743d: movabs $0x118bcb4d0,%rdi  ;   &#123;metadata(method data for &#123;method&#125; &#123;0x0000000118906500&#125; &apos;valueOf&apos; &apos;(I)Ljava/lang/String;&apos; in &apos;java/lang/String&apos;)&#125;</span><span class="line">  0x0000000105517447: addq   $0x1,0x108(%rdi)</span><span class="line">  0x000000010551744f: mov    %rsi,0x40(%rsp)</span><span class="line">  0x0000000105517454: mov    %rdx,%rsi          ;*invokestatic toString</span><span class="line">                                                ; - java.lang.String::valueOf@1 (line 3099)</span><span class="line">                                                ; - java.io.PrintStream::print@2 (line 597)</span><span class="line">                                                ; - java.io.PrintStream::println@6 (line 736)</span><span class="line"></span><span class="line">  0x0000000105517457: callq  0x0000000105144520  ; OopMap&#123;[64]=Oop [80]=Oop off=476&#125;</span><span class="line">                                                ;*invokestatic toString</span><span class="line">                                                ; - java.lang.String::valueOf@1 (line 3099)</span><span class="line">                                                ; - java.io.PrintStream::print@2 (line 597)</span><span class="line">                                                ; - java.io.PrintStream::println@6 (line 736)</span><span class="line">                                                ;   &#123;static_call&#125;</span><span class="line">  0x000000010551745c: mov    0x40(%rsp),%rsi</span><span class="line">  0x0000000105517461: movabs $0x118bcb360,%rdx  ;   &#123;metadata(method data for &#123;method&#125; &#123;0x0000000118a45fa8&#125; &apos;print&apos; &apos;(I)V&apos; in &apos;java/io/PrintStream&apos;)&#125;</span><span class="line">  0x000000010551746b: addq   $0x1,0x118(%rdx)</span><span class="line">  0x0000000105517473: mov    %rax,%rdx</span><span class="line">  0x0000000105517476: mov    0x40(%rsp),%rsi    ;*invokespecial write</span><span class="line">                                                ; - java.io.PrintStream::print@5 (line 597)</span><span class="line">                                                ; - java.io.PrintStream::println@6 (line 736)</span><span class="line"></span><span class="line">  0x000000010551747b: nop</span><span class="line">  0x000000010551747c: nop</span><span class="line">  0x000000010551747d: nop</span><span class="line">  0x000000010551747e: nop</span><span class="line">  0x000000010551747f: callq  0x00000001051440a0  ; OopMap&#123;[64]=Oop [80]=Oop off=516&#125;</span><span class="line">                                                ;*invokespecial write</span><span class="line">                                                ; - java.io.PrintStream::print@5 (line 597)</span><span class="line">                                                ; - java.io.PrintStream::println@6 (line 736)</span><span class="line">                                                ;   &#123;optimized virtual_call&#125;</span><span class="line">  0x0000000105517484: mov    0x40(%rsp),%rsi</span><span class="line">  0x0000000105517489: movabs $0x118bcb1b8,%rdi  ;   &#123;metadata(method data for &#123;method&#125; &#123;0x0000000118a46618&#125; &apos;println&apos; &apos;(I)V&apos; in &apos;java/io/PrintStream&apos;)&#125;</span><span class="line">  0x0000000105517493: addq   $0x1,0x138(%rdi)</span><span class="line">  0x000000010551749b: mov    0x40(%rsp),%rsi    ;*invokespecial newLine</span><span class="line">                                                ; - java.io.PrintStream::println@10 (line 737)</span><span class="line"></span><span class="line">  0x00000001055174a0: nop</span><span class="line">  0x00000001055174a1: nop</span><span class="line">  0x00000001055174a2: nop</span><span class="line">  0x00000001055174a3: nop</span><span class="line">  0x00000001055174a4: nop</span><span class="line">  0x00000001055174a5: nop</span><span class="line">  0x00000001055174a6: nop</span><span class="line">  0x00000001055174a7: callq  0x00000001051440a0  ; OopMap&#123;[64]=Oop [80]=Oop off=556&#125;</span><span class="line">                                                ;*invokespecial newLine</span><span class="line">                                                ; - java.io.PrintStream::println@10 (line 737)</span><span class="line">                                                ;   &#123;optimized virtual_call&#125;</span><span class="line">  0x00000001055174ac: lea    0x48(%rsp),%rax</span><span class="line">  0x00000001055174b1: mov    0x8(%rax),%rdi</span><span class="line">  0x00000001055174b5: mov    (%rdi),%rsi</span><span class="line">  0x00000001055174b8: and    $0x7,%rsi</span><span class="line">  0x00000001055174bc: cmp    $0x5,%rsi</span><span class="line">  0x00000001055174c0: je     0x00000001055174dd</span><span class="line">  0x00000001055174c6: mov    (%rax),%rsi</span><span class="line">  0x00000001055174c9: test   %rsi,%rsi</span><span class="line">  0x00000001055174cc: je     0x00000001055174dd</span><span class="line">  0x00000001055174d2: lock cmpxchg %rsi,(%rdi)</span><span class="line">  0x00000001055174d7: jne    0x00000001055175a8  ;*monitorexit</span><span class="line">                                                ; - java.io.PrintStream::println@14 (line 738)</span><span class="line"></span><span class="line">  0x00000001055174dd: movabs $0x118bcb1b8,%rax  ;   &#123;metadata(method data for &#123;method&#125; &#123;0x0000000118a46618&#125; &apos;println&apos; &apos;(I)V&apos; in &apos;java/io/PrintStream&apos;)&#125;</span><span class="line">  0x00000001055174e7: incl   0x148(%rax)        ;*goto</span><span class="line">                                                ; - java.io.PrintStream::println@15 (line 738)</span><span class="line"></span><span class="line">  0x00000001055174ed: add    $0x60,%rsp</span><span class="line">  0x00000001055174f1: pop    %rbp</span><span class="line">  0x00000001055174f2: test   %eax,-0x248f3f8(%rip)        # 0x0000000103088100</span><span class="line">                                                ;   &#123;poll_return&#125;</span><span class="line">  0x00000001055174f8: retq                      ;*return</span><span class="line">                                                ; - java.io.PrintStream::println@23 (line 739)</span></pre></td></tr></table></figure>
<h4 id="System-out-println-源码"><a href="#System-out-println-源码" class="headerlink" title="System.out.println 源码"></a>System.out.println 源码</h4><p>从上面输出日志里也可以第<code>402</code>行到第<code>488</code>行，关于<code>System.out.println</code>代码运行时的部分反汇编结果，是关于字节码指令<code>monitorenter</code>和<code>monitorexit</code>的执行部分。</p>
<img src="/blog/img/java/jmm/system-out-println.png" class="image-hg" title="[system-out-println]">
<h4 id="JITWatch-截屏"><a href="#JITWatch-截屏" class="headerlink" title="JITWatch 截屏"></a>JITWatch 截屏</h4><img src="/blog/img/java/java-volatile-print-assembly.png" class="image-hg" title="[java-volatile-print-assembly]">
<h3 id="参考文献-3"><a href="#参考文献-3" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li>Concurrent Programming in Java™: Design Principles and Pattern</li>
<li>JSR 133 (Java Memory Model) FAQ</li>
<li>JSR-133: Java Memory Model and Thread Specification</li>
<li>The JSR-133 Cookbook for Compiler Writers</li>
<li>Java 理论与实践: 正确使用 Volatile 变量</li>
<li>Java theory and practice: Fixing the Java Memory Model, Part 2</li>
</ol>
<h2 id="深入理解-Java-内存模型五：锁"><a href="#深入理解-Java-内存模型五：锁" class="headerlink" title="深入理解 Java 内存模型五：锁"></a>深入理解 Java 内存模型五：锁</h2><h3 id="锁的释放-获取建立的-happens-before-关系"><a href="#锁的释放-获取建立的-happens-before-关系" class="headerlink" title="锁的释放/获取建立的 happens-before 关系"></a>锁的释放/获取建立的 happens-before 关系</h3><p>锁是 java 并发编程中最重要的同步机制。锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。</p>
<p>下面是锁<strong>释放/获取</strong>的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonitorExample</span> </span>&#123;</span><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123; <span class="comment">// 1</span></span><span class="line">        a++;                            <span class="comment">// 2</span></span><span class="line">    &#125;                                   <span class="comment">// 3</span></span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123; <span class="comment">// 4</span></span><span class="line">        <span class="keyword">int</span> i = a;                      <span class="comment">// 5</span></span><span class="line">        <span class="comment">// ......</span></span><span class="line">    &#125;                                   <span class="comment">// 6</span></span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>假设线程 A 执行<code>writer()</code>方法，随后线程 B 执行<code>reader()</code>方法。根据<code>happens-before</code>规则，这个过程包含的<code>happens-before</code>关系可以分为两类：</p>
<ol>
<li>根据程序次序规则，1 happens-before 2, 2 happens-before 3; 4 happens-before 5, 5 happens-before 6。</li>
<li>根据监视器锁规则，3 happens-before 4。</li>
<li>根据 happens-before 的传递性，2 happens-before 5。</li>
</ol>
<p>上述 happens before 关系的图形化表现形式如下：</p>
<img src="/blog/img/java/jmm/jmm-51.png" class="image-md">
<p>在上图中，每一个箭头链接的两个节点，代表了一个<code>happens-before</code>关系。黑色箭头表示程序顺序规则；橙色箭头表示监视器锁规则；蓝色箭头表示组合这些规则后提供的<code>happens-before</code>保证。</p>
<p>上图表示在线程 A 释放了锁之后，随后线程 B 获取同一个锁。在上图中，2 <code>happens-before</code> 5。因此，线程 A 在释放锁之前所有可见的共享变量，在线程 B 获取同一个锁之后，将立刻变得对 B 线程可见。</p>
<h3 id="锁释放和获取的内存语义"><a href="#锁释放和获取的内存语义" class="headerlink" title="锁释放和获取的内存语义"></a>锁释放和获取的内存语义</h3><p>当线程释放锁时，JMM 会把该线程对应的本地内存中的共享变量刷新到主内存中。以上面的 MonitorExample 程序为例，A 线程释放锁后，共享数据的状态示意图如下：</p>
<img src="/blog/img/java/jmm/jmm-52.png" class="image-md">
<p>当线程获取锁时，JMM 会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须要从主内存中去读取共享变量。下面是锁获取的状态示意图：</p>
<img src="/blog/img/java/jmm/jmm-53.png" class="image-md">
<p>对比锁<strong>释放/获取</strong>的内存语义与 volatile <code>写-读</code>的内存语义，可以看出：</p>
<blockquote>
<p>锁释放与 volatile 写有相同的内存语义；锁获取与 volatile 读有相同的内存语义。</p>
</blockquote>
<p>下面对锁释放和锁获取的内存语义做个总结：</p>
<ol>
<li>线程 A 释放一个锁，实质上是线程 A 向接下来将要获取这个锁的某个线程发出了（线程 A 对共享变量所做修改的）消息。</li>
<li>线程 B 获取一个锁，实质上是线程 B 接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。</li>
<li>线程 A 释放锁，随后线程 B 获取这个锁，这个过程实质上是线程 A 通过主内存向线程 B 发送消息。</li>
</ol>
<h3 id="锁内存语义的实现"><a href="#锁内存语义的实现" class="headerlink" title="锁内存语义的实现"></a>锁内存语义的实现</h3><p>本文将借助 ReentrantLock 的源代码，来分析锁内存语义的具体实现机制。</p>
<p>请看下面的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockExample</span> </span>&#123;</span><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><span class="line">        lock.lock();        <span class="comment">// 获取锁</span></span><span class="line">        <span class="keyword">try</span> &#123;</span><span class="line">            a++;</span><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><span class="line">            lock.unlock();  <span class="comment">// 释放锁</span></span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><span class="line">        lock.lock();        <span class="comment">// 获取锁</span></span><span class="line">        <span class="keyword">try</span> &#123;</span><span class="line">            <span class="keyword">int</span> i = a;</span><span class="line">            <span class="comment">// ......</span></span><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><span class="line">            lock.unlock();  <span class="comment">// 释放锁</span></span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>在 ReentrantLock 中，调用<code>lock()</code>方法获取锁；调用<code>unlock()</code>方法释放锁。</p>
<p>ReentrantLock 的实现依赖于 java 同步器框架 AbstractQueuedSynchronizer（本文简称之为 AQS）。AQS 使用一个整型的 volatile 变量（命名为 state）来维护同步状态，马上我们会看到，这个 volatile 变量是 ReentrantLock 内存语义实现的关键。 下面是 ReentrantLock 的类图（仅画出与本文相关的部分）：</p>
<img src="/blog/img/java/jmm/jmm-54.png" class="image-md">
<p>ReentrantLock 分为公平锁和非公平锁，我们首先分析<strong>公平锁</strong>。</p>
<p>使用公平锁时，加锁方法<code>lock()</code>的方法调用轨迹如下：</p>
<ol>
<li>ReentrantLock : lock()</li>
<li>FairSync : lock()</li>
<li>AbstractQueuedSynchronizer : acquire(int arg)</li>
<li>ReentrantLock : tryAcquire(int acquires)</li>
</ol>
<p>在第 4 步真正开始加锁，下面是该方法的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><span class="line">    <span class="keyword">int</span> c = getState();  <span class="comment">// 获取锁的开始，首先读 volatile 变量 state</span></span><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><span class="line">        <span class="keyword">if</span> (isFirst(current) &amp;&amp;</span><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><span class="line">            setExclusiveOwnerThread(current);</span><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><span class="line">        setState(nextc);</span><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><span class="line">    &#125;</span><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>从上面源代码中我们可以看出，加锁方法首先读 volatile 变量 state。</p>
<p>在使用公平锁时，解锁方法<code>unlock()</code>的方法调用轨迹如下：</p>
<ol>
<li>ReentrantLock : unlock()</li>
<li>AbstractQueuedSynchronizer : release(int arg)</li>
<li>Sync : tryRelease(int releases)</li>
</ol>
<p>在第 3 步真正开始释放锁，下面是该方法的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><span class="line">        free = <span class="keyword">true</span>;</span><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><span class="line">    &#125;</span><span class="line">    setState(c);          <span class="comment">// 释放锁的最后，写 volatile 变量 state</span></span><span class="line">    <span class="keyword">return</span> free;</span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>从上面的源代码我们可以看出，在释放锁的最后写 volatile 变量 state。</p>
<p>公平锁在释放锁的最后写 volatile 变量 state；在获取锁时首先读这个 volatile 变量。根据 volatile 的<code>happens-before</code>规则，释放锁的线程在写 volatile 变量之前可见的共享变量，在获取锁的线程读取同一个 volatile 变量后将立即变的对获取锁的线程可见。</p>
<p>现在我们分析非公平锁的内存语义的实现。</p>
<p><strong>非公平锁</strong>的释放和公平锁完全一样，所以这里仅仅分析非公平锁的获取。</p>
<p>使用公平锁时，加锁方法<code>lock()</code>的方法调用轨迹如下：</p>
<ol>
<li>ReentrantLock : lock()</li>
<li>NonfairSync : lock()</li>
<li>AbstractQueuedSynchronizer : compareAndSetState(int expect, int update)</li>
</ol>
<p>在第 3 步真正开始加锁，下面是该方法的源代码：</p>
<figure class="highlight java"><figcaption><span>java.util.concurrent.locks.AbstractQueuedSynchronizer.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">553</span><span class="line">554</span><span class="line">555</span><span class="line">556</span><span class="line">557</span><span class="line">558</span><span class="line">559</span><span class="line">560</span><span class="line">561</span><span class="line">562</span><span class="line">563</span><span class="line">564</span><span class="line">565</span><span class="line">566</span><span class="line">567</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><span class="line"><span class="comment"> * Atomically sets synchronization state to the given updated</span></span><span class="line"><span class="comment"> * value if the current state value equals the expected value.</span></span><span class="line"><span class="comment"> * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read</span></span><span class="line"><span class="comment"> * and write.</span></span><span class="line"><span class="comment"> *</span></span><span class="line"><span class="comment"> * <span class="doctag">@param</span> expect the expected value</span></span><span class="line"><span class="comment"> * <span class="doctag">@param</span> update the new value</span></span><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that the actual</span></span><span class="line"><span class="comment"> *         value was not equal to the expected value.</span></span><span class="line"><span class="comment"> */</span></span><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>该方法以原子操作的方式更新 state 变量，本文把 java 的<code>compareAndSet()</code>方法调用简称为 CAS。</p>
<p>JDK 文档对该方法的说明如下：</p>
<blockquote>
<p>如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值，此操作具有 volatile 读和写的内存语义。</p>
</blockquote>
<h4 id="CAS-具有-volatile-读写内存语义示例代码"><a href="#CAS-具有-volatile-读写内存语义示例代码" class="headerlink" title="CAS 具有 volatile 读写内存语义示例代码"></a>CAS 具有 volatile 读写内存语义示例代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASVolatileSemantics</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(CASVolatileSemantics<span class="class">.<span class="keyword">class</span>)</span>;</span><span class="line"></span><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, InterruptedException </span>&#123;</span><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><span class="line">        casAdder();</span><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><span class="line">        LOGGER.info(<span class="string">"duration of cas : &#123;&#125;"</span>, (end - start)/<span class="number">1000000</span>);</span><span class="line"></span><span class="line">        start = System.nanoTime();</span><span class="line">        synchronizedAdder();</span><span class="line">        end = System.nanoTime();</span><span class="line">        LOGGER.info(<span class="string">"duration of synchronized : &#123;&#125;"</span>, (end - start)/<span class="number">1000000</span>);</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><span class="line"><span class="comment">     * * Setup to support compareAndSet. We need to natively implement</span></span><span class="line"><span class="comment">     * * this here: For the sake of permitting future enhancements, we</span></span><span class="line"><span class="comment">     * * cannot explicitly subclass AtomicInteger, which would be</span></span><span class="line"><span class="comment">     * * efficient and useful otherwise. So, as the lesser of evils, we</span></span><span class="line"><span class="comment">     * * natively implement using hotspot intrinsics API. And while we</span></span><span class="line"><span class="comment">     * * are at it, we do the same for other CASable fields (which could</span></span><span class="line"><span class="comment">     * * otherwise be done with atomic field updaters).</span></span><span class="line"><span class="comment">     *</span></span><span class="line"><span class="comment">     * private static final Unsafe unsafe = Unsafe.getUnsafe();</span></span><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><span class="line">        <span class="keyword">try</span> &#123;</span><span class="line">            Field field = Unsafe.class.getDeclaredField("theUnsafe");</span><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><span class="line">            <span class="keyword">return</span> (Unsafe) field.get(<span class="keyword">null</span>);</span><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">casAdder</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, InterruptedException </span>&#123;</span><span class="line">        <span class="keyword">final</span> Unsafe unsafe = getUnsafe();</span><span class="line">        <span class="keyword">final</span> CASVolatileSemantics cas = <span class="keyword">new</span> CASVolatileSemantics();</span><span class="line">        final long fieldOffset = unsafe.objectFieldOffset(CASVolatileSemantics.class.getDeclaredField("i"));</span><span class="line">        <span class="keyword">final</span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">4</span>);</span><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><span class="line">            executorService.submit(() -&gt; &#123;</span><span class="line">                LOGGER.info(<span class="string">"start thread : &#123;&#125;"</span>, Thread.currentThread().getName());</span><span class="line">                <span class="keyword">int</span> counter = <span class="number">0</span>;</span><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> loop = <span class="number">0</span>; loop &lt; <span class="number">100_000_000</span>; loop++) &#123;</span><span class="line">                    <span class="keyword">for</span> (;;) &#123;</span><span class="line">                        <span class="keyword">int</span> current = cas.i;</span><span class="line">                        <span class="comment">// 这个还是要看脸的，运气好冲突少，很快就执行完，冲突多就很慢，比 synchronized 还慢</span></span><span class="line">                        <span class="comment">// 快的 10 秒完成，慢则 30 秒，而 synchronized 比较稳定在 15 秒左右</span></span><span class="line">                        <span class="keyword">if</span> (unsafe.compareAndSwapInt(cas, fieldOffset, current, current + <span class="number">1</span>)) &#123;</span><span class="line">                            <span class="keyword">break</span>;</span><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><span class="line">                            <span class="comment">// 记录失败次数</span></span><span class="line">                            counter++;</span><span class="line">                        &#125;</span><span class="line">                    &#125;</span><span class="line">                &#125;</span><span class="line">                LOGGER.info(<span class="string">"unsafe.compareAndSwapInt failure counter : &#123;&#125;"</span>, counter);</span><span class="line">            &#125;);</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        executorService.shutdown();</span><span class="line"></span><span class="line">        <span class="keyword">if</span> (!executorService.awaitTermination(<span class="number">60L</span>, TimeUnit.SECONDS)) &#123;</span><span class="line">            LOGGER.info(<span class="string">"termination failure"</span>);</span><span class="line">            executorService.shutdownNow();</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        LOGGER.info(<span class="string">"CAS i = &#123;&#125;"</span>, cas.i);</span><span class="line">    &#125;</span><span class="line"></span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">synchronizedAdder</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><span class="line">        <span class="keyword">final</span> CASVolatileSemantics cas = <span class="keyword">new</span> CASVolatileSemantics();</span><span class="line">        <span class="keyword">final</span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">4</span>);</span><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><span class="line">            executorService.submit(() -&gt; &#123;</span><span class="line">                LOGGER.info(<span class="string">"start thread : &#123;&#125;"</span>, Thread.currentThread().getName());</span><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> loop = <span class="number">0</span>; loop &lt; <span class="number">100_000_000</span>; loop++) &#123;</span><span class="line">                    <span class="keyword">synchronized</span> (cas) &#123;</span><span class="line">                        cas.i = cas.i + <span class="number">1</span>;</span><span class="line">                    &#125;</span><span class="line">                &#125;</span><span class="line">            &#125;);</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        executorService.shutdown();</span><span class="line"></span><span class="line">        <span class="keyword">if</span> (!executorService.awaitTermination(<span class="number">60L</span>, TimeUnit.SECONDS)) &#123;</span><span class="line">            LOGGER.info(<span class="string">"termination failure"</span>);</span><span class="line">            executorService.shutdownNow();</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        LOGGER.info(<span class="string">"synchronized cas.i = &#123;&#125;"</span>, cas.i);</span><span class="line">    &#125;</span><span class="line"></span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>下面分别从编译器和处理器的角度来分析，CAS 如何同时具有 volatile 读和 volatile 写的内存语义。</p>
<p>前文我们提到过，编译器不会对 volatile 读与 volatile 读后面的任意内存操作重排序；编译器不会对 volatile 写与 volatile 写前面的任意内存操作重排序。组合这两个条件，意味着为了同时实现 volatile 读和 volatile 写的内存语义，编译器不能对 CAS 与 CAS 前面和后面的任意内存操作重排序。</p>
<p>下面我们来分析在常见的 intel x86 处理器中，CAS 是如何同时具有 volatile 读和 volatile 写的内存语义的。</p>
<p>下面是<code>sun.misc.Unsafe</code>类的<code>compareAndSwapInt()</code>方法的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><span class="line"><span class="function"><span class="params">         <span class="keyword">int</span> expected,</span></span></span><span class="line"><span class="function"><span class="params">         <span class="keyword">int</span> x)</span></span>;</span></pre></td></tr></table></figure>
<p>可以看到这是个本地方法调用。</p>
<p>这个本地方法在 openjdk8 中依次调用的<code>c++</code>代码为：</p>
<ol>
<li>unsafe.cpp</li>
<li>atomic.cpp</li>
<li>atomic_linux_x86.inline.hpp</li>
</ol>
<p>下面是 x86 处理器在 linux 平台上的相关<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/f3108e56b502/src/os_cpu/linux_x86/vm/atomic_linux_x86.inline.hpp#93" target="_blank" rel="noopener">源码</a>：</p>
<figure class="highlight cpp"><figcaption><span>http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/f3108e56b502/src/os_cpu/linux_x86/vm/atomic_linux_x86.inline.hpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">47</span><span class="line">48</span><span class="line">49</span><span class="line">50</span><span class="line">51</span><span class="line">52</span><span class="line">53</span><span class="line">54</span><span class="line">55</span><span class="line">56</span><span class="line">57</span><span class="line">58</span><span class="line">59</span><span class="line">60</span><span class="line">61</span><span class="line">62</span><span class="line">63</span><span class="line">64</span><span class="line">65</span><span class="line">66</span><span class="line">67</span><span class="line">68</span><span class="line">69</span><span class="line">70</span><span class="line">71</span><span class="line">72</span><span class="line">73</span><span class="line">74</span><span class="line">75</span><span class="line">76</span><span class="line">77</span><span class="line">78</span><span class="line">79</span><span class="line">80</span><span class="line">81</span><span class="line">82</span><span class="line">83</span><span class="line">84</span><span class="line">85</span><span class="line">86</span><span class="line">87</span><span class="line">88</span><span class="line">89</span><span class="line">90</span><span class="line">91</span><span class="line">92</span><span class="line">93</span><span class="line">94</span><span class="line">95</span><span class="line">96</span><span class="line">97</span><span class="line">98</span><span class="line">99</span><span class="line">100</span><span class="line">101</span><span class="line">102</span><span class="line">103</span><span class="line">104</span><span class="line">105</span><span class="line">106</span><span class="line">107</span><span class="line">108</span><span class="line">109</span><span class="line">110</span><span class="line">111</span><span class="line">112</span><span class="line">113</span><span class="line">114</span><span class="line">115</span><span class="line">116</span><span class="line">117</span><span class="line">118</span><span class="line">119</span><span class="line">120</span><span class="line">121</span><span class="line">122</span><span class="line">123</span><span class="line">124</span><span class="line">125</span><span class="line">126</span><span class="line">127</span><span class="line">128</span><span class="line">129</span><span class="line">130</span><span class="line">131</span><span class="line">132</span><span class="line">133</span><span class="line">134</span><span class="line">135</span><span class="line">136</span><span class="line">137</span><span class="line">138</span><span class="line">139</span><span class="line">140</span><span class="line">141</span><span class="line">142</span><span class="line">143</span><span class="line">144</span><span class="line">145</span><span class="line">146</span><span class="line">147</span><span class="line">148</span><span class="line">149</span><span class="line">150</span><span class="line">151</span><span class="line">152</span><span class="line">153</span><span class="line">154</span><span class="line">155</span><span class="line">156</span><span class="line">157</span><span class="line">158</span><span class="line">159</span><span class="line">160</span><span class="line">161</span><span class="line">162</span><span class="line">163</span><span class="line">164</span><span class="line">165</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Adding a lock prefix to an instruction on MP machine</span></span><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) <span class="meta-string">"cmp $0, "</span> #mp <span class="meta-string">"; je 1f; lock; 1: "</span></span></span><span class="line"></span><span class="line"><span class="function"><span class="keyword">inline</span> jint     <span class="title">Atomic::add</span>    <span class="params">(jint     add_value, <span class="keyword">volatile</span> jint*     dest)</span> </span>&#123;</span><span class="line">  jint addend = add_value;</span><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(  LOCK_IF_MP(%<span class="number">3</span>) <span class="string">"xaddl %0,(%2)"</span></span></span></span><span class="line"><span class="function"><span class="params">                    : <span class="string">"=r"</span> (addend)</span></span></span><span class="line"><span class="function"><span class="params">                    : <span class="string">"0"</span> (addend), <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp)</span></span></span><span class="line"><span class="function"><span class="params">                    : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><span class="line">  <span class="keyword">return</span> addend + add_value;</span><span class="line">&#125;</span><span class="line"></span><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Atomic::inc</span>    <span class="params">(<span class="keyword">volatile</span> jint*     dest)</span> </span>&#123;</span><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">1</span>) <span class="string">"addl $1,(%0)"</span> :</span></span></span><span class="line"><span class="function"><span class="params">                    : <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp) : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><span class="line">&#125;</span><span class="line"></span><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Atomic::inc_ptr</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">void</span>*     dest)</span> </span>&#123;</span><span class="line">  inc_ptr((<span class="keyword">volatile</span> <span class="keyword">intptr_t</span>*)dest);</span><span class="line">&#125;</span><span class="line"></span><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Atomic::dec</span>    <span class="params">(<span class="keyword">volatile</span> jint*     dest)</span> </span>&#123;</span><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">1</span>) <span class="string">"subl $1,(%0)"</span> :</span></span></span><span class="line"><span class="function"><span class="params">                    : <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp) : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><span class="line">&#125;</span><span class="line"></span><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Atomic::dec_ptr</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">void</span>*     dest)</span> </span>&#123;</span><span class="line">  dec_ptr((<span class="keyword">volatile</span> <span class="keyword">intptr_t</span>*)dest);</span><span class="line">&#125;</span><span class="line"></span><span class="line"><span class="function"><span class="keyword">inline</span> jint     <span class="title">Atomic::xchg</span>    <span class="params">(jint     exchange_value, <span class="keyword">volatile</span> jint*     dest)</span> </span>&#123;</span><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(  <span class="string">"xchgl (%2),%0"</span></span></span></span><span class="line"><span class="function"><span class="params">                    : <span class="string">"=r"</span> (exchange_value)</span></span></span><span class="line"><span class="function"><span class="params">                    : <span class="string">"0"</span> (exchange_value), <span class="string">"r"</span> (dest)</span></span></span><span class="line"><span class="function"><span class="params">                    : <span class="string">"memory"</span>)</span></span>;</span><span class="line">  <span class="keyword">return</span> exchange_value;</span><span class="line">&#125;</span><span class="line"></span><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span>*    <span class="title">Atomic::xchg_ptr</span><span class="params">(<span class="keyword">void</span>*    exchange_value, <span class="keyword">volatile</span> <span class="keyword">void</span>*     dest)</span> </span>&#123;</span><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span>*)xchg_ptr((<span class="keyword">intptr_t</span>)exchange_value, (<span class="keyword">volatile</span> <span class="keyword">intptr_t</span>*)dest);</span><span class="line">&#125;</span><span class="line"></span><span class="line"></span><span class="line"><span class="function"><span class="keyword">inline</span> jint     <span class="title">Atomic::cmpxchg</span>    <span class="params">(jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value)</span> </span>&#123;</span><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">"cmpxchgl %1,(%3)"</span></span></span></span><span class="line"><span class="function"><span class="params">                    : <span class="string">"=a"</span> (exchange_value)</span></span></span><span class="line"><span class="function"><span class="params">                    : <span class="string">"r"</span> (exchange_value), <span class="string">"a"</span> (compare_value), <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp)</span></span></span><span class="line"><span class="function"><span class="params">                    : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><span class="line">  <span class="keyword">return</span> exchange_value;</span><span class="line">&#125;</span><span class="line"></span><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AMD64</span></span><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Atomic::store</span>    <span class="params">(jlong    store_value, jlong*    dest)</span> </span>&#123; *dest = store_value; &#125;</span><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Atomic::store</span>    <span class="params">(jlong    store_value, <span class="keyword">volatile</span> jlong*    dest)</span> </span>&#123; *dest = store_value; &#125;</span><span class="line"></span><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">intptr_t</span> <span class="title">Atomic::add_ptr</span><span class="params">(<span class="keyword">intptr_t</span> add_value, <span class="keyword">volatile</span> <span class="keyword">intptr_t</span>* dest)</span> </span>&#123;</span><span class="line">  <span class="keyword">intptr_t</span> addend = add_value;</span><span class="line">  <span class="keyword">bool</span> mp = os::is_MP();</span><span class="line">  __asm__ __volatile__ (LOCK_IF_MP(%<span class="number">3</span>) <span class="string">"xaddq %0,(%2)"</span></span><span class="line">                        : <span class="string">"=r"</span> (addend)</span><span class="line">                        : <span class="string">"0"</span> (addend), <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp)</span><span class="line">                        : <span class="string">"cc"</span>, <span class="string">"memory"</span>);</span><span class="line">  <span class="keyword">return</span> addend + add_value;</span><span class="line">&#125;</span><span class="line"></span><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span>*    <span class="title">Atomic::add_ptr</span><span class="params">(<span class="keyword">intptr_t</span> add_value, <span class="keyword">volatile</span> <span class="keyword">void</span>*     dest)</span> </span>&#123;</span><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span>*)add_ptr(add_value, (<span class="keyword">volatile</span> <span class="keyword">intptr_t</span>*)dest);</span><span class="line">&#125;</span><span class="line"></span><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Atomic::inc_ptr</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">intptr_t</span>* dest)</span> </span>&#123;</span><span class="line">  <span class="keyword">bool</span> mp = os::is_MP();</span><span class="line">  __asm__ __volatile__ (LOCK_IF_MP(%<span class="number">1</span>) <span class="string">"addq $1,(%0)"</span></span><span class="line">                        :</span><span class="line">                        : <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp)</span><span class="line">                        : <span class="string">"cc"</span>, <span class="string">"memory"</span>);</span><span class="line">&#125;</span><span class="line"></span><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Atomic::dec_ptr</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">intptr_t</span>* dest)</span> </span>&#123;</span><span class="line">  <span class="keyword">bool</span> mp = os::is_MP();</span><span class="line">  __asm__ __volatile__ (LOCK_IF_MP(%<span class="number">1</span>) <span class="string">"subq $1,(%0)"</span></span><span class="line">                        :</span><span class="line">                        : <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp)</span><span class="line">                        : <span class="string">"cc"</span>, <span class="string">"memory"</span>);</span><span class="line">&#125;</span><span class="line"></span><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">intptr_t</span> <span class="title">Atomic::xchg_ptr</span><span class="params">(<span class="keyword">intptr_t</span> exchange_value, <span class="keyword">volatile</span> <span class="keyword">intptr_t</span>* dest)</span> </span>&#123;</span><span class="line">  __asm__ __volatile__ (<span class="string">"xchgq (%2),%0"</span></span><span class="line">                        : <span class="string">"=r"</span> (exchange_value)</span><span class="line">                        : <span class="string">"0"</span> (exchange_value), <span class="string">"r"</span> (dest)</span><span class="line">                        : <span class="string">"memory"</span>);</span><span class="line">  <span class="keyword">return</span> exchange_value;</span><span class="line">&#125;</span><span class="line"></span><span class="line"><span class="function"><span class="keyword">inline</span> jlong    <span class="title">Atomic::cmpxchg</span>    <span class="params">(jlong    exchange_value, <span class="keyword">volatile</span> jlong*    dest, jlong    compare_value)</span> </span>&#123;</span><span class="line">  <span class="keyword">bool</span> mp = os::is_MP();</span><span class="line">  __asm__ __volatile__ (LOCK_IF_MP(%<span class="number">4</span>) <span class="string">"cmpxchgq %1,(%3)"</span></span><span class="line">                        : <span class="string">"=a"</span> (exchange_value)</span><span class="line">                        : <span class="string">"r"</span> (exchange_value), <span class="string">"a"</span> (compare_value), <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp)</span><span class="line">                        : <span class="string">"cc"</span>, <span class="string">"memory"</span>);</span><span class="line">  <span class="keyword">return</span> exchange_value;</span><span class="line">&#125;</span><span class="line"></span><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">intptr_t</span> <span class="title">Atomic::cmpxchg_ptr</span><span class="params">(<span class="keyword">intptr_t</span> exchange_value, <span class="keyword">volatile</span> <span class="keyword">intptr_t</span>* dest, <span class="keyword">intptr_t</span> compare_value)</span> </span>&#123;</span><span class="line">  <span class="keyword">return</span> (<span class="keyword">intptr_t</span>)cmpxchg((jlong)exchange_value, (<span class="keyword">volatile</span> jlong*)dest, (jlong)compare_value);</span><span class="line">&#125;</span><span class="line"></span><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span>*    <span class="title">Atomic::cmpxchg_ptr</span><span class="params">(<span class="keyword">void</span>*    exchange_value, <span class="keyword">volatile</span> <span class="keyword">void</span>*     dest, <span class="keyword">void</span>*    compare_value)</span> </span>&#123;</span><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span>*)cmpxchg((jlong)exchange_value, (<span class="keyword">volatile</span> jlong*)dest, (jlong)compare_value);</span><span class="line">&#125;</span><span class="line"></span><span class="line"><span class="function"><span class="keyword">inline</span> jlong <span class="title">Atomic::load</span><span class="params">(<span class="keyword">volatile</span> jlong* src)</span> </span>&#123; <span class="keyword">return</span> *src; &#125;</span><span class="line"></span><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// !AMD64</span></span></span><span class="line"><span class="comment">// ......</span></span><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// AMD64</span></span></span></pre></td></tr></table></figure>
<p>如上面源代码所示，其中<code>cmpxchgl</code>和<code>cmpxchgq</code>的最后 CPU 实际指令就是<code>cmpxchg</code>，只是汇编指令的运行细节上的包装，宏命令<code>LOCK_IF_MP</code>会根据当前处理器的类型来决定是否为<code>cmpxchg</code>指令添加<code>LOCK</code>前缀。如果程序是在多处理器上运行，就为<code>cmpxchg</code>指令加上<code>lock</code>前缀（<code>lock cmpxchg</code>）。反之，如果程序是在单处理器上运行，就省略<code>LOCK 前缀</code>（单处理器自身会维护单处理器内的顺序一致性，不需要<code>LOCK 前缀</code>提供的<code>内存屏障</code>效果）。</p>
<h3 id="CAS-实现说明"><a href="#CAS-实现说明" class="headerlink" title="CAS 实现说明"></a>CAS 实现说明</h3><p>Intel 的手册对<code>LOCK 前缀</code>的说明如下：</p>
<ol>
<li>确保对内存的<code>读-改-写</code>操作原子执行。在 Pentium 及 Pentium 之前的处理器中，带有 LOCK 前缀的指令在执行期间会锁住总线，使得其他处理器暂时无法通过总线访问内存。很显然，这会带来昂贵的开销。从 Pentium 4，Intel Xeon 及 P6 处理器开始，intel 在原有总线锁的基础上做了一个很有意义的优化：<br> 如果要访问的内存区域（area of memory）在 LOCK 前缀指令执行期间已经在处理器内部的缓存中被锁定（即包含该内存区域的缓存行当前处于独占或以修改状态），并且该内存区域被完全包含在单个缓存行（cache line）中，那么处理器将直接执行该指令。由于在指令执行期间该缓存行会一直被锁定，其它处理器无法<code>读/写</code>该指令要访问的内存区域，因此能保证指令执行的原子性。<br> 这个操作过程叫做缓存锁定（cache locking），缓存锁定将大大降低 LOCK 前缀指令的执行开销，但是当多处理器之间的竞争程度很高或者指令访问的内存地址未对齐时，仍然会锁住总线。</li>
<li>禁止该指令与之前的读和之后的写指令重排序。</li>
<li>把写缓冲区中的所有数据刷新到内存中。</li>
</ol>
<p>上面的第 2 点和第 3 点所具有的内存屏障效果，足以同时实现 volatile 读和 volatile 写的内存语义，需要注意的是虽然 CAS 具有 volatile 的内存语义，但是 AQS 实现里仍然需要一个 volatile 共享变量来控制此变量对于别的线程的可见性。</p>
<p>经过上面的这些分析，现在我们终于能明白为什么 JDK 文档说 CAS 同时具有 volatile 读和 volatile 写的内存语义了。</p>
<p>在 x86 架构上，CAS 被翻译为<code>lock cmpxchg</code>。<code>cmpxchg</code>是 CAS 的汇编指令。在 CPU 架构中依靠<code>lock</code>信号保证可见性并禁止重排序。</p>
<p><code>LOCK 前缀</code>是一个特殊的信号，执行过程如下：</p>
<ol>
<li>对总线和缓存上锁。</li>
<li>强制所有 lock 信号之前的指令，都在此之前被执行，并同步相关缓存。</li>
<li>执行 lock 后的指令（如 cmpxchg）。</li>
<li>释放对总线和缓存上的锁。</li>
<li>强制所有 lock 信号之后的指令，都在此之后被执行，并同步相关缓存。</li>
</ol>
<p>因此，lock 信号虽然不是内存屏障，但具有<code>MFENCE</code>的语义（当然，还有排他性的语义），与内存屏障相比，lock 信号要额外对总线和缓存上锁，成本更高。</p>
<h3 id="stackoverflow-上对于-LOCK-前缀的解释"><a href="#stackoverflow-上对于-LOCK-前缀的解释" class="headerlink" title="stackoverflow 上对于 LOCK 前缀的解释"></a>stackoverflow 上对于 LOCK 前缀的解释</h3><blockquote>
<p><code>LOCK</code> is not an instruction itself: it is an instruction prefix, which applies to the following instruction. That instruction must be something that does a read-modify-write on memory (<code>inc</code>, <code>xchg</code>, <code>cmpxchg</code> etc.)</p>
<p>The <code>LOCK</code> prefix ensures that the CPU has exclusive ownership of the appropriate cache line for the duration of the operation, and provides certain additional ordering guarantees. This may be achieved by asserting a bus lock, but the CPU will avoid this where possible. If the bus is locked then it is only for the duration of the locked instruction.</p>
</blockquote>
<h3 id="IA-32-Intel®-Architecture-Software-Developer’s-Manual"><a href="#IA-32-Intel®-Architecture-Software-Developer’s-Manual" class="headerlink" title="IA-32 Intel® Architecture Software Developer’s Manual"></a>IA-32 Intel® Architecture Software Developer’s Manual</h3><p><a href="http://www.scs.stanford.edu/05au-cs240c/lab/ia32/IA32-2A.pdf" target="_blank" rel="noopener">http://www.scs.stanford.edu/05au-cs240c/lab/ia32/IA32-2A.pdf</a> 文档或者是 <a href="https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf" target="_blank" rel="noopener">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> 中关于 LOCK 前缀的说明，摘录如下：</p>
<blockquote>
<p>The LOCK prefix (F0H) forces an operation that ensures exclusive use of shared memory in a multiprocessor environment.</p>
</blockquote>
<h3 id="LOCK—Assert-LOCK-Signal-Prefix"><a href="#LOCK—Assert-LOCK-Signal-Prefix" class="headerlink" title="LOCK—Assert LOCK# Signal Prefix"></a>LOCK—Assert LOCK# Signal Prefix</h3><table>    <thead>        <tr>            <th style="text-align:center;width:10%;">Opcode*</th>            <th style="text-align:cente;width:10%;r">Instruction</th>            <th style="text-align:cente;width:10%;r">64-Bit Mode</th>            <th style="text-align:lef;width:15%;t">Compat/Leg Mode</th>            <th style="text-align:left">Description</th>        </tr>    </thead>    <tbody>        <tr>            <td style="text-align:center">F0</td>            <td style="text-align:center">LOCK</td>            <td style="text-align:center">Valid</td>            <td style="text-align:left">Valid</td>            <td style="text-align:left">Asserts LOCK# signal for duration of the accompanying instruction.</td>        </tr>    </tbody></table>

<blockquote>
<p>NOTES: * See IA-32 Architecture Compatibility section below.</p>
</blockquote>
<h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>Causes the processor’s LOCK# signal to be asserted during execution of the accompanying instruction (turns the instruction into an atomic instruction). In a multiprocessor environment, the LOCK# signal insures that the processor has exclusive use of any shared memory while the signal is asserted.</p>
<p>Note that, in later IA-32 processors (including the Pentium 4, Intel Xeon, and P6 family processors), locking may occur without the LOCK# signal being asserted. See IA-32 Architecture Compatibility below.</p>
<p>The LOCK prefix can be prepended only to the following instructions and only to those forms of the instructions where the destination operand is a memory operand: ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG. If the LOCK prefix is used with one of these instructions and the source operand is a memory operand, an undefined opcode exception (#UD) may be generated. An undefined opcode exception will also be generated if the LOCK prefix is used with any instruction not in the above list. The XCHG instruction always asserts the LOCK# signal regardless of the presence or absence of the LOCK prefix.</p>
<p>The LOCK prefix is typically used with the BTS instruction to perform a <code>read-modify-write</code> operation on a memory location in shared memory environment.</p>
<p>The integrity of the LOCK prefix is not affected by the alignment of the memory field. Memory locking is observed for arbitrarily misaligned fields.</p>
<p>This instruction’s operation is the same in non-64-bit modes and 64-bit mode.</p>
<h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><p>现在对<strong>公平锁</strong>和<strong>非公平锁</strong>的内存语义做个总结：</p>
<ol>
<li>公平锁和非公平锁释放时，最后都要写一个 volatile 变量 state。</li>
<li>公平锁获取时，首先会去读这个 volatile 变量。</li>
<li>非公平锁获取时，首先会用 CAS 更新这个 volatile 变量,这个操作同时具有 volatile 读和 volatile 写的内存语义。</li>
</ol>
<p>从本文对 ReentrantLock 的分析可以看出，锁<strong>释放/获取</strong>的内存语义的实现至少有下面两种方式：</p>
<ol>
<li>利用 volatile 变量的<code>写-读</code>所具有的内存语义。</li>
<li>利用 CAS 所附带的 volatile 读和 volatile 写的内存语义。</li>
</ol>
<h3 id="concurrent-包的实现"><a href="#concurrent-包的实现" class="headerlink" title="concurrent 包的实现"></a>concurrent 包的实现</h3><p>由于 java 的 CAS 同时具有 volatile 读和 volatile 写的内存语义，因此 Java 线程之间的通信现在有了下面四种方式：</p>
<ol>
<li>A 线程写 volatile 变量，随后 B 线程读这个 volatile 变量。</li>
<li>A 线程写 volatile 变量，随后 B 线程用 CAS 更新这个 volatile 变量。</li>
<li>A 线程用 CAS 更新一个 volatile 变量，随后 B 线程用 CAS 更新这个 volatile 变量。</li>
<li>A 线程用 CAS 更新一个 volatile 变量，随后 B 线程读这个 volatile 变量。</li>
</ol>
<p>Java 的 CAS 会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行<code>读-改-写</code>操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性<code>读-改-写</code>指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性<code>读-改-写</code>操作的原子指令）。同时，volatile 变量的<code>读/写</code>和 CAS 可以实现线程之间的通信，把这些特性整合在一起，就形成了整个 concurrent 包得以实现的基石。</p>
<p>如果我们仔细分析 concurrent 包的源代码实现，会发现一个通用化的实现模式：</p>
<ol>
<li>首先，声明共享变量为 volatile；</li>
<li>然后，使用 CAS 的原子条件更新来实现线程之间的同步；</li>
<li>同时，配合以 volatile 的<code>读/写</code>和 CAS 所具有的 volatile <code>读和写</code>的内存语义来实现线程之间的通信。</li>
</ol>
<p>AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic 包中的类），这些 concurrent 包中的基础类都是使用这种模式来实现的，而 concurrent 包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent 包的实现示意图如下：</p>
<img src="/blog/img/java/jmm/jmm-55.png" class="image-md">
<h3 id="参考文献-4"><a href="#参考文献-4" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li>Concurrent Programming in Java: Design Principles and Pattern</li>
<li>JSR 133 (Java Memory Model) FAQ</li>
<li>JSR-133: Java Memory Model and Thread Specification</li>
<li>Java Concurrency in Practice</li>
<li>Java™ Platform, Standard Edition 6 API Specification</li>
<li>The JSR-133 Cookbook for Compiler Writers</li>
<li>Intel® 64 and IA-32 ArchitecturesvSoftware Developer’s Manual Volume 3A: System Programming Guide, Part 1</li>
<li>The Art of Multiprocessor Programming</li>
</ol>
<h2 id="深入理解-Java-内存模型六：final"><a href="#深入理解-Java-内存模型六：final" class="headerlink" title="深入理解 Java 内存模型六：final"></a>深入理解 Java 内存模型六：final</h2><p>与前面介绍的锁和 volatile 相比较，对 final 域的读和写更像是普通的变量访问。对于 final 域，编译器和处理器要遵守两个重排序规则：</p>
<ol>
<li>在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
<li>初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序。</li>
</ol>
<p>下面，我们通过一些示例性的代码来分别说明这两个规则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalExample</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="keyword">int</span> i;                              <span class="comment">// 普通变量</span></span><span class="line"></span><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> j;                        <span class="comment">// final 变量</span></span><span class="line"></span><span class="line">    <span class="keyword">static</span> FinalExample obj;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalExample</span><span class="params">()</span> </span>&#123;             <span class="comment">// 构造函数</span></span><span class="line">        i = <span class="number">1</span>;                          <span class="comment">// 写普通域</span></span><span class="line">        j = <span class="number">2</span>;                          <span class="comment">// 写 final 域</span></span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;       <span class="comment">// 写线程 A 执行</span></span><span class="line">        obj = <span class="keyword">new</span> FinalExample();</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;        <span class="comment">// 读线程 B 执行</span></span><span class="line">        FinalExample object = obj;       <span class="comment">// 读对象引用</span></span><span class="line">        <span class="keyword">int</span> a = object.i;                <span class="comment">// 读普通域</span></span><span class="line">        <span class="keyword">int</span> b = object.j;                <span class="comment">// 读 final 域</span></span><span class="line">    &#125;</span><span class="line"></span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>这里假设一个线程 A 执行<code>writer()</code>方法，随后另一个线程 B 执行<code>reader()</code>方法。下面我们通过这两个线程的交互来说明这两个规则。</p>
<h3 id="写-final-域的重排序规则"><a href="#写-final-域的重排序规则" class="headerlink" title="写 final 域的重排序规则"></a>写 final 域的重排序规则</h3><p>写 final 域的重排序规则禁止把 final 域的写重排序到构造函数之外。这个规则的实现包含下面 2 个方面：</p>
<ol>
<li>JMM 禁止编译器把 final 域的写重排序到构造函数之外。</li>
<li>编译器会在 final 域的写之后，构造函数 return 之前，插入一个<code>StoreStore</code>屏障。这个屏障禁止处理器把 final 域的写重排序到构造函数之外。</li>
</ol>
<p>现在让我们分析<code>writer()</code>方法。<code>writer()</code>方法只包含一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">obj = <span class="keyword">new</span> FinalExample();</span></pre></td></tr></table></figure>
<p>这行代码包含两个步骤：</p>
<ol>
<li>构造一个 FinalExample 类型的对象；</li>
<li>把这个对象的引用赋值给引用变量 obj。</li>
</ol>
<p>假设线程 B 读对象引用与读对象的成员域之间没有重排序（马上会说明为什么需要这个假设），下图是一种可能的执行时序：</p>
<img src="/blog/img/java/jmm/jmm-61.jpg" class="image-md">
<p>在上图中，写普通域的操作被编译器重排序到了构造函数之外，读线程 B 错误的读取了普通变量 i 初始化之前的值。而写 final 域的操作，被写 final 域的重排序规则<strong>限定</strong>在了构造函数之内，读线程 B 正确的读取了 final 变量初始化之后的值。</p>
<p>写 final 域的重排序规则可以确保：</p>
<blockquote>
<p>在对象引用为任意线程可见之前，对象的 final 域已经被正确初始化过了，而普通域不具有这个保障。</p>
</blockquote>
<p>以上图为例，在读线程 B <strong>看到</strong>对象引用 obj 时，很可能 obj 对象还没有构造完成（对普通域 i 的写操作被重排序到构造函数外，此时初始值 2 还没有写入普通域 i）。</p>
<h3 id="读-final-域的重排序规则"><a href="#读-final-域的重排序规则" class="headerlink" title="读 final 域的重排序规则"></a>读 final 域的重排序规则</h3><p>读 final 域的重排序规则如下：</p>
<ol>
<li>在一个线程中，初次读对象引用与初次读该对象包含的 final 域，JMM 禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读 final 域操作的前面插入一个 LoadLoad 屏障。</li>
<li>初次读对象引用与初次读该对象包含的 final 域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，大多数处理器也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（比如 alpha 处理器），这个规则就是专门用来针对这种处理器。</li>
</ol>
<p><code>reader()</code>方法包含三个操作：</p>
<ol>
<li>初次读引用变量 obj;</li>
<li>初次读引用变量 obj 指向对象的普通域 j。</li>
<li>初次读引用变量 obj 指向对象的 final 域 i。</li>
</ol>
<p>现在我们假设写线程 A 没有发生任何重排序，同时程序在不遵守间接依赖的处理器上执行，下面是一种可能的执行时序：</p>
<img src="/blog/img/java/jmm/jmm-62.png" class="image-md">
<p>在上图中，读对象的普通域的操作被处理器重排序到读对象引用之前。读普通域时，该域还没有被写线程 A 写入，这是一个错误的读取操作。而读 final 域的重排序规则会把读对象 final 域的操作<strong>限定</strong>在读对象引用之后，此时该 final 域已经被 A 线程初始化过了，这是一个正确的读取操作。</p>
<p>读 final 域的重排序规则可以确保：</p>
<blockquote>
<p>在读一个对象的 final 域之前，一定会先读包含这个 final 域的对象的引用。</p>
</blockquote>
<p>在这个示例程序中，如果该引用不为 null，那么引用对象的 final 域一定已经被 A 线程初始化过了。</p>
<h3 id="如果-final-域是引用类型"><a href="#如果-final-域是引用类型" class="headerlink" title="如果 final 域是引用类型"></a>如果 final 域是引用类型</h3><p>上面我们看到的 final 域是基础数据类型，下面让我们看看如果 final 域是引用类型，将会有什么效果？</p>
<p>请看下列示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceExample</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] intArray;                  <span class="comment">// final 是引用类型</span></span><span class="line"></span><span class="line">    <span class="keyword">static</span> FinalReferenceExample obj;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceExample</span><span class="params">()</span> </span>&#123;       <span class="comment">// 构造函数</span></span><span class="line">        intArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];             <span class="comment">// 1</span></span><span class="line">        intArray[<span class="number">0</span>] = <span class="number">1</span>;                   <span class="comment">// 2</span></span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writerOne</span><span class="params">()</span> </span>&#123;       <span class="comment">// 写线程 A 执行</span></span><span class="line">        obj = <span class="keyword">new</span> FinalReferenceExample(); <span class="comment">// 3</span></span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writerTwo</span><span class="params">()</span> </span>&#123;       <span class="comment">// 写线程 B 执行</span></span><span class="line">        obj.intArray[<span class="number">0</span>] = <span class="number">2</span>;               <span class="comment">// 4</span></span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;          <span class="comment">// 读线程 C 执行</span></span><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;                 <span class="comment">// 5</span></span><span class="line">            <span class="keyword">int</span> temp1 = obj.intArray[<span class="number">0</span>];   <span class="comment">// 6</span></span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>这里 final 域为一个引用类型，它引用一个 int 型的数组对象。对于引用类型，写 final 域的重排序规则对编译器和处理器增加了如下约束：</p>
<ol>
<li>在构造函数内对一个 final 引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
</ol>
<p>对上面的示例程序，我们假设首先线程 A 执行<code>writerOne()</code>方法，执行完后线程 B 执行<code>writerTwo()</code>方法，执行完后线程 C 执行<code>reader()</code>方法。下面是一种可能的线程执行时序：</p>
<img src="/blog/img/java/jmm/jmm-63.png" class="image-md">
<p>在上图中，1 是对 final 域的写入，2 是对这个 final 域引用的对象的成员域的写入，3 是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的 1 不能和 3 重排序外，2 和 3 也不能重排序。</p>
<p>JMM 可以确保读线程 C 至少能看到写线程 A 在构造函数中对 final 引用对象的成员域的写入。即 C 至少能看到数组下标 0 的值为 1。而写线程 B 对数组元素的写入，读线程 C 可能看的到，也可能看不到。JMM 不保证线程 B 的写入对读线程 C 可见，因为写线程 B 和读线程 C 之间存在数据竞争，此时的执行结果不可预知。</p>
<p>如果想要确保读线程 C 看到写线程 B 对数组元素的写入，写线程 B 和读线程 C 之间需要使用<code>同步原语</code>（lock 或 volatile）来确保内存可见性。</p>
<h3 id="为什么-final-引用不能从构造函数内-quot-逸出-quot"><a href="#为什么-final-引用不能从构造函数内-quot-逸出-quot" class="headerlink" title="为什么 final 引用不能从构造函数内&quot;逸出&quot;"></a>为什么 final 引用不能从构造函数内&quot;逸出&quot;</h3><p>前面我们提到过，写 final 域的重排序规则可以确保：</p>
<blockquote>
<p>在引用变量为任意线程可见之前，该引用变量指向的对象的 final 域已经在构造函数中被正确初始化过了。</p>
</blockquote>
<p>其实要得到这个效果，还需要一个保证：</p>
<blockquote>
<p>在构造函数内部，不能让这个被构造对象的引用为其他线程可见，也就是对象引用不能在构造函数中<strong>逸出</strong>。</p>
</blockquote>
<p>为了说明问题，让我们来看下面示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceEscapeExample</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> i;</span><span class="line"></span><span class="line">    <span class="keyword">static</span> FinalReferenceEscapeExample obj;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceEscapeExample</span><span class="params">()</span> </span>&#123;</span><span class="line">        i = <span class="number">1</span>;                               <span class="comment">// 1 写 final 域</span></span><span class="line">        obj = <span class="keyword">this</span>;                          <span class="comment">// 2 this 引用在此逸出</span></span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><span class="line">        <span class="keyword">new</span> FinalReferenceEscapeExample();</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;                    <span class="comment">// 3</span></span><span class="line">            <span class="keyword">int</span> temp = obj.i;                 <span class="comment">// 4</span></span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>假设一个线程 A 执行<code>writer()</code>方法，另一个线程 B 执行<code>reader()</code>方法。这里的操作 2 使得对象还未完成构造前就为线程 B 可见。即使这里的操作 2 是构造函数的最后一步，且即使在程序中操作 2 排在操作 1 后面，执行<code>read()</code>方法的线程仍然可能无法看到 final 域被初始化后的值，因为这里的操作 1 和操作 2 之间可能被重排序。实际的执行时序可能如下图所示：</p>
<img src="/blog/img/java/jmm/jmm-64.png" class="image-md">
<p>从上图我们可以看出：</p>
<blockquote>
<p>在构造函数返回前，被构造对象的引用不能为其他线程可见，因为此时的 final 域可能还没有被初始化。在构造函数返回后，任意线程都将保证能看到 final 域正确初始化之后的值。</p>
</blockquote>
<h3 id="final-语义在处理器中的实现"><a href="#final-语义在处理器中的实现" class="headerlink" title="final 语义在处理器中的实现"></a>final 语义在处理器中的实现</h3><p>现在我们以 x86 处理器为例，说明 final 语义在处理器中的具体实现。</p>
<p>上面我们提到，写 final 域的重排序规则会要求译编器在 final 域的写之后，构造函数 return 之前，插入一个<code>StoreStore</code>障屏。读 final 域的重排序规则要求编译器在读 final 域的操作前面插入一个<code>LoadLoad</code>屏障。</p>
<p>由于 x86 处理器<strong>不会</strong>对<code>写-写</code>操作做重排序，所以在 x86 处理器中，写 final 域需要的<code>StoreStore</code>障屏会被省略掉。同样，由于 x86 处理器不会对存在间接依赖关系的操作做重排序，所以在 x86 处理器中，读 final 域需要的<code>LoadLoad</code>屏障也会被省略掉。</p>
<p>也就是说在<strong>x86 处理器</strong>中，final 域的<code>读/写</code><strong>不会插入任何内存屏障</strong>！</p>
<h3 id="JSR-133-为什么要增强-final-的语义"><a href="#JSR-133-为什么要增强-final-的语义" class="headerlink" title="JSR-133 为什么要增强 final 的语义"></a>JSR-133 为什么要增强 final 的语义</h3><p>在<strong>旧</strong>的 Java 内存模型中 ，最严重的一个缺陷就是线程可能看到 final 域的值会改变。比如，一个线程当前看到一个整形 final 域的值为 0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个 final 域的值时，却发现值变为了 1（被某个线程初始化之后的值）。最常见的例子就是在旧的 Java 内存模型中，String 的值可能会改变（参考文献 2 中有一个具体的例子，感兴趣的读者可以自行参考，这里就不赘述了）。</p>
<p>为了修补这个漏洞，<code>JSR-133</code>专家组增强了 final 的语义。通过为 final 域增加写和读重排序规则，可以为 java 程序员提供初始化安全保证：</p>
<blockquote>
<p>只要对象是正确构造的（被构造对象的引用在构造函数中没有<strong>逸出</strong>），那么不需要使用同步（指 lock 和 volatile 的使用），就可以保证任意线程都能看到这个 final 域在构造函数中被初始化之后的值。</p>
</blockquote>
<h3 id="参考文献-5"><a href="#参考文献-5" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li>Java Concurrency in Practice</li>
<li>JSR 133 (Java Memory Model) FAQ</li>
<li>Java Concurrency in Practice</li>
<li>The JSR-133 Cookbook for Compiler Writers</li>
<li>Intel® 64 and IA-32 ArchitecturesvSoftware Developer’s Manual Volume 3A: System Programming Guide, Part 1</li>
</ol>
<h2 id="深入理解-Java-内存模型七：总结"><a href="#深入理解-Java-内存模型七：总结" class="headerlink" title="深入理解 Java 内存模型七：总结"></a>深入理解 Java 内存模型七：总结</h2><h3 id="处理器内存模型"><a href="#处理器内存模型" class="headerlink" title="处理器内存模型"></a>处理器内存模型</h3><p>顺序一致性内存模型是一个理论参考模型，JMM 和处理器内存模型在设计时通常会把顺序一致性内存模型作为参照。JMM 和处理器内存模型在设计时会对顺序一致性模型做一些放松，因为如果完全按照顺序一致性模型来实现处理器和 JMM，那么很多的处理器和编译器优化都要被禁止，这对执行性能将会有很大的影响。</p>
<p>根据对不同类型<code>读/写</code>操作组合的执行顺序的放松，可以把常见处理器的内存模型划分为下面几种类型：</p>
<ol>
<li>放松程序中<code>写-读</code>操作的顺序，由此产生了 total store ordering 内存模型（简称为 TSO）。</li>
<li>在前面 1 的基础上，继续放松程序中<code>写-写</code>操作的顺序，由此产生了 partial store order 内存模型（简称为 PSO）。</li>
<li>在前面 1 和 2 的基础上，继续放松程序中<code>读-写</code>和<code>读-读</code>操作的顺序，由此产生了 relaxed memory order 内存模型（简称为 RMO）和 PowerPC 内存模型。</li>
</ol>
<p>注意，这里处理器对<code>读-写</code>操作的放松，是以两个操作之间不存在数据依赖性为前提的（因为处理器要遵守<code>as-if-serial</code>语义，处理器不会对存在数据依赖性的两个内存操作做重排序）。</p>
<p>下面的表格展示了常见处理器内存模型的细节特征：</p>
<table>
<thead>
<tr>
<th style="text-align:left">内存模型名称</th>
<th style="text-align:left">对应的处理器</th>
<th style="text-align:left">Store-Load 重排序</th>
<th style="text-align:left">Store-Store 重排序</th>
<th style="text-align:left">Load-Load 和 Load-Store 重排序</th>
<th style="text-align:left">可以更早读取到其它处理器的写</th>
<th style="text-align:left">可以更早读取到当前处理器的写</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">TSO</td>
<td style="text-align:left">sparc-TSO / X64</td>
<td style="text-align:left">Y</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">Y</td>
</tr>
<tr>
<td style="text-align:left">PSO</td>
<td style="text-align:left">sparc-PSO</td>
<td style="text-align:left">Y</td>
<td style="text-align:left">Y</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">Y</td>
</tr>
<tr>
<td style="text-align:left">RMO</td>
<td style="text-align:left">ia64</td>
<td style="text-align:left">Y</td>
<td style="text-align:left">Y</td>
<td style="text-align:left">Y</td>
<td style="text-align:left"></td>
<td style="text-align:left">Y</td>
</tr>
<tr>
<td style="text-align:left">PowerPC</td>
<td style="text-align:left">PowerPC</td>
<td style="text-align:left">Y</td>
<td style="text-align:left">Y</td>
<td style="text-align:left">Y</td>
<td style="text-align:left">Y</td>
<td style="text-align:left">Y</td>
</tr>
</tbody>
</table>
<p>在这个表格中，我们可以看到所有处理器内存模型都允许<code>写-读</code>重排序，原因在第一章以说明过：</p>
<blockquote>
<p>它们都使用了写缓存区，写缓存区可能导致<code>写-读</code>操作重排序。</p>
</blockquote>
<p>同时，我们可以看到这些处理器内存模型都允许更早读到当前处理器的写，原因同样是因为写缓存区：</p>
<blockquote>
<p>由于写缓存区仅对当前处理器可见，这个特性导致当前处理器可以比其他处理器先看到临时保存在自己的写缓存区中的写。</p>
</blockquote>
<p>上面表格中的各种处理器内存模型，从上到下，模型由强变弱。越是追求性能的处理器，内存模型设计的会越弱。因为这些处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。</p>
<p>由于常见的处理器内存模型比 JMM 要弱，java 编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时，由于各种处理器内存模型的强弱并不相同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM 在不同的处理器中需要插入的内存屏障的数量和种类也不相同。下图展示了 JMM 在不同处理器内存模型中需要插入的内存屏障的示意图：</p>
<img src="/blog/img/java/jmm/jmm-71.png" class="image-md">
<p>如上图所示，JMM 屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为 java 程序员呈现了一个一致的内存模型。</p>
<h3 id="JMM，处理器内存模型与顺序一致性内存模型之间的关系"><a href="#JMM，处理器内存模型与顺序一致性内存模型之间的关系" class="headerlink" title="JMM，处理器内存模型与顺序一致性内存模型之间的关系"></a>JMM，处理器内存模型与顺序一致性内存模型之间的关系</h3><p>JMM 是一个语言级的内存模型，处理器内存模型是硬件级的内存模型，顺序一致性内存模型是一个理论参考模型。下面是语言内存模型，处理器内存模型和顺序一致性内存模型的强弱对比示意图：</p>
<img src="/blog/img/java/jmm/jmm-72.png" class="image-md">
<p>从上图我们可以看出：</p>
<blockquote>
<p>常见的 4 种处理器内存模型比常用的 3 中语言内存模型要弱，处理器内存模型和语言内存模型都比顺序一致性内存模型要弱。</p>
</blockquote>
<p>同处理器内存模型一样，越是追求执行性能的语言，内存模型设计的会越弱。</p>
<h3 id="JMM-的设计"><a href="#JMM-的设计" class="headerlink" title="JMM 的设计"></a>JMM 的设计</h3><p>从 JMM 设计者的角度来说，在设计 JMM 时，需要考虑两个关键因素：</p>
<ol>
<li>程序员对内存模型的使用。程序员希望内存模型易于理解，易于编程。程序员希望基于一个强内存模型来编写代码。</li>
<li>编译器和处理器对内存模型的实现。编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现一个弱内存模型。</li>
</ol>
<p>由于这两个因素互相矛盾，所以<code>JSR-133</code>专家组在设计 JMM 时的核心目标就是找到一个好的平衡点：</p>
<blockquote>
<p>一方面要为程序员提供足够强的内存可见性保证；<br>另一方面，对编译器和处理器的限制要尽可能的放松。</p>
</blockquote>
<p>下面让我们看看<code>JSR-133</code>是如何实现这一目标的。</p>
<p>为了具体说明，请看前面提到过的计算圆面积的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> pi  = <span class="number">3.14</span>;    <span class="comment">// A</span></span><span class="line"><span class="keyword">double</span> r   = <span class="number">1.0</span>;     <span class="comment">// B</span></span><span class="line"><span class="keyword">double</span> area = pi * r * r; <span class="comment">// C</span></span></pre></td></tr></table></figure>
<p>上面计算圆的面积的示例代码存在三个<code>happens-before</code>关系：</p>
<ol>
<li>A <code>happens-before</code> B；</li>
<li>B <code>happens-before</code> C；</li>
<li>A <code>happens-before</code> C；</li>
</ol>
<p>由于 A <code>happens-before</code> B，<code>happens-before</code>的定义会要求：</p>
<blockquote>
<p>A 操作执行的结果要对 B 可见，且 A 操作的执行顺序排在 B 操作之前。</p>
</blockquote>
<p>但是从程序语义的角度来说，对 A 和 B 做重排序即不会改变程序的执行结果，也还能提高程序的执行性能（允许这种重排序减少了对编译器和处理器优化的束缚）。也就是说，上面这 3 个<code>happens-before</code>关系中，虽然 2 和 3 是必需要的，但 1 是不必要的。</p>
<p>因此，JMM 把<code>happens-before</code>要求禁止的重排序分为了下面两类：</p>
<ol>
<li>会改变程序执行结果的重排序。</li>
<li>不会改变程序执行结果的重排序。</li>
</ol>
<p>JMM 对这两种不同性质的重排序，采取了不同的策略：</p>
<ol>
<li>对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序。</li>
<li>对于不会改变程序执行结果的重排序，JMM 对编译器和处理器不作要求（JMM 允许这种重排序）。</li>
</ol>
<p>下面是 JMM 的设计示意图：</p>
<img src="/blog/img/java/jmm/jmm-73.png" class="image-md">
<p>从上图可以看出两点：</p>
<ol>
<li>JMM 向程序员提供的<code>happens-before</code>规则能满足程序员的需求。JMM 的<code>happens-before</code>规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证（有些内存可见性保证其实并不一定真实存在，比如上面的 A <code>happens-before</code> B）。</li>
<li>JMM 对编译器和处理器的束缚已经尽可能的少。从上面的分析我们可以看出，JMM 其实是在遵循一个基本原则：</li>
</ol>
<blockquote>
<p>只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。</p>
</blockquote>
<p>比如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再比如，如果编译器经过细致的分析后，认定一个 volatile 变量仅仅只会被单个线程访问，那么编译器可以把这个 volatile 变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。</p>
<h3 id="JMM-的内存可见性保证"><a href="#JMM-的内存可见性保证" class="headerlink" title="JMM 的内存可见性保证"></a>JMM 的内存可见性保证</h3><p>Java 程序的内存可见性保证按程序类型可以分为下列三类：</p>
<ol>
<li>单线程程序。单线程程序不会出现内存可见性问题。编译器，runtime 和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</li>
<li>正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是 JMM 关注的重点，JMM 通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</li>
<li>未同步/未正确同步的多线程程序。JMM 为它们提供了最小安全性保障，即线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。</li>
</ol>
<p>下图展示了这三类程序在 JMM 中与在顺序一致性内存模型中的执行结果的异同：</p>
<img src="/blog/img/java/jmm/jmm-74.png" class="image-md">
<p>只要多线程程序是正确同步的，JMM 保证该程序在任意的处理器平台上的执行结果，与该程序在顺序一致性内存模型中的执行结果一致。</p>
<h3 id="JSR-133-对旧内存模型的修补"><a href="#JSR-133-对旧内存模型的修补" class="headerlink" title="JSR-133 对旧内存模型的修补"></a>JSR-133 对旧内存模型的修补</h3><p><code>JSR-133</code>对 JDK5 之前的旧内存模型的修补主要有两个：</p>
<ol>
<li>增强 volatile 的内存语义。旧内存模型允许 volatile 变量与普通变量重排序。<code>JSR-133</code>严格限制 volatile 变量与普通变量的重排序，使 volatile 的<code>写-读</code>和锁的<strong>释放/获取</strong>具有相同的内存语义。</li>
<li>增强 final 的内存语义。在旧内存模型中，多次读取同一个 final 变量的值可能会不相同。为此，<code>JSR-133</code>为 final 增加了两个重排序规则。现在，final 具有了初始化安全性。</li>
</ol>
<h3 id="参考文献-6"><a href="#参考文献-6" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li>Computer Architecture: A Quantitative Approach, 4th Edition</li>
<li>Shared memory consistency models: A tutorial</li>
<li>Intel® Itanium® Architecture Software Developer’s Manual Volume 2: System Architecture</li>
<li>Concurrent Programming on Windows</li>
<li>JSR 133 (Java Memory Model) FAQ</li>
<li>The JSR-133 Cookbook for Compiler Writers</li>
<li>Java theory and practice: Fixing the Java Memory Model, Part 2</li>
</ol>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p>程晓明，Java 软件工程师，国家认证的系统分析师、信息项目管理师。专注于并发编程，就职于富士通南大。</p>
<h2 id="原文-PDF-下载"><a href="#原文-PDF-下载" class="headerlink" title="原文 PDF 下载"></a>原文 PDF 下载</h2><p>此文作者除了讲解 JMM 规则，并精心制作了示例代码和配图，对于深入理解 JMM 帮助很大，转载原文用以参考学习，另外作者提供的 PDF 下载地址：</p>
<ul>
<li><a href="https://files.cnblogs.com/files/skywang12345/%E6%B7%B1%E5%85%A5Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.pdf" target="_blank" rel="noopener">深入 Java 内存模型.pdf</a></li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a href="http://www.infoq.com/cn/articles/java-memory-model-1" target="_blank" rel="noopener">深入理解 Java 内存模型一：基础</a></li>
<li><a href="http://www.infoq.com/cn/articles/java-memory-model-2" target="_blank" rel="noopener">深入理解 Java 内存模型二：重排序</a></li>
<li><a href="http://www.infoq.com/cn/articles/java-memory-model-3" target="_blank" rel="noopener">深入理解 Java 内存模型三：顺序一致性</a></li>
<li><a href="http://www.infoq.com/cn/articles/java-memory-model-4" target="_blank" rel="noopener">深入理解 Java 内存模型四：volatile</a></li>
<li><a href="http://www.infoq.com/cn/articles/java-memory-model-5" target="_blank" rel="noopener">深入理解 Java 内存模型五：锁</a></li>
<li><a href="http://www.infoq.com/cn/articles/java-memory-model-6" target="_blank" rel="noopener">深入理解 Java 内存模型六：final</a></li>
<li><a href="http://www.infoq.com/cn/articles/java-memory-model-7" target="_blank" rel="noopener">深入理解 Java 内存模型七：总结</a></li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E6%8C%87%E4%BB%A4%E7%AE%A1%E7%B7%9A%E5%8C%96" target="_blank" rel="noopener">指令流水线</a></li>
<li><a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html" target="_blank" rel="noopener">The JSR-133 Cookbook for Compiler Writers</a></li>
<li><a href="https://booksite.elsevier.com/9780123973375/" target="_blank" rel="noopener">The Art of Multiprocessor Programming</a></li>
<li><a href="http://www.cs.virginia.edu/~evans/cs216/guides/x86.html" target="_blank" rel="noopener">x86 Assembly Guide</a></li>
<li><a href="https://shipilev.net/blog/2014/jmm-pragmatics/" target="_blank" rel="noopener">Java Memory Model Pragmatics</a></li>
<li><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf" target="_blank" rel="noopener">JSR-133: Java Memory Model and Thread Specification</a></li>
<li><a href="http://www.wowotech.net/kernel_synchronization/Why-Memory-Barriers.html" target="_blank" rel="noopener">Why Memory Barriers</a></li>
<li><a href="https://www.hpl.hp.com/techreports/Compaq-DEC/WRL-95-7.pdf" target="_blank" rel="noopener">Shared Memory Consistency Models: A Tutorial</a></li>
<li><a href="https://stackoverflow.com/questions/8891067/what-does-the-lock-instruction-mean-in-x86-assembly" target="_blank" rel="noopener">What does the “lock” instruction mean in x86 assembly</a></li>
<li><a href="https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf" target="_blank" rel="noopener">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a></li>
<li><a href="http://www.scs.stanford.edu/05au-cs240c/lab/reference.html" target="_blank" rel="noopener">Advanced OS Implementation Reference Materials</a></li>
<li><a href="http://www.scs.stanford.edu/05au-cs240c/lab/ia32/IA32-2A.pdf" target="_blank" rel="noopener">http://www.scs.stanford.edu/05au-cs240c/lab/ia32/IA32-2A.pdf</a></li>
<li><a href="http://www.scs.stanford.edu/05au-cs240c/lab/pcasm-book.pdf" target="_blank" rel="noopener">http://www.scs.stanford.edu/05au-cs240c/lab/pcasm-book.pdf</a></li>
<li><a href="https://www.felixcloutier.com/x86/" target="_blank" rel="noopener">x86 and amd64 instruction reference</a></li>
<li><a href="http://openjdk.java.net/jeps/188" target="_blank" rel="noopener">JEP 188: Java Memory Model Update</a></li>
<li><a href="https://www.ibm.com/developerworks/java/library/j-jtp03304/index.html" target="_blank" rel="noopener">Fixing the Java Memory Model</a></li>
<li><a href="https://cvw.cac.cornell.edu/codeopt/memhier" target="_blank" rel="noopener">Code Optimization: Memory Hierarchy</a></li>
<li><a href="https://www.anandtech.com/show/2183/9" target="_blank" rel="noopener">Getting Spendy with Transistors - L3 cache</a></li>
<li><a href="http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf" target="_blank" rel="noopener">Memory Barriers: a Hardware View for Software Hackers</a></li>
<li><a href="https://gvsmirnov.ru/blog/tech/2014/02/10/jmm-under-the-hood.html" target="_blank" rel="noopener">Java Memory Model Under The Hood</a></li>
<li><a href="https://www.gamedev.net/articles/programming/general-and-gameplay-programming/a-journey-through-the-cpu-pipeline-r3115#" target="_blank" rel="noopener">A Journey Through the CPU Pipeline</a></li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/java/2018/08/05/hotspot-source-code-memory-types-and-generation-gc.html" rel="next" title="hotspot source code - memory types and generation gc">
                <i class="fa fa-chevron-left"></i>
                hotspot source code - memory types and generation gc
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/web/2018/10/21/the-best-chrome-extension-tampermonkey.html" rel="prev" title="chrome 插件之 tampermonkey">
                <i class="fa fa-chevron-right"></i>
                chrome 插件之 tampermonkey
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/blog/images/avatar.jpg" alt="yuweijun">
          <p class="site-author-name" itemprop="name">yuweijun</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/blog/archives">
              <span class="site-state-item-count">492</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">categories</span>
              
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/blog/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yuweijun" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/yuweijun" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#深入理解-Java-内存模型一：基础"><span class="nav-number">1.</span> <span class="nav-text">深入理解 Java 内存模型一：基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#并发编程模型的分类"><span class="nav-number">1.1.</span> <span class="nav-text">并发编程模型的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-内存模型的抽象"><span class="nav-number">1.2.</span> <span class="nav-text">Java 内存模型的抽象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重排序"><span class="nav-number">1.3.</span> <span class="nav-text">重排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#处理器重排序与内存屏障指令"><span class="nav-number">1.3.1.</span> <span class="nav-text">处理器重排序与内存屏障指令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#happens-before"><span class="nav-number">1.4.</span> <span class="nav-text">happens-before</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考文献"><span class="nav-number">1.5.</span> <span class="nav-text">参考文献</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入理解-Java-内存模型二：重排序"><span class="nav-number">2.</span> <span class="nav-text">深入理解 Java 内存模型二：重排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据依赖性"><span class="nav-number">2.1.</span> <span class="nav-text">数据依赖性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#as-if-serial-语义"><span class="nav-number">2.2.</span> <span class="nav-text">as-if-serial 语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序顺序规则"><span class="nav-number">2.3.</span> <span class="nav-text">程序顺序规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重排序对多线程的影响"><span class="nav-number">2.4.</span> <span class="nav-text">重排序对多线程的影响</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Out-Of-Order-Execution-Core"><span class="nav-number">2.4.1.</span> <span class="nav-text">Out-Of-Order Execution Core</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Retirement-Unit"><span class="nav-number">2.4.2.</span> <span class="nav-text">Retirement Unit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU-乱序执行示例"><span class="nav-number">2.4.3.</span> <span class="nav-text">CPU 乱序执行示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JCStress-并发压力测试"><span class="nav-number">2.4.4.</span> <span class="nav-text">JCStress 并发压力测试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考文献-1"><span class="nav-number">2.5.</span> <span class="nav-text">参考文献</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入理解-Java-内存模型三：顺序一致性"><span class="nav-number">3.</span> <span class="nav-text">深入理解 Java 内存模型三：顺序一致性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据竞争与顺序一致性保证"><span class="nav-number">3.1.</span> <span class="nav-text">数据竞争与顺序一致性保证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序一致性内存模型"><span class="nav-number">3.2.</span> <span class="nav-text">顺序一致性内存模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步程序的顺序一致性效果"><span class="nav-number">3.3.</span> <span class="nav-text">同步程序的顺序一致性效果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#未同步程序的执行特性"><span class="nav-number">3.4.</span> <span class="nav-text">未同步程序的执行特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无缓存处理器指令重排序对程序的影响示例图"><span class="nav-number">3.5.</span> <span class="nav-text">无缓存处理器指令重排序对程序的影响示例图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考文献-2"><span class="nav-number">3.6.</span> <span class="nav-text">参考文献</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入理解-Java-内存模型四：volatile"><span class="nav-number">4.</span> <span class="nav-text">深入理解 Java 内存模型四：volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile-的特性"><span class="nav-number">4.1.</span> <span class="nav-text">volatile 的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile-写-读-建立的-happens-before-关系"><span class="nav-number">4.2.</span> <span class="nav-text">volatile 写-读 建立的 happens-before 关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile-写-读-的内存语义"><span class="nav-number">4.3.</span> <span class="nav-text">volatile 写-读 的内存语义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#普通共享变量并行读的测试代码"><span class="nav-number">4.3.1.</span> <span class="nav-text">普通共享变量并行读的测试代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile-共享变量写操作并行读示例"><span class="nav-number">4.3.2.</span> <span class="nav-text">volatile 共享变量写操作并行读示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#普通读和-volatile-读并行示例"><span class="nav-number">4.3.3.</span> <span class="nav-text">普通读和 volatile 读并行示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile-读写内存语义总绕结"><span class="nav-number">4.3.4.</span> <span class="nav-text">volatile 读写内存语义总绕结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile-内存语义的实现"><span class="nav-number">4.4.</span> <span class="nav-text">volatile 内存语义的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile-禁止重排序测试"><span class="nav-number">4.4.1.</span> <span class="nav-text">volatile 禁止重排序测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile-重排序测试"><span class="nav-number">4.4.2.</span> <span class="nav-text">volatile 重排序测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存屏障插入位置与-java-代码对比示例"><span class="nav-number">4.4.3.</span> <span class="nav-text">内存屏障插入位置与 java 代码对比示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x86-架构的内存屏障"><span class="nav-number">4.5.</span> <span class="nav-text">x86 架构的内存屏障</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Store-Barrier"><span class="nav-number">4.5.1.</span> <span class="nav-text">Store Barrier</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Load-Barrier"><span class="nav-number">4.5.2.</span> <span class="nav-text">Load Barrier</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Full-Barrier"><span class="nav-number">4.5.3.</span> <span class="nav-text">Full Barrier</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SSE2-Cacheability-Control-and-Ordering-Instructions"><span class="nav-number">4.5.4.</span> <span class="nav-text">SSE2 Cacheability Control and Ordering Instructions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LFENCE-Load-Fence"><span class="nav-number">4.5.5.</span> <span class="nav-text">LFENCE - Load Fence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MFENCE-Memory-Fence"><span class="nav-number">4.5.6.</span> <span class="nav-text">MFENCE - Memory Fence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Memory-Ordering-Instructions"><span class="nav-number">4.5.7.</span> <span class="nav-text">Memory Ordering Instructions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#x86-架构下-Hotspot-对-volatile-变量的处理"><span class="nav-number">4.5.8.</span> <span class="nav-text">x86 架构下 Hotspot 对 volatile 变量的处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于-Memory-Caches-MESI-说明-The-Art-of-Multiprocessor-Programming"><span class="nav-number">4.6.</span> <span class="nav-text">关于 Memory/Caches/MESI 说明 (The Art of Multiprocessor Programming)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Memory-和-Cache-的读写速度比较"><span class="nav-number">4.6.1.</span> <span class="nav-text">Memory 和 Cache 的读写速度比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Memory"><span class="nav-number">4.6.2.</span> <span class="nav-text">Memory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Caches"><span class="nav-number">4.6.3.</span> <span class="nav-text">Caches</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Coherence"><span class="nav-number">4.6.4.</span> <span class="nav-text">Coherence</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spinning"><span class="nav-number">4.6.5.</span> <span class="nav-text">Spinning</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Relaxed-Memory-Consistency"><span class="nav-number">4.6.6.</span> <span class="nav-text">Relaxed Memory Consistency</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#x86-架构与内存屏障"><span class="nav-number">4.6.7.</span> <span class="nav-text">x86 架构与内存屏障</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Interconnect"><span class="nav-number">4.6.8.</span> <span class="nav-text">Interconnect</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Store-Buffer"><span class="nav-number">4.6.9.</span> <span class="nav-text">Store Buffer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU-Intel-i7-Shared-L3-Cache"><span class="nav-number">4.6.10.</span> <span class="nav-text">CPU Intel i7 Shared L3 Cache</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于为何禁止重排序的说明"><span class="nav-number">4.7.</span> <span class="nav-text">关于为何禁止重排序的说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#普通读和-volatile-写重排序说明"><span class="nav-number">4.7.1.</span> <span class="nav-text">普通读和 volatile 写重排序说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile-读和普通写重排序说明"><span class="nav-number">4.7.2.</span> <span class="nav-text">volatile 读和普通写重排序说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile-读和普通读重排序说明"><span class="nav-number">4.7.3.</span> <span class="nav-text">volatile 读和普通读重排序说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSR-133-为什么要增强-volatile-的内存语义"><span class="nav-number">4.8.</span> <span class="nav-text">JSR-133 为什么要增强 volatile 的内存语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-XX-PrintAssembly-查看-volatile-底层实现"><span class="nav-number">4.9.</span> <span class="nav-text">java -XX:+PrintAssembly 查看 volatile 底层实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#System-out-println-源码"><span class="nav-number">4.9.1.</span> <span class="nav-text">System.out.println 源码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JITWatch-截屏"><span class="nav-number">4.9.2.</span> <span class="nav-text">JITWatch 截屏</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考文献-3"><span class="nav-number">4.10.</span> <span class="nav-text">参考文献</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入理解-Java-内存模型五：锁"><span class="nav-number">5.</span> <span class="nav-text">深入理解 Java 内存模型五：锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#锁的释放-获取建立的-happens-before-关系"><span class="nav-number">5.1.</span> <span class="nav-text">锁的释放/获取建立的 happens-before 关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁释放和获取的内存语义"><span class="nav-number">5.2.</span> <span class="nav-text">锁释放和获取的内存语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁内存语义的实现"><span class="nav-number">5.3.</span> <span class="nav-text">锁内存语义的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS-具有-volatile-读写内存语义示例代码"><span class="nav-number">5.3.1.</span> <span class="nav-text">CAS 具有 volatile 读写内存语义示例代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS-实现说明"><span class="nav-number">5.4.</span> <span class="nav-text">CAS 实现说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stackoverflow-上对于-LOCK-前缀的解释"><span class="nav-number">5.5.</span> <span class="nav-text">stackoverflow 上对于 LOCK 前缀的解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IA-32-Intel®-Architecture-Software-Developer’s-Manual"><span class="nav-number">5.6.</span> <span class="nav-text">IA-32 Intel® Architecture Software Developer’s Manual</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LOCK—Assert-LOCK-Signal-Prefix"><span class="nav-number">5.7.</span> <span class="nav-text">LOCK—Assert LOCK# Signal Prefix</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Description"><span class="nav-number">5.7.1.</span> <span class="nav-text">Description</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#公平锁和非公平锁"><span class="nav-number">5.8.</span> <span class="nav-text">公平锁和非公平锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#concurrent-包的实现"><span class="nav-number">5.9.</span> <span class="nav-text">concurrent 包的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考文献-4"><span class="nav-number">5.10.</span> <span class="nav-text">参考文献</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入理解-Java-内存模型六：final"><span class="nav-number">6.</span> <span class="nav-text">深入理解 Java 内存模型六：final</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#写-final-域的重排序规则"><span class="nav-number">6.1.</span> <span class="nav-text">写 final 域的重排序规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读-final-域的重排序规则"><span class="nav-number">6.2.</span> <span class="nav-text">读 final 域的重排序规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如果-final-域是引用类型"><span class="nav-number">6.3.</span> <span class="nav-text">如果 final 域是引用类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么-final-引用不能从构造函数内-quot-逸出-quot"><span class="nav-number">6.4.</span> <span class="nav-text">为什么 final 引用不能从构造函数内&quot;逸出&quot;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final-语义在处理器中的实现"><span class="nav-number">6.5.</span> <span class="nav-text">final 语义在处理器中的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSR-133-为什么要增强-final-的语义"><span class="nav-number">6.6.</span> <span class="nav-text">JSR-133 为什么要增强 final 的语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考文献-5"><span class="nav-number">6.7.</span> <span class="nav-text">参考文献</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入理解-Java-内存模型七：总结"><span class="nav-number">7.</span> <span class="nav-text">深入理解 Java 内存模型七：总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#处理器内存模型"><span class="nav-number">7.1.</span> <span class="nav-text">处理器内存模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JMM，处理器内存模型与顺序一致性内存模型之间的关系"><span class="nav-number">7.2.</span> <span class="nav-text">JMM，处理器内存模型与顺序一致性内存模型之间的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JMM-的设计"><span class="nav-number">7.3.</span> <span class="nav-text">JMM 的设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JMM-的内存可见性保证"><span class="nav-number">7.4.</span> <span class="nav-text">JMM 的内存可见性保证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSR-133-对旧内存模型的修补"><span class="nav-number">7.5.</span> <span class="nav-text">JSR-133 对旧内存模型的修补</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考文献-6"><span class="nav-number">7.6.</span> <span class="nav-text">参考文献</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于作者"><span class="nav-number">8.</span> <span class="nav-text">关于作者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原文-PDF-下载"><span class="nav-number">9.</span> <span class="nav-text">原文 PDF 下载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#References"><span class="nav-number">10.</span> <span class="nav-text">References</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-github"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yuweijun</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist.KISS
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>











  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.0.0/jquery.min.js"></script>

  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>

  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>

  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.3.1/velocity.min.js"></script>

  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.3.1/velocity.ui.min.js"></script>


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/blog/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/blog/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
