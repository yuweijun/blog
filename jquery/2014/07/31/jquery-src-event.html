<!doctype html>




<html class="theme-next mist">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">


















  

<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">






  <link rel="alternate" href="/blog/atom.xml" title="一" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/blog/favicon.ico?v=5.0.1">






<meta name="description" content="下面是Dean Edwards关于javascript事件机制处理的源码">
<meta property="og:type" content="article">
<meta property="og:title" content="jquery-1.4.2 event部分源码分析">
<meta property="og:url" content="http://www.4e00.com/jquery/2014/07/31/jquery-src-event.html">
<meta property="og:site_name" content="一">
<meta property="og:description" content="下面是Dean Edwards关于javascript事件机制处理的源码">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://www.w3.org/TR/2011/WD-DOM-Level-3-Events-20110531/images/eventflow.png">
<meta property="og:updated_time" content="2020-03-06T01:24:26.094Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jquery-1.4.2 event部分源码分析">
<meta name="twitter:description" content="下面是Dean Edwards关于javascript事件机制处理的源码">
<meta name="twitter:image" content="http://www.w3.org/TR/2011/WD-DOM-Level-3-Events-20110531/images/eventflow.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide"},
    fancybox: false,
    motion: false,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://www.4e00.com/blog/jquery/2014/07/31/jquery-src-event.html">

  <title> jquery-1.4.2 event部分源码分析 | 一 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/blog/" class="brand" rel="start">
      <span class="site-title">一</span>
    </a>
  </div>
  <p class="site-subtitle">{"type":"编程笔记"}</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      <li class="menu-item menu-item-search">
        <a href="https://www.google.com.hk/search?q=site%3Ahttp://www.4e00.com/blog/" class="popup-trigger">
          <i class="menu-item-icon fa fa-search fa-fw"></i>Search
        </a>
      </li>
    </ul>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                jquery-1.4.2 event部分源码分析
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2014-07-31T21:50:36+08:00" content="2014-07-31">
              2014-07-31
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="//schema.org/Thing">
                  <a href="/blog/categories/jquery/" itemprop="url" rel="index">
                    <span itemprop="name">jquery</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>下面是Dean Edwards关于javascript事件机制处理的<a href="http://dean.edwards.name/weblog/2005/10/add-event/" target="_blank" rel="noopener">源码</a></p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// written by Dean Edwards, 2005</span></span><span class="line"><span class="comment">// with input from Tino Zijdel, Matthias Miller, Diego Perini</span></span><span class="line"></span><span class="line"><span class="comment">// http://dean.edwards.name/weblog/2005/10/add-event/</span></span><span class="line"></span><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><span class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</span><span class="line">        element.addEventListener(type, handler, <span class="literal">false</span>); <span class="comment">// copy handler function.</span></span><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><span class="line">        <span class="comment">// assign each event handler a unique ID</span></span><span class="line">        <span class="keyword">if</span> (!handler.$$guid) handler.$$guid = addEvent.guid++;</span><span class="line">        <span class="comment">// create a hash table of event types for the element</span></span><span class="line">        <span class="keyword">if</span> (!element.events) element.events = &#123;&#125;;</span><span class="line">        <span class="comment">// create a hash table of event handlers for each element/event pair</span></span><span class="line">        <span class="keyword">var</span> handlers = element.events[type];</span><span class="line">        <span class="keyword">if</span> (!handlers) &#123;</span><span class="line">            handlers = element.events[type] = &#123;&#125;;</span><span class="line">            <span class="comment">// store the existing event handler (if there is one, else this value is 'undefined')</span></span><span class="line">            <span class="keyword">if</span> (element[<span class="string">"on"</span> + type]) &#123;</span><span class="line">                <span class="comment">// alert('exist on' + type + ' handler! copy existing event handler to handlers[0]');</span></span><span class="line">                handlers[<span class="number">0</span>] = element[<span class="string">"on"</span> + type];</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line">        <span class="comment">// store the event handler in the hash table</span></span><span class="line">        handlers[handler.$$guid] = handler;</span><span class="line">        <span class="comment">// assign a global event handler to do all the work</span></span><span class="line">        element[<span class="string">"on"</span> + type] = handleEvent;</span><span class="line">    &#125;</span><span class="line">&#125;;</span><span class="line"><span class="comment">// a counter used to create unique IDs, Static variable: addEvent.guid</span></span><span class="line">addEvent.guid = <span class="number">1</span>;</span><span class="line"></span><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeEvent</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><span class="line">    <span class="keyword">if</span> (element.removeEventListener) &#123;</span><span class="line">        element.removeEventListener(type, handler, <span class="literal">false</span>);</span><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><span class="line">        <span class="comment">// delete the event handler from the hash table</span></span><span class="line">        <span class="keyword">if</span> (element.events &amp;&amp; element.events[type]) &#123;</span><span class="line">            <span class="keyword">delete</span> element.events[type][handler.$$guid];</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">&#125;;</span><span class="line"></span><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span>(<span class="params">event</span>) </span>&#123;</span><span class="line">    <span class="keyword">var</span> returnValue = <span class="literal">true</span>;</span><span class="line">    <span class="comment">// grab the event object (IE uses a global event object)</span></span><span class="line">    event = event || fixEvent(((<span class="keyword">this</span>.ownerDocument || <span class="keyword">this</span>.document || <span class="keyword">this</span>).parentWindow || <span class="built_in">window</span>).event);</span><span class="line">    <span class="comment">// get a reference to the hash table of event handlers</span></span><span class="line">    <span class="keyword">var</span> handlers = <span class="keyword">this</span>.events[event.type];</span><span class="line">    <span class="comment">// execute each event handler</span></span><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> handlers) &#123;</span><span class="line">        <span class="keyword">this</span>.$$handleEvent = handlers[i];</span><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.$$handleEvent(event) === <span class="literal">false</span>) &#123;</span><span class="line">            returnValue = <span class="literal">false</span>;</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">    <span class="keyword">return</span> returnValue;</span><span class="line">&#125;;</span><span class="line"></span><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fixEvent</span>(<span class="params">event</span>) </span>&#123;</span><span class="line">    <span class="comment">// add W3C standard event methods, IE has not those methods</span></span><span class="line">    event.preventDefault = fixEvent.preventDefault;</span><span class="line">    event.stopPropagation = fixEvent.stopPropagation;</span><span class="line">    <span class="keyword">return</span> event;</span><span class="line">&#125;;</span><span class="line">fixEvent.preventDefault = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><span class="line">    <span class="keyword">this</span>.returnValue = <span class="literal">false</span>;</span><span class="line">&#125;;</span><span class="line">fixEvent.stopPropagation = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><span class="line">    <span class="keyword">this</span>.cancelBubble = <span class="literal">true</span>;</span><span class="line">&#125;;</span><span class="line"></span><span class="line"><span class="comment">// This little snippet fixes the problem that the onload attribute on the body-element will overwrite</span></span><span class="line"><span class="comment">// previous attached events on the window object for the onload event</span></span><span class="line"><span class="keyword">if</span> (!<span class="built_in">window</span>.addEventListener) &#123;</span><span class="line">    <span class="built_in">document</span>.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><span class="line">        <span class="keyword">if</span> (<span class="built_in">window</span>.onload &amp;&amp; <span class="built_in">window</span>.onload != handleEvent) &#123;</span><span class="line">            addEvent(<span class="built_in">window</span>, <span class="string">'load'</span>, <span class="built_in">window</span>.onload);</span><span class="line">            <span class="built_in">window</span>.onload = handleEvent;</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>###javascript中keyEvent按键事件说明(录自javascript权威指南第5版)</p>
<p>有3种按键类型，分别是keydown. keypress和keyup，它们分别对应onkeydown、onkeypress和onkeyup这几个事件监听器。</p>
<p>一个按键操作会产生这3个事件，依次是keydown. keypress，然后在按键释放的时候keyup。</p>
<p>这3个事件类型中，keypress事件是最为用户友好的：和它们相关的事件对象包含了所产生的实际字符的编码。keydown和keyup事件是较底层的，它们的按键事件包含一个和键盘所生成的硬件编码相关的“虚拟按键码”。对于ASCII字符集中的数字和字符，这些虚拟按键码和ASCII码相同。如果按下SHIFT键并按下数字2，keydown事件将通知发生了“SHITF-2”的按键事件。keypress事件会解释这一事件，说明这次按键产生了一个可打印的字符&quot;@&quot;。</p>
<p>对于不能打印的功能按键，如Backspace. Enter、Escape和箭头方向键、Page Up、Page Down以及F1到F12，它们会产生keydown和keyup事件。</p>
<p>在不同的浏览器中，按键事件的一些细节区别如下：</p>
<ol>
<li>对于不能打印的功能按键，在Firefox中，也会产生keypress事件，在IE和Chrome中，则不会触发keypress事件，只有当按键有一个ASCII码的时候，即此字符为可打印字符或者一个控制字符的时候，keypress事件才会发生。对于这些不能打印的功能按键，可通过和keydown事件相关的keyCode来获取。</li>
<li>作为一条通用的规则，keydown事件对于功能按键来说是最有用的，而keypress事件对于可打印的按键来说是最有用的，按下大写的&quot;A&quot;，keypress获取到的charCode为65，而按下小写的&quot;a&quot;，keypress获取到的charCode为97，但对于keydown事件来说，其获得的keyCode都是65，不能区分出实际按键是&quot;A&quot;还是&quot;a&quot;，所以keypress事件对用户最为友好。</li>
<li>在IE中，Alt按键组合被认为是无法打印的，所以并不会触发keypress事件。</li>
<li>在Firefox中，按键事件定义有二个属性，keyCode存储了一个按键的较低层次的虚拟按键码，并且和keydown事件一起发送。charCode存储了按下一个键时所产生的可打印的字符的编码，并且和keypress事件一起发送。在Firefox中，功能按键会产生一个keypress事件，在这种情况下，charCode是0，而keyCode包含了虚拟按键码。在Firefox中，发生keydown事件时，charCode都为0，所以在keydown时获取charCode是无意义的。</li>
<li>在IE中，只有一个keyCode属性，并且它的解释也取决于事件的类型。对于keydown事件来说，keyCode是一个虚拟按键码，对于keypress事件来说，keyCode是一个字符码。</li>
<li>在Chrome中，功能键与IE中表现一样，不会触发keypress事件，对于keydown事件，也会在事件的keyCode中存储虚拟按键码，而charCode为0，与IE和Firefox表现一样，然而在发生可打印字符的keypress事件时，除了与Firefox一样，会在事件的charCode中存储实际按键编码之外，也会在keyCode中存储实际按键编码，这二个值相同。</li>
<li>charCode字符码可以使用静态方数String.fromCharCode()转为字符。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 = <span class="built_in">document</span>.getElementById(<span class="string">'a1'</span>);</span><span class="line"><span class="keyword">var</span> a2 = <span class="built_in">document</span>.getElementById(<span class="string">'a2'</span>);</span><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><span class="line">    $.<span class="built_in">console</span>.log(<span class="string">'handler:'</span> + e.type);</span><span class="line">    e.preventDefault();</span><span class="line">&#125;;</span><span class="line"><span class="keyword">var</span> otherHandler = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><span class="line">    $.<span class="built_in">console</span>.log(<span class="string">'otherHandler: '</span> + e.type + e.eventPhase);</span><span class="line">    e.preventDefault();</span><span class="line">&#125;;</span><span class="line"><span class="keyword">var</span> handlerSelf = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><span class="line">    $.<span class="built_in">console</span>.log(e.type + <span class="string">': '</span> + e.eventPhase + <span class="string">', handlerSelf handler'</span>);</span><span class="line">    e.preventDefault();</span><span class="line">&#125;;</span><span class="line"><span class="keyword">var</span> keyPressHandler = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><span class="line">    $.<span class="built_in">console</span>.log(<span class="string">"keyPress keyCode: "</span> + e.keyCode);</span><span class="line">    $.<span class="built_in">console</span>.log(<span class="string">"keyPress charCode: "</span> + e.charCode);</span><span class="line">&#125;;</span><span class="line"><span class="keyword">var</span> keyDownHandler = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><span class="line">    $.<span class="built_in">console</span>.log(<span class="string">"keyDown keyCode: "</span> + e.keyCode);</span><span class="line">    <span class="comment">// The 'charCode' property of a keydown event should not be used. The value is meaningless.</span></span><span class="line">    $.<span class="built_in">console</span>.log(<span class="string">"在keydown事件中获取charCode毫无意义，IE中不能获取，其他浏览器中此值都为0"</span>);</span><span class="line">&#125;;</span><span class="line">a1.onmouseover = handlerSelf; <span class="comment">// this handler will override by addEvent function.</span></span><span class="line">addEvent(a1, <span class="string">'mouseover'</span>, handler); <span class="comment">// addEvent.guid = 1(handler), element.events['mouseover'][0] = element['on' + 'mouseover'] = handlerSelf, element.events['mouseover'][1] = handler</span></span><span class="line">addEvent(a1, <span class="string">'click'</span>, handler); <span class="comment">// addEvent.guid = 1(handler), element.events['click'][1] = handler</span></span><span class="line">addEvent(a1, <span class="string">'click'</span>, otherHandler); <span class="comment">// addEvent.guid = 2(otherHandler), element.events['click'][2] = otherHandler</span></span><span class="line">addEvent(a2, <span class="string">'keydown'</span>, keyDownHandler);</span><span class="line">addEvent(a2, <span class="string">'keypress'</span>, keyPressHandler);</span></pre></td></tr></table></figure>
<p>jQuery-1.4.2版本的事件管理机制是以此代码为原型的，之前jQuery-1.2.6版本中的event管理机制稍显简单。</p>
<p>与Dean Edwards稍有不同的是，jQuery并不是将events作为原生element对象的属性保存的，而是巧妙的通过jQuery.data中的以key为events进行保存，并且events[type]对应不是以object对象形式存放了handle事件处理方法，而是一个数组(events[type] = [])，在数组里放入了进一步封闭的handleObj，handleObj对象包括以下属性：handle. data、namespace、type、guid。</p>
<p>其事件管理的机制非常简单清晰：每个事件处理方法handler都有一个全局的ID，每个element都增加了一个events对象属性(element.events={})，而此events对象中键值即为事件类型type，每个事件类型(element.events[type])对应一个object(element.events[type]={})，在此object中存放了与此element，此type事件类型相关的所有事件处理方法handlers，而且object的key值即为对应每个handler分配到的全局ID。</p>
<p>最后再为element[&quot;on&quot; + type]添加事件处理方法handleEvent，在此方法内遍历运行element.events[type]对象中的所有handle，如果其中有一个handle方法返回false，则由handleEvent返回false作为element[&quot;on&quot; + type]事件触发的最后结果。</p>
<p>jQuery.event对象定义源码部分，jQuery.event对象中的这些方法是在jQuery源码内部使用的，是其事件管理的核心代码，与jQuery.data(elem, &quot;events&quot;)关联在一起，关于jQuery.data()部分可参考data源码阅读笔记。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><span class="line"><span class="comment"> * A number of helper functions used for managing events.</span></span><span class="line"><span class="comment"> * Many of the ideas behind this code originated from</span></span><span class="line"><span class="comment"> * Dean Edwards' addEvent library.</span></span><span class="line"><span class="comment"> */</span></span><span class="line">jQuery.event = &#123;</span><span class="line"></span><span class="line">    <span class="comment">// Bind an event to an element</span></span><span class="line">    <span class="comment">// Original by Dean Edwards</span></span><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params"> elem, types, handler, data </span>) </span>&#123;</span><span class="line">        <span class="comment">// Node.TEXT_NODE = 3;             // Text</span></span><span class="line">        <span class="comment">// Node.COMMENT_NODE = 8;          // Comment</span></span><span class="line">        <span class="comment">// 将事件添加到Element上，对于text node和comment node上的事件绑定忽略</span></span><span class="line">        <span class="keyword">if</span> ( elem.nodeType === <span class="number">3</span> || elem.nodeType === <span class="number">8</span> ) &#123;</span><span class="line">            <span class="keyword">return</span>;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// For whatever reason, IE has trouble passing the window object</span></span><span class="line">        <span class="comment">// around, causing it to be cloned in the process</span></span><span class="line">        <span class="comment">// 对IE中的window对象进行处理</span></span><span class="line">        <span class="keyword">if</span> ( elem.setInterval &amp;&amp; ( elem !== <span class="built_in">window</span> &amp;&amp; !elem.frameElement ) ) &#123;</span><span class="line">            elem = <span class="built_in">window</span>;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="keyword">var</span> handleObjIn, handleObj;</span><span class="line"></span><span class="line">        <span class="comment">// handler对象可以是一个object，需要绑定的事件监听器实际为handler.handler，如在jQuery.fn.live()方法定义中用到的：</span></span><span class="line">        <span class="comment">// jQuery.event.add(this, liveConvert( type, selector ),</span></span><span class="line">        <span class="comment">//                 &#123; data: data, selector: selector, handler: fn, origType: type, origHandler: fn, preType: preType &#125;);</span></span><span class="line">        <span class="comment">// 将传入的handler参数记到临时变量handleObjIn，将其回调方法handleObjIn.handler作为handler事件回调方法</span></span><span class="line">        <span class="keyword">if</span> ( handler.handler ) &#123;</span><span class="line">            handleObjIn = handler;</span><span class="line">            handler = handleObjIn.handler;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// 为事件监听器handler添加一个全局的guid，此guid会作为key，进行事件添加和删除操作</span></span><span class="line">        <span class="comment">// Make sure that the function being executed has a unique ID</span></span><span class="line">        <span class="keyword">if</span> ( !handler.guid ) &#123;</span><span class="line">            handler.guid = jQuery.guid++;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// Init the element's event structure</span></span><span class="line">        <span class="keyword">var</span> elemData = jQuery.data( elem );</span><span class="line"></span><span class="line">        <span class="comment">// 参考jQuery.data()的代码阅读笔记：如果想将data附在embed/object/applet上，将无法生效，并且jQuery.data(elem)方法返回undefined</span></span><span class="line">        <span class="comment">// If no elemData is found then we must be trying to bind to one of the</span></span><span class="line">        <span class="comment">// banned noData elements</span></span><span class="line">        <span class="keyword">if</span> ( !elemData ) &#123;</span><span class="line">            <span class="keyword">return</span>;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// jQuery中，事件通过elemData而绑定到对应的element之上，并不是直接添加在element元素本身上</span></span><span class="line">        <span class="comment">// jQuery代码的一个原则就是不会修改和添加javascript原生对象的属性</span></span><span class="line">        <span class="keyword">var</span> events = elemData.events = elemData.events || &#123;&#125;,</span><span class="line">            eventHandle = elemData.handle, eventHandle;</span><span class="line"></span><span class="line">        <span class="comment">// 如果eventHandle没有初始化，则进行初始化</span></span><span class="line">        <span class="comment">// jQuery实际是通过将这个eventHandle方法绑到DOM元素上，其他用jQuery绑定的各种事件，包括用户自定义的事件以及更高级的支持命名空间的事件，实际上jQuery都将之存在jQuery.data(elem, "events")缓存中，当浏览器触发了相应的事件，就会通过eventHandle，执行缓存中的与此事件类型相关的全部事件处理器</span></span><span class="line">        <span class="comment">// 注意这个eventHandle方法的代码中，没有使用关键字this来指向这个被监听的DOM元素，而是使用了Function.prototype.apply()方法，将jQuery.event.handle()作为DOM元素的方法进行调用，从而用jQuery绑定的事件处理器中的this关键字可以正确指向发生事件的DOM元素</span></span><span class="line">        <span class="comment">// 之所以使用Function.prototype.apply()将事件处理方法重新绑到正确的作用域上，是为了解决IE事件绑定方法的错误，因为elem.addEventListener(type, handler, useCapture)方法将handler绑定在elem之上，当事件发生时，handler中的this关键字是正确指向elem的。但是在IE中，使用elem.attachEvent('on' + type, handler)方法，将handler绑定到elem之上，在事件发生时，handler中的this却永远是指向全局的window对象的，并不是指向发生事件的elem元素，这使得handler中的this关键字全无用处，或者被误用</span></span><span class="line">        <span class="comment">// 另外可以看到attachEvent()方法只接收二个参数，所以在IE中绑定的handler都是在冒泡阶段被调用，没有机会将handler绑定在事件的捕获阶段，因为IE的事件模型的冒泡型的，与标准的DOM 2级别的事件模型不一样，jQuery为了兼容性，所以事件也是在冒泡(包括第2阶段到达事件目标节点阶段)阶段时，调用下面这个eventHandle，因此使用jQuery进行事件绑定也是不能将事件绑定到捕获阶段的</span></span><span class="line">        <span class="keyword">if</span> ( !eventHandle ) &#123;</span><span class="line">            elemData.handle = eventHandle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><span class="line">                <span class="comment">// Handle the second event of a trigger and when an event is called after a page has unloaded</span></span><span class="line">                <span class="keyword">return</span> <span class="keyword">typeof</span> jQuery !== <span class="string">"undefined"</span> &amp;&amp; !jQuery.event.triggered ?</span><span class="line">                    <span class="comment">// 当绑定在elem元素上的事件发生时，调用jQuery.event.handle进行事件处理</span></span><span class="line">                    <span class="comment">// eventHandle作为事件监听器，事件发生时，会调用此方法，浏览器会将event做为参数传给eventHandle此方法，arguments[0]即为event</span></span><span class="line">                    jQuery.event.handle.apply( eventHandle.elem, <span class="built_in">arguments</span> ) :</span><span class="line">                    <span class="literal">undefined</span>;</span><span class="line">            &#125;;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// 将elem作为eventHandle方法的一个参数，在事件被添加完成之后，会将elem置为null</span></span><span class="line">        <span class="comment">// Add elem as a property of the handle function</span></span><span class="line">        <span class="comment">// This is to prevent a memory leak with non-native events in IE.</span></span><span class="line">        eventHandle.elem = elem;</span><span class="line"></span><span class="line">        <span class="comment">// 通过空格分隔事件名，可以一次绑定多个事件</span></span><span class="line">        <span class="comment">// Handle multiple events separated by a space</span></span><span class="line">        <span class="comment">// jQuery(...).bind("mouseover mouseout", fn);</span></span><span class="line">        types = types.split(<span class="string">" "</span>);</span><span class="line"></span><span class="line">        <span class="comment">// 关于namespaces的作用，可看后面关于unbind方法的官方文档说明，是为了可以有选择的移除事件监听器</span></span><span class="line">        <span class="keyword">var</span> type, i = <span class="number">0</span>, namespaces;</span><span class="line"></span><span class="line">        <span class="keyword">while</span> ( (type = types[ i++ ]) ) &#123;</span><span class="line">            <span class="comment">// 因为可能同时绑定多个事件到jquery对象匹配的DOM元素上，所以每次需要重新初始化handleObj</span></span><span class="line">            handleObj = handleObjIn ?</span><span class="line">                jQuery.extend(&#123;&#125;, handleObjIn) :</span><span class="line">                &#123; <span class="attr">handler</span>: handler, <span class="attr">data</span>: data &#125;;</span><span class="line"></span><span class="line">            <span class="comment">// jQuery的自定义事件支持namespace</span></span><span class="line">            <span class="comment">// Namespaced event handlers</span></span><span class="line">            <span class="keyword">if</span> ( type.indexOf(<span class="string">"."</span>) &gt; <span class="number">-1</span> ) &#123;</span><span class="line">                namespaces = type.split(<span class="string">"."</span>);</span><span class="line">                <span class="comment">// 第一个点号前的字符串为实际的事件类型，如live.keyup.input中live做为事件类型</span></span><span class="line">                type = namespaces.shift();</span><span class="line">                <span class="comment">// 将后面部分字符串再次有序的拼成一个以点号分隔的字符串，做为事件的namespace：input.keyup，并且在做unbind时，input.keyup同keyup.input作用一样</span></span><span class="line">                handleObj.namespace = namespaces.slice(<span class="number">0</span>).sort().join(<span class="string">"."</span>);</span><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><span class="line">                namespaces = [];</span><span class="line">                handleObj.namespace = <span class="string">""</span>;</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="comment">// 为handleObj设置type和guid</span></span><span class="line">            <span class="comment">// type与events[ type ]重复，handleObj.guid与handler.guid相同是为了后面做jQuery.event.remove()操作时方便比较</span></span><span class="line">            handleObj.type = type;</span><span class="line">            handleObj.guid = handler.guid;</span><span class="line"></span><span class="line">            <span class="comment">// 从events[ type ]中获取到已经存储在jQuery.data(elem, "events")[ type ]中的事件处理方法列表</span></span><span class="line">            <span class="comment">// Get the current list of functions bound to this event</span></span><span class="line">            <span class="keyword">var</span> handlers = events[ type ],</span><span class="line">                <span class="comment">// 获取jQuery.event.special中type类型的特殊事件处理方法</span></span><span class="line">                <span class="comment">// 如type为live类型的特殊事件添加时，会获取此类事件的特殊处理对象，对于live事件，有add/remove方法</span></span><span class="line">                special = jQuery.event.special[ type ] || &#123;&#125;;</span><span class="line"></span><span class="line">            <span class="comment">// Init the event handler queue</span></span><span class="line">            <span class="comment">// 第一次添加type类型的事件时，因为handlers为undefined，所以会进入下面handlers初始化，以及将事件绑定到elem元素上</span></span><span class="line">            <span class="comment">// 所以type类型的事件绑定操作只会发生一次</span></span><span class="line">            <span class="keyword">if</span> ( !handlers ) &#123;</span><span class="line">                <span class="comment">// 如果此elem元素没有绑定过该type类型的事件，则在此进行初始化</span></span><span class="line">                <span class="comment">// 在Dean Edwards中这里初始化为一个object直接量，而jQuery此处是初始化为一个数组</span></span><span class="line">                <span class="comment">// 如果handlers已经被初始化为[]，则因为[]为true，不会运行到此处代码</span></span><span class="line">                handlers = events[ type ] = [];</span><span class="line"></span><span class="line">                <span class="comment">// 在这里调用special.setup()方法，通过此方法调用，jQuery.fn.live()实现blur/focus/submit/change/mouseenter/mouseleave等类型的事件代理</span></span><span class="line">    <span class="comment">// should notice difference between special.setup and special.add, special.setup only call once for per type per element, but special.add will call every event bind. The functionality that can be skipped is the actual binding of the event to the element using the addEventListener or attachEvent methods. This functionality is skipped based on the return value. Any value other than false prevents jQuery from actually binding the event to the element. In other words if you add return false to the setup and teardown methods of your special event, it will actually use the native DOM APIs to bind the event to the element.</span></span><span class="line">                <span class="comment">// special.add每次事件绑定都会调用，而special.setup只是在每个元素此事件类型第一次绑定时调用一次，可查看后面multiclick的例子说明</span></span><span class="line">    <span class="comment">// http://brandonaaron.net/blog/2009/03/26/special-events</span></span><span class="line">                <span class="comment">// Check for a special event handler</span></span><span class="line">                <span class="comment">// Only use addEventListener/attachEvent if the special</span></span><span class="line">                <span class="comment">// events handler returns false</span></span><span class="line">                <span class="keyword">if</span> ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === <span class="literal">false</span> ) &#123;</span><span class="line">                    <span class="comment">// Bind the global event handler to the element</span></span><span class="line">                    <span class="comment">// IE中没有实现elem.addEventListener()方法，Opera中elem.addEventListener/elem.attachEvent二个方法都有</span></span><span class="line">                    <span class="keyword">if</span> ( elem.addEventListener ) &#123;</span><span class="line">                        <span class="comment">// 将type类型的事件绑定到elem元素上，同样type类型的事件，绑定只发生一次，触发时则调用eventHandle事件监听器</span></span><span class="line">                        <span class="comment">// 对于特殊的事件类型，如live，这么绑定也没有意义</span></span><span class="line">                        elem.addEventListener( type, eventHandle, <span class="literal">false</span> );</span><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( elem.attachEvent ) &#123;</span><span class="line">                        <span class="comment">// 将事件绑定到elem元素上(IE)</span></span><span class="line">                        elem.attachEvent( <span class="string">"on"</span> + type, eventHandle );</span><span class="line">                    &#125;</span><span class="line">                &#125;</span><span class="line">            &#125;</span><span class="line"></span><span class="line">    <span class="comment">// jQuery 1.4 add two new special event hooks: add and remove. These two events hooks brought lots of power by being able to manipulate the event details for each event handler registered. This is different from the existing setup and teardown hooks (added in 1.2.2) that only worked once per an event, per an element.</span></span><span class="line">    <span class="comment">// In jQuery 1.4 there are two new special event hooks: add and remove. These two hooks, unlike setup and teardown, are called for each event being bound. The add hook receives the handler, data, and namespaces as arguments. The remove hook receives the data and namespaces as arguments. The add and remove hooks enable the creation of more complex, even customizable, events.</span></span><span class="line">            <span class="comment">// 有special.add方法的特殊事件，在jQuery.event.special本身的特殊事件中就只有live事件有add方法</span></span><span class="line">            <span class="comment">// 通过jQuery.event.special.live.add()方法再次调用到当前方法jQuery.event.add()，将live代理的实际事件类型也绑定到elem上</span></span><span class="line">            <span class="keyword">if</span> ( special.add ) &#123;</span><span class="line">                <span class="comment">// .live()绑定事件监听器时，除了会在events中添加live类型的事件监听器，也会调用special.add()再往events中添加live代理的实际事件类型</span></span><span class="line">                special.add.call( elem, handleObj );</span><span class="line"></span><span class="line">    <span class="comment">// 注意下面这个处理是为了防止在第3方的special.add方法中将handleObj.handler重写之后，将原来的guid丢失了，可参考这二篇文章中的说明：</span></span><span class="line">        <span class="comment">// http://brandonaaron.net/blog/2009/06/4/jquery-edge-new-special-event-hooks</span></span><span class="line">        <span class="comment">// http://brandonaaron.net/blog/2010/02/25/special-events-the-changes-in-1-4-2</span></span><span class="line">                <span class="keyword">if</span> ( !handleObj.handler.guid ) &#123;</span><span class="line">                    handleObj.handler.guid = handler.guid;</span><span class="line">                &#125;</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="comment">// 将handleObj加入此elem的type类型的事件回调方法列表中</span></span><span class="line">            <span class="comment">// Add the function to the element's handler list</span></span><span class="line">            handlers.push( handleObj );</span><span class="line"></span><span class="line">            <span class="comment">// 全局标记，说明type类型的事件已经被使用</span></span><span class="line">            <span class="comment">// Keep track of which events have been used, for global triggering</span></span><span class="line">            jQuery.event.global[ type ] = <span class="literal">true</span>;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// 关于IE中内存泄漏的细节可查看微软MSDN上官方解释：http://msdn.microsoft.com/en-us/library/bb250448%28VS.85%29.aspx</span></span><span class="line">        <span class="comment">// IE下面用来检查内存泄漏和DOM使用情况的工具sIEve：http://home.orange.nl/jsrosman/</span></span><span class="line">        <span class="comment">// Nullify elem to prevent memory leaks in IE</span></span><span class="line">        elem = <span class="literal">null</span>;</span><span class="line">    &#125;,</span><span class="line"></span><span class="line">    <span class="comment">// 缓存jQuery.event全局事件类型</span></span><span class="line">    global: &#123;&#125;,</span><span class="line"></span><span class="line">    <span class="comment">// 从一个element上，移除一个或者一组事件</span></span><span class="line">    <span class="comment">// [.die()-&gt;].unbind()-&gt;.remove()</span></span><span class="line">    <span class="comment">// Detach an event or set of events from an element</span></span><span class="line">    remove: <span class="function"><span class="keyword">function</span>(<span class="params"> elem, types, handler, pos </span>) </span>&#123;</span><span class="line">        <span class="comment">// 过滤文本和注释节点上的事件绑定</span></span><span class="line">        <span class="comment">// don't do events on text and comment nodes</span></span><span class="line">        <span class="keyword">if</span> ( elem.nodeType === <span class="number">3</span> || elem.nodeType === <span class="number">8</span> ) &#123;</span><span class="line">            <span class="keyword">return</span>;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="keyword">var</span> ret, type, fn, i = <span class="number">0</span>, all, namespaces, namespace, special, eventType, handleObj, origType,</span><span class="line">            elemData = jQuery.data( elem ),</span><span class="line">            events = elemData &amp;&amp; elemData.events;</span><span class="line"></span><span class="line">        <span class="comment">// 如果在element上没有发现elemData和elemData.events，则无事件可移除</span></span><span class="line">        <span class="keyword">if</span> ( !elemData || !events ) &#123;</span><span class="line">            <span class="keyword">return</span>;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// 如果types是一个handleObj对象，则重置handler和types的值</span></span><span class="line">        <span class="comment">// types is actually an event object here</span></span><span class="line">        <span class="keyword">if</span> ( types &amp;&amp; types.type ) &#123;</span><span class="line">            handler = types.handler;</span><span class="line">            types = types.type;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// 如果没有传types或者是传入了某个( "." + namespace )的types，则将从elem上移除所有类型的事件监听器或者全部namespace名命空间下的事件</span></span><span class="line">        <span class="comment">// Unbind all events for the element</span></span><span class="line">        <span class="keyword">if</span> ( !types || <span class="keyword">typeof</span> types === <span class="string">"string"</span> &amp;&amp; types.charAt(<span class="number">0</span>) === <span class="string">"."</span> ) &#123;</span><span class="line">            types = types || <span class="string">""</span>;</span><span class="line"></span><span class="line">            <span class="keyword">for</span> ( type <span class="keyword">in</span> events ) &#123;</span><span class="line">                <span class="comment">// 这里type + types举例如: "click" + ".namespace"</span></span><span class="line">                <span class="comment">// 再次调用当前方法，移除elem指定的事件类型</span></span><span class="line">                <span class="comment">// 这里就没有再传入handler这第三个参数，因为remove方法在运行时，可从其作用域链上拿到handler这个值</span></span><span class="line">                jQuery.event.remove( elem, type + types );</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="keyword">return</span>;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// 如果types是以空格分隔的多个事件类型，则分离之后逐一移除elem上的事件</span></span><span class="line">        <span class="comment">// Handle multiple events separated by a space</span></span><span class="line">        <span class="comment">// jQuery(...).unbind("mouseover mouseout", fn);</span></span><span class="line">        types = types.split(<span class="string">" "</span>);</span><span class="line"></span><span class="line">        <span class="keyword">while</span> ( (type = types[ i++ ]) ) &#123;</span><span class="line">            <span class="comment">// 将原来的type置入一个变量中，以备后用，因为type值可能被覆写</span></span><span class="line">            origType = type;</span><span class="line">            handleObj = <span class="literal">null</span>;</span><span class="line">            <span class="comment">// 如果type中没有分隔字符"."，则表示type事件类型不包括namespace，需要将此type的事件全部从当前elem上移除</span></span><span class="line">            all = type.indexOf(<span class="string">"."</span>) &lt; <span class="number">0</span>;</span><span class="line">            namespaces = [];</span><span class="line"></span><span class="line">            <span class="keyword">if</span> ( !all ) &#123;</span><span class="line">                <span class="comment">// 如果事件类型type是有特定的namespace，则重新解析，得到新的type值和namespace</span></span><span class="line">                <span class="comment">// Namespaced event handlers</span></span><span class="line">                namespaces = type.split(<span class="string">"."</span>);</span><span class="line">                type = namespaces.shift();</span><span class="line"></span><span class="line">                namespace = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(^|\\.)"</span> +</span><span class="line">                    jQuery.map( namespaces.slice(<span class="number">0</span>).sort(), fcleanup ).join(<span class="string">"\\.(?:.*\\.)?"</span>) + <span class="string">"(\\.|$)"</span>)</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="comment">// 获取指定事件类型为type的所有事件监听器集合</span></span><span class="line">            eventType = events[ type ];</span><span class="line"></span><span class="line">            <span class="comment">// 如果无此type类型的事件监听器(或者是前面有操作将此type类型的事件监听器已经全部删除了)，则继续下一循环</span></span><span class="line">            <span class="keyword">if</span> ( !eventType ) &#123;</span><span class="line">                <span class="keyword">continue</span>;</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="keyword">if</span> ( !handler ) &#123;</span><span class="line">                <span class="comment">// 如果remove方法没有传入handler参数，则需要根据当前elem上type类型的事件监听器进行remove操作</span></span><span class="line">                <span class="comment">// 因为下面eventType的内容会被Array的splice方法所修改，因此eventType.length是个不定长度，所以用"j &lt; eventType.length"进行比较</span></span><span class="line">                <span class="keyword">for</span> ( <span class="keyword">var</span> j = <span class="number">0</span>; j &lt; eventType.length; j++ ) &#123;</span><span class="line">                    handleObj = eventType[ j ];</span><span class="line"></span><span class="line">                    <span class="keyword">if</span> ( all || namespace.test( handleObj.namespace ) ) &#123;</span><span class="line">                        <span class="comment">// 如果前面调用jQuery.event.remove()方法没有指定handler，则在遍历时传入handleObje.handler，再次调用当前方法</span></span><span class="line">                        <span class="comment">// 移除origType类型中的handler事件监听器</span></span><span class="line">                        <span class="comment">// 传入了第四个参数j，是个重要的标识符，用于说明jQuery.event.remove()操作时，是没有传入handler事件监听器的操作</span></span><span class="line">                        <span class="comment">// 与后面的代码"pos != null &amp;&amp; eventType.length === 1"相对应</span></span><span class="line">                        <span class="comment">// 并且jQuery.event.remove()中传入第四个参数说明已经处于eventType.length这个循环中，根据循环中的handleObj进行remove操作</span></span><span class="line">                        <span class="comment">// 与后面pos != null处break跳出循环体相对应</span></span><span class="line">                        <span class="comment">// 如果是调用jQuery.fn.die(type)，没有传事件监听器进入此处代码时，最后会调用当前方法jQuery.event.remove()的代码：delete events[ type ]，这样执行之后，将移除对应于.live()的context上elemData.events.live属性，配合jQuery.event.special.live.remove()方法中remove标识符，通过将remove标识符置为false，从而只是移除了context上的live事件，并不移除context上通过live代理的原生事件，因此context上的原生事件仍然被绑定，只是执行到liveHandler()方法中，因为events.live属性不存在，被立即return</span></span><span class="line">                        jQuery.event.remove( elem, origType, handleObj.handler, j );</span><span class="line"></span><span class="line">                        <span class="comment">// 利用Array的splice方法将当前操作的handleObj从eventType中移除，最后eventType长度变为0时，j也会自减成为-1，结束当前for循环</span></span><span class="line">                        <span class="comment">// splice( start, deleteCount, value,...): Deletes the specified number of elements from the array starting at the specified index, then inserts any remaining arguments into the array at that location. Returns an array containing the deleted elements.</span></span><span class="line">                        eventType.splice( j--, <span class="number">1</span> );</span><span class="line">                    &#125;</span><span class="line">                &#125;</span><span class="line"></span><span class="line">                <span class="keyword">continue</span>;</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="comment">// 获取type类型的特殊事件监听器对象</span></span><span class="line">            special = jQuery.event.special[ type ] || &#123;&#125;;</span><span class="line"></span><span class="line">            <span class="comment">// eventType数组可能是变长的，取决于是否传入第四个参数pos，所以for循环中比较中使用eventType.length与j进行比较</span></span><span class="line">            <span class="keyword">for</span> ( <span class="keyword">var</span> j = pos || <span class="number">0</span>; j &lt; eventType.length; j++ ) &#123;</span><span class="line">                handleObj = eventType[ j ];</span><span class="line"></span><span class="line">                <span class="comment">// 此处进行事件监听器移除的操作，是根据guid进行判断的，所以如果2个不同的hanlder具有相同的的guid，这可以经过jQuery.proxy(fn1, fn2)方法代理绑定相同的guid，这2个handler都被绑定到这个elem上的话，如果移除其中任何一个handler，另一个handler也会被一起移除，因为它们的guid是相同的，参考utitilies部分的jQuery.proxy()方法说明</span></span><span class="line">                <span class="comment">// 当传入参数handler事件监听器的guid与当前handleObj的guid一致，则需要将此handleObj从eventType列表中移除</span></span><span class="line">                <span class="keyword">if</span> ( handler.guid === handleObj.guid ) &#123;</span><span class="line">                    <span class="comment">// remove the given handler for the given type</span></span><span class="line">                    <span class="keyword">if</span> ( all || namespace.test( handleObj.namespace ) ) &#123;</span><span class="line">                        <span class="comment">// 将handleObj从eventType列表中移除</span></span><span class="line">                        <span class="keyword">if</span> ( pos == <span class="literal">null</span> ) &#123;</span><span class="line">                            <span class="comment">// 利用Array的splice方法将当前操作的handleObj从eventType中移除</span></span><span class="line">                            <span class="comment">// 所以eventType数组是变长的</span></span><span class="line">                            eventType.splice( j--, <span class="number">1</span> );</span><span class="line">                        &#125;</span><span class="line"></span><span class="line">                        <span class="comment">// 如果当前的special特殊事件监听器对象有remove方法，则调用之</span></span><span class="line">                        <span class="comment">// 与special.add对应，每个事件监听器被删除时，都会有机会调用special.remove方法，而special.teardown是在最后一个事件处理器被删除时发生调用</span></span><span class="line">                        <span class="keyword">if</span> ( special.remove ) &#123;</span><span class="line">                            <span class="comment">// 调用jQuery.event.special.live.remove()方法</span></span><span class="line">                            special.remove.call( elem, handleObj );</span><span class="line">                        &#125;</span><span class="line">                    &#125;</span><span class="line"></span><span class="line">                    <span class="comment">// 如果有pos传入，即此处代码是由于"jQuery.event.remove( elem, origType, handleObj.handler, j )"调用产生</span></span><span class="line">                    <span class="comment">// 实际只是在eventType数组的指定位置pos上，调用完当前方法后就任务完成，在此跳出循环</span></span><span class="line">                    <span class="keyword">if</span> ( pos != <span class="literal">null</span> ) &#123;</span><span class="line">                        <span class="keyword">break</span>;</span><span class="line">                    &#125;</span><span class="line">                &#125;</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="comment">// 当有第四个参数pos传入时，是移除指定的handler，而当eventType.length为1时，表示这是最后一个此type类型的事件监听器被移除，后面因为调用eventType.splice( j--, 1 )之后，eventType数组长度就会成为0了，这时需要移除elem元素上的事件监听器eventHandle</span></span><span class="line">            <span class="comment">// elemData.handle = eventHandle = function()&#123;...&#125;，是在jQuery.event.add()方法中定义的一个事件监听器</span></span><span class="line">            <span class="comment">// eventHandle这个事件监听器是通过elem元素原来的addEventListener/attachEvent方法绑定的，需要通过removeEvent()方法调用removeEventListener/detachEvent移除事件绑定</span></span><span class="line">            <span class="comment">// remove generic event handler if no more handlers exist</span></span><span class="line">            <span class="keyword">if</span> ( eventType.length === <span class="number">0</span> || pos != <span class="literal">null</span> &amp;&amp; eventType.length === <span class="number">1</span> ) &#123;</span><span class="line">                <span class="comment">// 如果定义了special.teardown，则调用之，如果此回调方法返回false，则调用removeEvent()方法从DOM节点elem上移除对应type类型的handler，special.teardown只调用一次，与special.setup相对应</span></span><span class="line">                <span class="keyword">if</span> ( !special.teardown || special.teardown.call( elem, namespaces ) === <span class="literal">false</span> ) &#123;</span><span class="line">                    removeEvent( elem, type, elemData.handle );</span><span class="line">                &#125;</span><span class="line"></span><span class="line">                ret = <span class="literal">null</span>;</span><span class="line">                <span class="comment">// 当这里的type值"live"的时候，将移除elemData.events.live属性，而通过live绑定在其context上的原生事件却不会被删除，因为在jQuery.event.special.live.remove()方法中的remove标识符会被置为false</span></span><span class="line">                <span class="keyword">delete</span> events[ type ];</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// delete操作符说明：Deletes an object property.</span></span><span class="line">        <span class="comment">// Note that this is not the same as simply setting the property to null.</span></span><span class="line">        <span class="comment">// Evaluates to false if the property could not be deleted, or true otherwise.</span></span><span class="line">        <span class="comment">// 关于javascript delete操作符的一篇文章：http://perfectionkills.com/understanding-delete/</span></span><span class="line">        <span class="comment">// 此文的翻译链接：http://www.denisdeng.com/?p=858</span></span><span class="line">        <span class="comment">// 另一篇原文是日语，国人翻译链接：http://tech.idv2.com/2008/01/09/javascript-variables-and-delete-operator/</span></span><span class="line">        <span class="comment">// 如果elemData.events为空对象，则同时移除elemData上的handle和events属性，释放内存</span></span><span class="line">        <span class="comment">// Remove the expando if it's no longer used</span></span><span class="line">        <span class="keyword">if</span> ( jQuery.isEmptyObject( events ) ) &#123;</span><span class="line">            <span class="keyword">var</span> handle = elemData.handle;</span><span class="line">            <span class="comment">// 在jQuery.event.add()方法中在handle上绑定了一个属性elem，其值即为当前元素elem</span></span><span class="line">            <span class="keyword">if</span> ( handle ) &#123;</span><span class="line">                handle.elem = <span class="literal">null</span>;</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="comment">// 因为当前jQuery.event.remove()方法可能被自身调用过一次，elemData.events/handle已经被删除过，会重复执行，删除一个不存在的events/handle属性</span></span><span class="line">            <span class="comment">// 这个jQuery.event.remove()方法写得比较绕，后续的jQuery版本肯定会做改进</span></span><span class="line">            <span class="keyword">delete</span> elemData.events;</span><span class="line">            <span class="keyword">delete</span> elemData.handle;</span><span class="line"></span><span class="line">            <span class="comment">// 如果elemData本身也已经是空对象，那么也调用jQuery.removeData()方法，将elem对应的data从jQuery.cache中全部删除</span></span><span class="line">            <span class="keyword">if</span> ( jQuery.isEmptyObject( elemData ) ) &#123;</span><span class="line">                jQuery.removeData( elem );</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line">    &#125;,</span><span class="line"></span><span class="line">    <span class="comment">// bubbling is internal</span></span><span class="line">    trigger: <span class="function"><span class="keyword">function</span>(<span class="params"> event, data, elem <span class="regexp">/*, bubbling */</span> </span>) </span>&#123;</span><span class="line">        <span class="comment">// Event object or event type</span></span><span class="line">        <span class="comment">// 获取事件类型，第四个参数用于控制是否事件冒泡</span></span><span class="line">        <span class="keyword">var</span> type = event.type || event,</span><span class="line">            bubbling = <span class="built_in">arguments</span>[<span class="number">3</span>];</span><span class="line"></span><span class="line">        <span class="keyword">if</span> ( !bubbling ) &#123;</span><span class="line">            <span class="comment">// 利用jQuery.Event()构造方法，构造一个jQuery模拟规范重写过的仿event对象</span></span><span class="line">            event = <span class="keyword">typeof</span> event === <span class="string">"object"</span> ?</span><span class="line">                <span class="comment">// jQuery.Event object</span></span><span class="line">                <span class="comment">// 如果event[expando]属性存在，说明此event已经是jQuery.Event对象</span></span><span class="line">                event[expando] ? event :</span><span class="line">                <span class="comment">// Object literal</span></span><span class="line">                <span class="comment">// 不然这个event对象是一个object直接量，将其属性合并到jQuery.Event(type)生成的event对象中</span></span><span class="line">                jQuery.extend( jQuery.Event(type), event ) :</span><span class="line">                <span class="comment">// Just the event type (string)</span></span><span class="line">                <span class="comment">// 根据传入的type创建一个jQuery.Event对象</span></span><span class="line">                jQuery.Event(type);</span><span class="line"></span><span class="line">            <span class="comment">// 如果type有后缀"!"，表示取反操作</span></span><span class="line">            <span class="keyword">if</span> ( type.indexOf(<span class="string">"!"</span>) &gt;= <span class="number">0</span> ) &#123;</span><span class="line">                <span class="comment">// 将原type中最后一个字符去掉</span></span><span class="line">                event.type = type = type.slice(<span class="number">0</span>, <span class="number">-1</span>);</span><span class="line">                event.exclusive = <span class="literal">true</span>;</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="comment">// 如果当前方法是全局调用的，没有传入具体的elem元素，则将所有元素上的type类型的事件全部触发</span></span><span class="line">            <span class="comment">// Handle a global trigger</span></span><span class="line">            <span class="keyword">if</span> ( !elem ) &#123;</span><span class="line">                <span class="comment">// Don't bubble custom events when global (to avoid too much overhead)</span></span><span class="line">                <span class="comment">// 只触发当前对象上的事件监听器，阻止事件向上冒泡</span></span><span class="line">                event.stopPropagation();</span><span class="line"></span><span class="line">                <span class="comment">// 根据全局标识符jQuery.event.global[ type ]确认文档中type类型的事件绑定，才进行触发操作</span></span><span class="line">                <span class="comment">// Only trigger if we've ever bound an event for it</span></span><span class="line">                <span class="keyword">if</span> ( jQuery.event.global[ type ] ) &#123;</span><span class="line">                    jQuery.each( jQuery.cache, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><span class="line">                        <span class="keyword">if</span> ( <span class="keyword">this</span>.events &amp;&amp; <span class="keyword">this</span>.events[type] ) &#123;</span><span class="line">                            <span class="comment">// 调用方法本身，此时的event对象，已经是被jQuery.Event()方法修复之后的对象</span></span><span class="line">                            jQuery.event.trigger( event, data, <span class="keyword">this</span>.handle.elem );</span><span class="line">                        &#125;</span><span class="line">                    &#125;);</span><span class="line">                &#125;</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="comment">// Handle triggering a single element</span></span><span class="line"></span><span class="line">            <span class="comment">// don't do events on text and comment nodes</span></span><span class="line">            <span class="keyword">if</span> ( !elem || elem.nodeType === <span class="number">3</span> || elem.nodeType === <span class="number">8</span> ) &#123;</span><span class="line">                <span class="keyword">return</span> <span class="literal">undefined</span>;</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="comment">// Clean up in case it is reused</span></span><span class="line">            event.result = <span class="literal">undefined</span>;</span><span class="line">            event.target = elem;</span><span class="line"></span><span class="line">            <span class="comment">// Clone the incoming data, if any</span></span><span class="line">            data = jQuery.makeArray( data );</span><span class="line">            <span class="comment">// 将修复之后的event对象也压入data数组之中</span></span><span class="line">            data.unshift( event );</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// 在W3C中，用currentTarget来说明在捕获阶段和冒泡阶段时，事件正在处理的DOM对象，此时currentTarget与event.target可能不同，IE中不支持此属性</span></span><span class="line">        <span class="comment">// event.currentTarget: The current DOM element within the event bubbling phase.</span></span><span class="line">        event.currentTarget = elem;</span><span class="line"></span><span class="line">        <span class="comment">// 在jQuery.event.add()方法中为elemData添加了handle属性：elemData.handle = eventHandle = function() &#123;...&#125;</span></span><span class="line">        <span class="comment">// Trigger the event, it is assumed that "handle" is a function</span></span><span class="line">        <span class="keyword">var</span> handle = jQuery.data( elem, <span class="string">"handle"</span> );</span><span class="line">        <span class="keyword">if</span> ( handle ) &#123;</span><span class="line">            <span class="comment">// 触发DOM2级别的事件监听器，包括IE中通过attachEvent形式注册的事件监听器</span></span><span class="line">            <span class="comment">// 将handle作为elem的方法进行调用，并将data做为参数传给handle事件监听器，其中第一个参数正是修复后的event对象</span></span><span class="line">            handle.apply( elem, data );</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="keyword">var</span> parent = elem.parentNode || elem.ownerDocument;</span><span class="line"></span><span class="line">        <span class="comment">// 触发DOM0级别的事件监听器，即原始事件模型(事件监听器以HTML属性方式存在)</span></span><span class="line">        <span class="comment">// Trigger an inline bound script</span></span><span class="line">        <span class="keyword">try</span> &#123;</span><span class="line">            <span class="keyword">if</span> ( !(elem &amp;&amp; elem.nodeName &amp;&amp; jQuery.noData[elem.nodeName.toLowerCase()]) ) &#123;</span><span class="line">                <span class="comment">// 定义为HTML属性的事件监听器具有更加复杂的作用域链，它执行的作用域和其他的函数的作用域不同，更详细说明可查看javascript权威指南的第17章1.6节</span></span><span class="line">                <span class="comment">// 触发定义为HTML属性的事件监听器</span></span><span class="line">                <span class="keyword">if</span> ( elem[ <span class="string">"on"</span> + type ] &amp;&amp; elem[ <span class="string">"on"</span> + type ].apply( elem, data ) === <span class="literal">false</span> ) &#123;</span><span class="line">                    event.result = <span class="literal">false</span>;</span><span class="line">                &#125;</span><span class="line">            &#125;</span><span class="line"></span><span class="line">        <span class="comment">// prevent IE from throwing an error for some elements with some event types, see #3533</span></span><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><span class="line"></span><span class="line">        <span class="comment">// 当事件经过捕获. 到达目标、冒泡三个阶段之后，才会触发浏览器中事件的默认行为</span></span><span class="line">        <span class="comment">// 如果事件event没有被阻止向上冒泡，则触发祖先节点上的事件监听器，并传入第四个参数bubbling为true</span></span><span class="line">        <span class="keyword">if</span> ( !event.isPropagationStopped() &amp;&amp; parent ) &#123;</span><span class="line">            jQuery.event.trigger( event, data, parent, <span class="literal">true</span> );</span><span class="line"></span><span class="line">        <span class="comment">// jQuery.event.trigger()方法模拟了浏览器执行事件的过程，在处理了DOM 2和DOM 0级别的事件监听器之后，触发事件原生行为</span></span><span class="line">        <span class="comment">// 触发事件event应该发生的原生行为，即事件在浏览器中的默认行为</span></span><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( !event.isDefaultPrevented() ) &#123;</span><span class="line">            <span class="comment">// 如果事件event没有被取消浏览器默认行为，如表单提交. 链接跳转</span></span><span class="line">            <span class="keyword">var</span> target = event.target, old,</span><span class="line">                <span class="comment">// isClick表示链接上发生的点击事件</span></span><span class="line">                isClick = jQuery.nodeName(target, <span class="string">"a"</span>) &amp;&amp; type === <span class="string">"click"</span>,</span><span class="line">                special = jQuery.event.special[ type ] || &#123;&#125;;</span><span class="line"></span><span class="line">            <span class="comment">// 排除无_default行为属性或者_default返回false的special对象</span></span><span class="line">            <span class="comment">// 因为前面用jQuery.event.trigger( event, data, parent, true)冒泡到document，此时_default是在document上调用的，而不是在event.target上调用的，这里设计可能不是作者的原意</span></span><span class="line">            <span class="keyword">if</span> ( (!special._default || special._default.call( elem, event ) === <span class="literal">false</span>) &amp;&amp;</span><span class="line">                  <span class="comment">// 排除链接上的点击事件</span></span><span class="line">                  !isClick &amp;&amp;</span><span class="line">                  <span class="comment">// 排除发生在embed/object/applet上的事件</span></span><span class="line">                  !(target &amp;&amp; target.nodeName &amp;&amp; jQuery.noData[target.nodeName.toLowerCase()]) ) &#123;</span><span class="line"></span><span class="line">                <span class="keyword">try</span> &#123;</span><span class="line">                    <span class="keyword">if</span> ( target[ type ] ) &#123;</span><span class="line">                        <span class="comment">// Make sure that we don't accidentally re-trigger the onFOO events</span></span><span class="line">                        old = target[ <span class="string">"on"</span> + type ];</span><span class="line"></span><span class="line">                        <span class="comment">// 因为后面target[ type ]()代码触发默认行为会执行elem.onTYPE事件监听器</span></span><span class="line">                        <span class="comment">// 为防止elem.onTYPE事件再次被触发，先将其置于临时变量old中，并将其置为null</span></span><span class="line">                        <span class="keyword">if</span> ( old ) &#123;</span><span class="line">                            target[ <span class="string">"on"</span> + type ] = <span class="literal">null</span>;</span><span class="line">                        &#125;</span><span class="line"></span><span class="line">                        <span class="comment">// 表示当前elem上type类型的事件已经触发，作为一个标识符，避免eventHandle事件监听器被重复触发</span></span><span class="line">                        jQuery.event.triggered = <span class="literal">true</span>;</span><span class="line"></span><span class="line">                        <span class="comment">// 触发elem元素上的默认浏览器行为，如input.blur(). input.focus()、form.submit()等</span></span><span class="line">                        target[ type ]();</span><span class="line">                    &#125;</span><span class="line"></span><span class="line">                <span class="comment">// prevent IE from throwing an error for some elements with some event types, see #3533</span></span><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><span class="line"></span><span class="line">                <span class="keyword">if</span> ( old ) &#123;</span><span class="line">                    <span class="comment">// 根据临时变量old，还原event.target上的HTML属性形式的事件监听器</span></span><span class="line">                    target[ <span class="string">"on"</span> + type ] = old;</span><span class="line">                &#125;</span><span class="line"></span><span class="line">                <span class="comment">// 事件event触发原生行为完成后，重置jQuery.event.triggered为false</span></span><span class="line">                jQuery.event.triggered = <span class="literal">false</span>;</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line">    &#125;,</span><span class="line"></span><span class="line">    handle: <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><span class="line">        <span class="keyword">var</span> all, handlers, namespaces, namespace, events;</span><span class="line"></span><span class="line">        <span class="comment">// handle事件处理方法在eventHandle这个事件监听器被触发时调用时jQuery.event.handle.apply( eventHandle.elem, arguments )，其event为浏览器本身的event对象</span></span><span class="line">        <span class="comment">// 其中的arguments是在jQuery.event.trigger()方法中生成的data数组，数组中第一个值即是经过修复的event对象，这个event对象也就被传到当前handle方法的参数event上，再调用jQuery.event.fix()方法，对当前event对象模拟实现规范里的属性和方法</span></span><span class="line">        event = <span class="built_in">arguments</span>[<span class="number">0</span>] = jQuery.event.fix( event || <span class="built_in">window</span>.event );</span><span class="line">        event.currentTarget = <span class="keyword">this</span>;</span><span class="line"></span><span class="line">        <span class="comment">// Namespaced event handlers</span></span><span class="line">        all = event.type.indexOf(<span class="string">"."</span>) &lt; <span class="number">0</span> &amp;&amp; !event.exclusive;</span><span class="line"></span><span class="line">        <span class="keyword">if</span> ( !all ) &#123;</span><span class="line">            namespaces = event.type.split(<span class="string">"."</span>);</span><span class="line">            event.type = namespaces.shift();</span><span class="line">            namespace = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(^|\\.)"</span> + namespaces.slice(<span class="number">0</span>).sort().join(<span class="string">"\\.(?:.*\\.)?"</span>) + <span class="string">"(\\.|$)"</span>);</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="keyword">var</span> events = jQuery.data(<span class="keyword">this</span>, <span class="string">"events"</span>), handlers = events[ event.type ];</span><span class="line"></span><span class="line">        <span class="keyword">if</span> ( events &amp;&amp; handlers ) &#123;</span><span class="line">            <span class="comment">// Clone the handlers to prevent manipulation</span></span><span class="line">            <span class="comment">// Array.prototype.slice: Returns a new array that contains the elements of the array from the element numbered start, up to, but not including, the element numbered end. 数组的slice方法返回一个新数组，也就是根据原来的数组内容新创建了一个数组对象，利用slice进行数组的复制也很巧妙</span></span><span class="line">            handlers = handlers.slice(<span class="number">0</span>);</span><span class="line"></span><span class="line">            <span class="keyword">for</span> ( <span class="keyword">var</span> j = <span class="number">0</span>, l = handlers.length; j &lt; l; j++ ) &#123;</span><span class="line">                <span class="keyword">var</span> handleObj = handlers[ j ];</span><span class="line"></span><span class="line">                <span class="comment">// Filter the functions by class</span></span><span class="line">                <span class="keyword">if</span> ( all || namespace.test( handleObj.namespace ) ) &#123;</span><span class="line">                    <span class="comment">// Pass in a reference to the handler function itself</span></span><span class="line">                    <span class="comment">// So that we can later remove it</span></span><span class="line">                    event.handler = handleObj.handler;</span><span class="line"></span><span class="line">                    <span class="comment">// Contains the optional data passed to jQuery.fn.bind when the current executing handler was bound.</span></span><span class="line">                    event.data = handleObj.data;</span><span class="line">                    event.handleObj = handleObj;</span><span class="line"></span><span class="line">                    <span class="comment">// 依次运行handlers中的每个handleObj.handler事件监听器</span></span><span class="line">                    <span class="keyword">var</span> ret = handleObj.handler.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><span class="line"></span><span class="line">                    <span class="keyword">if</span> ( ret !== <span class="literal">undefined</span> ) &#123;</span><span class="line">                        <span class="comment">// 最后运行结果非undefined的handleObj.handler，其运行结果被作为jQuery.event.handle()方法的结果返回</span></span><span class="line">                        event.result = ret;</span><span class="line">                        <span class="keyword">if</span> ( ret === <span class="literal">false</span> ) &#123;</span><span class="line">                            <span class="comment">// handlers数组中任意一个handleObj.handler事件监听器结果为false，则取消事件冒泡和事件的默认行为</span></span><span class="line">                            <span class="comment">// 所以如果想取消一个事件的向上冒泡和默认行为，只要使用绑定的事件监听器return false</span></span><span class="line">                            <span class="comment">// 此处的代码也说明了在事件处理器中使用return false和event.preventDefault()二者的区别</span></span><span class="line">                            event.preventDefault();</span><span class="line">                            event.stopPropagation();</span><span class="line">                        &#125;</span><span class="line">                    &#125;</span><span class="line"></span><span class="line">                    <span class="comment">// 如果事件要求立即停止事件传播，则跳出循环体，之后的handleObj.handler事件监听器将不再执行，立即停止</span></span><span class="line">                    <span class="comment">// 如果只是event.isPropagationStopped()，是会继续执行其他的handleObj.handler事件监听器的</span></span><span class="line">                    <span class="comment">// stopImmediatePropagation可以看后面其与stopPropagation区别的一段说明,这是DOM3的事件API方法</span></span><span class="line">                    <span class="keyword">if</span> ( event.isImmediatePropagationStopped() ) &#123;</span><span class="line">                        <span class="keyword">break</span>;</span><span class="line">                    &#125;</span><span class="line">                &#125;</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// result: This attribute contains the last value returned by an event handler that was triggered by this event, unless the value was undefined.</span></span><span class="line">        <span class="keyword">return</span> event.result;</span><span class="line">    &#125;,</span><span class="line"></span><span class="line">    props: <span class="string">"altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY originalTarget pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which"</span>.split(<span class="string">" "</span>),</span><span class="line"></span><span class="line">    fix: <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><span class="line">        <span class="comment">// 如果event[ expando ]为true，则说明当前event对象已经被修复(或者是一个jQuery.Event对象)，可以直接返回</span></span><span class="line">        <span class="keyword">if</span> ( event[ expando ] ) &#123;</span><span class="line">            <span class="keyword">return</span> event;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// store a copy of the original event object</span></span><span class="line">        <span class="comment">// and "clone" to set read-only properties</span></span><span class="line">        <span class="keyword">var</span> originalEvent = event;</span><span class="line">        event = jQuery.Event( originalEvent );</span><span class="line"></span><span class="line">        <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="keyword">this</span>.props.length, prop; i; ) &#123;</span><span class="line">            prop = <span class="keyword">this</span>.props[ --i ];</span><span class="line">            event[ prop ] = originalEvent[ prop ];</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// event.target: The DOM element that initiated the event.</span></span><span class="line">        <span class="comment">// Fix target property, if necessary</span></span><span class="line">        <span class="keyword">if</span> ( !event.target ) &#123;</span><span class="line">            event.target = event.srcElement || <span class="built_in">document</span>; <span class="comment">// Fixes #1925 where srcElement might not be defined either</span></span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// check if target is a textnode (safari)</span></span><span class="line">        <span class="keyword">if</span> ( event.target.nodeType === <span class="number">3</span> ) &#123;</span><span class="line">            event.target = event.target.parentNode;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// relatedTarget: The other DOM element involved in the event, if any.</span></span><span class="line">        <span class="comment">// For mouseout, indicates the element being entered; for mousein, indicates the element being exited.</span></span><span class="line">        <span class="comment">// Add relatedTarget, if necessary</span></span><span class="line">        <span class="keyword">if</span> ( !event.relatedTarget &amp;&amp; event.fromElement ) &#123;</span><span class="line">            event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// DOM 2事件模型规范:</span></span><span class="line">        <span class="comment">// clientX, clientY</span></span><span class="line">        <span class="comment">// These properties specify the X and Y coordinates of the mouse pointer, relative to the client area of the browser window. Note that these coordinates do not take document scrolling into account. Defined for mouse events.</span></span><span class="line"></span><span class="line">        <span class="comment">// 不直接pageX/Y的浏览器，如IE中，有clientX/Y这二个属性，通过这2个值和scroll的位置计算pageX/Y值：</span></span><span class="line">        <span class="comment">// clientX, clientY</span></span><span class="line">        <span class="comment">// The X and Y coordinates, relative to the web browser page, at which the event occurred.</span></span><span class="line"></span><span class="line">        <span class="comment">// 支持pageX/Y的浏览器，则直接使用这二个属性：</span></span><span class="line">        <span class="comment">// pageX, pageY</span></span><span class="line">        <span class="comment">// The X and Y coordinates, relative to the web browser page, at which the event occurred. Note that these coordinates are relative to the top-level page, not to any enclosing layers.</span></span><span class="line"></span><span class="line">        <span class="comment">// pageX/Y这二个属性在drag事件中最常用到</span></span><span class="line">        <span class="comment">// pageX: The mouse position relative to the left edge of the document.</span></span><span class="line">        <span class="comment">// pageY: The mouse position relative to the top edge of the document.</span></span><span class="line">        <span class="comment">// Calculate pageX/Y if missing and clientX/Y available</span></span><span class="line">        <span class="keyword">if</span> ( event.pageX == <span class="literal">null</span> &amp;&amp; event.clientX != <span class="literal">null</span> ) &#123;</span><span class="line">            <span class="keyword">var</span> doc = <span class="built_in">document</span>.documentElement, body = <span class="built_in">document</span>.body;</span><span class="line">            event.pageX = event.clientX + (doc &amp;&amp; doc.scrollLeft || body &amp;&amp; body.scrollLeft || <span class="number">0</span>) - (doc &amp;&amp; doc.clientLeft || body &amp;&amp; body.clientLeft || <span class="number">0</span>);</span><span class="line">            event.pageY = event.clientY + (doc &amp;&amp; doc.scrollTop  || body &amp;&amp; body.scrollTop  || <span class="number">0</span>) - (doc &amp;&amp; doc.clientTop  || body &amp;&amp; body.clientTop  || <span class="number">0</span>);</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// event.which: For key or button events, this attribute indicates the specific button or key that was pressed.</span></span><span class="line">        <span class="comment">// Add which for key events</span></span><span class="line">        <span class="keyword">if</span> ( !event.which &amp;&amp; ((event.charCode || event.charCode === <span class="number">0</span>) ? event.charCode : event.keyCode) ) &#123;</span><span class="line">            event.which = event.charCode || event.keyCode;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)</span></span><span class="line">        <span class="keyword">if</span> ( !event.metaKey &amp;&amp; event.ctrlKey ) &#123;</span><span class="line">            event.metaKey = event.ctrlKey;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// event.button是DOM 2级别标准事件模型中事件的只读属性，0代表鼠标左键，1代表中键，2代表右键:</span></span><span class="line">        <span class="comment">// During mouse events caused by the depression or release of a mouse button, button is used to indicate which mouse button changed state. The values for button range from zero to indicate the left button of the mouse, one to indicate the middle button if present, and two to indicate the right button. For mice configured for left handed use in which the button actions are reversed the values are instead read from right to left.</span></span><span class="line">        <span class="comment">// Netscape 6.0 uses the values 1, 2, and 3 instead of 0, 1, and 2. This is fixed in Netscape 6.1.</span></span><span class="line">        <span class="comment">// 在IE中，没有event.which属性，并且其event.button的值也与标准不同：1代表左键，4代表中键，2代表右键，并且event.button只在onmousedown，onmousemove和onmouseup这三个事件中才有值的，其他的如click事件都为0。</span></span><span class="line">        <span class="comment">// 非IE浏览器中，event.which: For keyboard and mouse events, which specifies which key or mouse button was pressed or released. For keyboard events, this property contains the character encoding of the key that was pressed. For mouse events, it contains 1, 2, or 3, indicating the left, middle, or right buttons.</span></span><span class="line">        <span class="comment">// jQuery使用event.which，并且用1, 2, 3分指鼠标的左键，中键，右键</span></span><span class="line">        <span class="comment">// Add which for click: 1 === left; 2 === middle; 3 === right</span></span><span class="line">        <span class="comment">// Note: button is not normalized, so don't use it</span></span><span class="line">        <span class="keyword">if</span> ( !event.which &amp;&amp; event.button !== <span class="literal">undefined</span> ) &#123;</span><span class="line">            <span class="comment">// 修复IE中event.which，在IE中event.button的值：1代表左键，2代表右键，4代表中键</span></span><span class="line">            event.which = (event.button &amp; <span class="number">1</span> ? <span class="number">1</span> : ( event.button &amp; <span class="number">2</span> ? <span class="number">3</span> : ( event.button &amp; <span class="number">4</span> ? <span class="number">2</span> : <span class="number">0</span> ) ));</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="keyword">return</span> event;</span><span class="line">    &#125;,</span><span class="line"></span><span class="line">    <span class="comment">// Deprecated, use jQuery.guid instead</span></span><span class="line">    guid: <span class="number">1E8</span>,</span><span class="line"></span><span class="line">    <span class="comment">// Deprecated, use jQuery.proxy instead</span></span><span class="line">    proxy: jQuery.proxy,</span><span class="line"></span><span class="line"><span class="comment">// should notice difference of add/setup and teardown/remove in special event.</span></span><span class="line"><span class="comment">// http://brandonaaron.net/blog/2009/03/26/special-events</span></span><span class="line">    <span class="comment">// http://brandonaaron.net/blog/2009/06/4/jquery-edge-new-special-event-hooks</span></span><span class="line">    <span class="comment">// http://brandonaaron.net/blog/2010/02/25/special-events-the-changes-in-1-4-2</span></span><span class="line">    <span class="comment">// jQuery.event.special对象定义，此处定义了ready/live/beforeunload三个属性</span></span><span class="line">    <span class="comment">// 后面还定义了mouseenter/mouseleave/submit/change/focusin/focusout六个属性，用于处理一些事件的浏览器兼容性问题和事件冒泡问题</span></span><span class="line">    special: &#123;</span><span class="line">        ready: &#123;</span><span class="line">            <span class="comment">// Make sure the ready event is setup</span></span><span class="line">            setup: jQuery.bindReady,</span><span class="line">            teardown: jQuery.noop</span><span class="line">        &#125;,</span><span class="line"></span><span class="line">        live: &#123;</span><span class="line">            add: <span class="function"><span class="keyword">function</span>(<span class="params"> handleObj </span>) </span>&#123;</span><span class="line">                <span class="comment">// 调用jQuery.event.add()方法，传入在jQuery.fn.live()方法中设置的handleObj.origType，并且使用liveHandler覆盖handleObj.handler</span></span><span class="line">                <span class="comment">// 将origType绑定到live事件的context对象上，事件监听器则为liveHandler</span></span><span class="line">                jQuery.event.add( <span class="keyword">this</span>, handleObj.origType, jQuery.extend(&#123;&#125;, handleObj, &#123;<span class="attr">handler</span>: liveHandler&#125;) );</span><span class="line">            &#125;,</span><span class="line"></span><span class="line">            <span class="comment">// 参考jQuery.event.remove()方法中的说明</span></span><span class="line">            remove: <span class="function"><span class="keyword">function</span>(<span class="params"> handleObj </span>) </span>&#123;</span><span class="line">                <span class="keyword">var</span> remove = <span class="literal">true</span>,</span><span class="line">                    <span class="comment">// 从origType中获取实际的事件类型</span></span><span class="line">                    type = handleObj.origType.replace(rnamespaces, <span class="string">""</span>);</span><span class="line"></span><span class="line">                <span class="comment">// 当前的remove()方法是以elem作为调用对象执行的，此处this指向.live()方法中的context</span></span><span class="line">                jQuery.each( jQuery.data(<span class="keyword">this</span>, <span class="string">"events"</span>).live || [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><span class="line">                    <span class="comment">// 当调用jQuery.fn.die(type)，并且不传入事件监听器fn时，则删除jquery对象上的elemData.events.live属性，并不移除在.live()方法的context上绑定的事件监听器</span></span><span class="line">                    <span class="keyword">if</span> ( type === <span class="keyword">this</span>.origType.replace(rnamespaces, <span class="string">""</span>) ) &#123;</span><span class="line">                        remove = <span class="literal">false</span>;</span><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><span class="line">                    &#125;</span><span class="line">                &#125;);</span><span class="line"></span><span class="line">                <span class="keyword">if</span> ( remove ) &#123;</span><span class="line">                    <span class="comment">// 如果以jQuery.fn.die(type, fn)形式调用到当前remove方法，则会同时移除context上type类型和live类型对应fn事件监听器</span></span><span class="line">                    jQuery.event.remove( <span class="keyword">this</span>, handleObj.origType, liveHandler );</span><span class="line">                &#125;</span><span class="line">            &#125;</span><span class="line"></span><span class="line">        &#125;,</span><span class="line"></span><span class="line">        beforeunload: &#123;</span><span class="line">            setup: <span class="function"><span class="keyword">function</span>(<span class="params"> data, namespaces, eventHandle </span>) </span>&#123;</span><span class="line">                <span class="comment">// We only want to do this special case on windows</span></span><span class="line">                <span class="keyword">if</span> ( <span class="keyword">this</span>.setInterval ) &#123;</span><span class="line">                    <span class="comment">// beforeunload事件类型只能绑定在window对象上</span></span><span class="line">                    <span class="keyword">this</span>.onbeforeunload = eventHandle;</span><span class="line">                &#125;</span><span class="line"></span><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><span class="line">            &#125;,</span><span class="line">            teardown: <span class="function"><span class="keyword">function</span>(<span class="params"> namespaces, eventHandle </span>) </span>&#123;</span><span class="line">                <span class="keyword">if</span> ( <span class="keyword">this</span>.onbeforeunload === eventHandle ) &#123;</span><span class="line">                    <span class="keyword">this</span>.onbeforeunload = <span class="literal">null</span>;</span><span class="line">                &#125;</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>在jQuery.event.remove(elem, types, handler, pos)方法中，事件监听器的移除操作是由handler.guid值决定的，而不是handler的名字决定的，结合utilities部分的jQuery.proxy()方法说明如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><span class="line">    $.<span class="built_in">console</span>.log(<span class="string">'fn1'</span>);</span><span class="line">    $.<span class="built_in">console</span>.log(fn1.guid);</span><span class="line">&#125;;</span><span class="line"><span class="keyword">var</span> fn2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><span class="line">    $.<span class="built_in">console</span>.log(<span class="string">'fn2'</span>);</span><span class="line">    $.<span class="built_in">console</span>.log(fn2.guid);</span><span class="line">&#125;;</span><span class="line"></span><span class="line"><span class="comment">// fn1代理fn2，也可以说是fn2代理fn1，这个没有关系</span></span><span class="line">jQuery.proxy(fn1, fn2);</span><span class="line">$(<span class="string">'body'</span>).click(fn1).click();</span><span class="line">$(<span class="string">'body'</span>).click(fn2).click();</span><span class="line"></span><span class="line"><span class="comment">// 因为fn1和fn2都使用了fn1的guid，所以在移除fn1时，会将fn2绑定的事件监听器也一起移除，反之亦然</span></span><span class="line"><span class="comment">// $('body').unbind('click', fn1);</span></span><span class="line"></span><span class="line"><span class="comment">// 如果修改了fn2的guid值，则使用unbind将无法达到移除事件监听器的目的，jQuery.event.remove实际上是根据传进来的handler.guid控制事件监听器删除的</span></span><span class="line">fn2.guid = jQuery.guid++;</span><span class="line"><span class="comment">// 因为fn2的guid发生了变化，下面的这个操作实际上并不会从body上移除fn1和fn2的这2个事件监听器，因为那二个事件监听器的guid是使用fn1的guid进行控制的</span></span><span class="line">$(<span class="string">'body'</span>).unbind(<span class="string">'click'</span>, fn2);</span></pre></td></tr></table></figure>
<p>定义从elem上移除绑定事件的方法removeEvent，在这个方法中处理了浏览器的兼容性：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> removeEvent = <span class="built_in">document</span>.removeEventListener ?</span><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"> elem, type, handle </span>) </span>&#123;</span><span class="line">        elem.removeEventListener( type, handle, <span class="literal">false</span> );</span><span class="line">    &#125; :</span><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"> elem, type, handle </span>) </span>&#123;</span><span class="line">        elem.detachEvent( <span class="string">"on"</span> + type, handle );</span><span class="line">    &#125;;</span></pre></td></tr></table></figure></p>
<p><a href="http://api.jquery.com/category/events/event-object/" target="_blank" rel="noopener">jQuery.Event</a>对象构造方法定义，jQuery自定义了一个event对象，模拟实现W3C标准的<a href="http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html" target="_blank" rel="noopener">DOM 3级别事件模型</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery.Event = <span class="function"><span class="keyword">function</span>(<span class="params"> src </span>) </span>&#123;</span><span class="line">    <span class="comment">// Allow instantiation without the 'new' keyword</span></span><span class="line">    <span class="comment">// 如果当前对象有preventDefault属性，则此时的this关键字已经指向jQuery.Event对象，因为jQuery帮助new创建了jQuery.Event(src)</span></span><span class="line">    <span class="keyword">if</span> ( !<span class="keyword">this</span>.preventDefault ) &#123;</span><span class="line">        <span class="comment">// 如果当前对象(注意此时的this关键字代表jQuery这个方法对象)没有preventDefault属性，表示jQuery.Event()方法被调用</span></span><span class="line">        <span class="comment">// 便于构造函数调用，不需要使用new关键字</span></span><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> jQuery.Event( src );</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="comment">// Event object</span></span><span class="line">    <span class="keyword">if</span> ( src &amp;&amp; src.type ) &#123;</span><span class="line">        <span class="keyword">this</span>.originalEvent = src;</span><span class="line">        <span class="keyword">this</span>.type = src.type;</span><span class="line">    <span class="comment">// Event type</span></span><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><span class="line">        <span class="keyword">this</span>.type = src;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="comment">// 重写了事件event发生的时间戳</span></span><span class="line">    <span class="comment">// timeStamp is buggy for some events on Firefox(#3843)</span></span><span class="line">    <span class="comment">// So we won't rely on the native value</span></span><span class="line">    <span class="keyword">this</span>.timeStamp = now();</span><span class="line"></span><span class="line">    <span class="comment">// 利用event[ expando ]标记event已经被修复，这个标识符在事件trigger时会用于判断event是否已经被修复</span></span><span class="line">    <span class="comment">// Mark it as fixed</span></span><span class="line">    <span class="keyword">this</span>[ expando ] = <span class="literal">true</span>;</span><span class="line">&#125;;</span><span class="line"></span><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnFalse</span>(<span class="params"></span>) </span>&#123;</span><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><span class="line">&#125;</span><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnTrue</span>(<span class="params"></span>) </span>&#123;</span><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>jQuery.Event.prototype原型链定义，参考W3C中<a href="http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/Overview.html" target="_blank" rel="noopener">DOM 3级别的标准事件模型</a>和<a href="http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/" target="_blank" rel="noopener">DOM 2级别的标准事件模型</a>说明。</p>
<p>DOM 3级别标准事件模型中关于事件默认行为和可取消默认行为的事件说明:</p>
<p>###Default actions and cancelable events</p>
<blockquote>
<p>Implementations may have a default action associated with an event type. An example is the [HTML 4.01] form element. When the user submits the form (e.g. by pressing on a submit button), the event {&quot;<a href="http://www.w3.org/2001/xml-events&quot;" target="_blank" rel="noopener">http://www.w3.org/2001/xml-events&quot;</a>, &quot;submit&quot;} is dispatched to the element and the default action for this event type is generally to send a request to a Web server with the parameters from the form.</p>
<p>The default actions are not part of the DOM Event flow. Before invoking a default action, the implementation must first dispatch the event as described in the DOM event flow.</p>
<p>A cancelable event is an event associated with a default action which is allowed to be canceled during the DOM event flow. At any phase during the event flow, the triggered event listeners have the option of canceling the default action or allowing the default action to proceed. In the case of the hyperlink in the browser, canceling the action would have the result of not activating the hyperlink. Not all events defined in this specification are cancelable events.</p>
<p>Different implementations will specify their own default actions, if any, associated with each event. The DOM Events specification does not attempt to specify these actions.</p>
<p>This specification does not provide mechanisms for accessing default actions or adding new ones.</p>
</blockquote>
<p>可取消默认行为的事件有：<strong>submit表单提交，链接转向，鼠标事件(mousemove事件除外，click/mousedown/mouseup/mouseout/mouseover)，DOMActivate</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-Event-initEvent</span></span><span class="line">jQuery.Event.prototype = &#123;</span><span class="line">    <span class="comment">// preventDefault: If an event is cancelable, the preventDefault method is used to signify that the event is to be canceled, meaning any default action normally taken by the implementation as a result of the event will not occur. If, during any stage of event flow, the preventDefault method is called the event is canceled. Any default action associated with the event will not occur. Calling this method for a non-cancelable event has no effect. Once preventDefault has been called it will remain in effect throughout the remainder of the event's propagation. This method may be used during any stage of event flow.</span></span><span class="line">    preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><span class="line">        <span class="keyword">this</span>.isDefaultPrevented = returnTrue;</span><span class="line"></span><span class="line">        <span class="keyword">var</span> e = <span class="keyword">this</span>.originalEvent;</span><span class="line">        <span class="keyword">if</span> ( !e ) &#123;</span><span class="line">            <span class="keyword">return</span>;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// if preventDefault exists run it on the original event</span></span><span class="line">        <span class="keyword">if</span> ( e.preventDefault ) &#123;</span><span class="line">            e.preventDefault();</span><span class="line">        &#125;</span><span class="line">        <span class="comment">// otherwise set the returnValue property of the original event to false (IE)</span></span><span class="line">        e.returnValue = <span class="literal">false</span>;</span><span class="line">    &#125;,</span><span class="line">    <span class="comment">// stopPropagation: The stopPropagation method is used prevent further propagation of an event during event flow. If this method is called by any EventListener the event will cease propagating through the tree. The event will complete dispatch to all listeners on the current EventTarget before event flow stops. This method may be used during any stage of event flow.</span></span><span class="line">    stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><span class="line">        <span class="keyword">this</span>.isPropagationStopped = returnTrue;</span><span class="line"></span><span class="line">        <span class="keyword">var</span> e = <span class="keyword">this</span>.originalEvent;</span><span class="line">        <span class="keyword">if</span> ( !e ) &#123;</span><span class="line">            <span class="keyword">return</span>;</span><span class="line">        &#125;</span><span class="line">        <span class="comment">// 如果原始事件(被存在临时变量originalEvent中)存在.stopPropagation()方法，则调用之</span></span><span class="line">        <span class="comment">// if stopPropagation exists run it on the original event</span></span><span class="line">        <span class="keyword">if</span> ( e.stopPropagation ) &#123;</span><span class="line">            e.stopPropagation();</span><span class="line">        &#125;</span><span class="line">        <span class="comment">// 对于IE，因为其事件模型没有按标准事件模型进行实现，而是定义了一个.cancelBubble属性，将其置为true，阻止事件向上冒泡传递</span></span><span class="line">        <span class="comment">// otherwise set the cancelBubble property of the original event to true (IE)</span></span><span class="line">        e.cancelBubble = <span class="literal">true</span>;</span><span class="line">    &#125;,</span><span class="line">    <span class="comment">// 关于stopImmediatePropagation见后面单独一节的说明,在当前1.4.2版本中这个方法其实还没有使用</span></span><span class="line">    stopImmediatePropagation: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><span class="line">        <span class="keyword">this</span>.isImmediatePropagationStopped = returnTrue;</span><span class="line">        <span class="keyword">this</span>.stopPropagation();</span><span class="line">    &#125;,</span><span class="line">    isDefaultPrevented: returnFalse,</span><span class="line">    isPropagationStopped: returnFalse,</span><span class="line">    isImmediatePropagationStopped: returnFalse</span><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>jQuery.event相关的一些特殊事件定义，因为在jQuery 1.3版本中，jQuery.fn.live()方法不能完全代理以下事件类型：blur, focus, mouseenter, mouseleave, change and submit，这个也有事件如change因为浏览器差异常的原因，在当前jQuery 1.4.2版本中，都做了修复。在W3C的<a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html" target="_blank" rel="noopener">DOM 2标准事件模型</a>中，blur/focus/load/unload这四个事件类型不支持事件冒泡，同时也不支持使用preventDefault()方法取消默认行为(更多信息可查阅javascript权威指南第五版表17-3说明)。</p>
<p>但是在W3C标准中另外提供了二个事件类型叫<a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-Event-initUIEvent" target="_blank" rel="noopener">DOMFocusIn和DOMFocusOut</a>，而这二个事件则是支持事件冒泡的。Firefox与其他浏览器实现了这2个事件类型，但是IE实现了focusin和focusout二个事件类型，并且也支持事件冒泡。jQuery团队采用了IE的二个事件类型名称focusin和focusout，在此基础上，实现了blur/focus事件代理机制，这其中IE是在focusin/focusout事件冒泡时触发事件监听器，其他浏览器其实是在blur/focus的事件捕获阶段触发事件监听器。</p>
<p>在IE中<a href="http://msdn.microsoft.com/en-us/library/ms536945(v=VS.85" target="_blank" rel="noopener">mouseenter</a>.aspx)和mouseleave这2个事件类型也不支持事件冒泡，但是mouseover和mouseout在IE中却是支持事件冒泡的，同blur/focus类似处理，使mouseenter和mouseleave借mouseover和mouseout这2个事件类型，实现事件代理。</p>
<p>IE支持的事件列表及事件说明：<a href="http://msdn.microsoft.com/en-us/library/ms533051(v=VS.85).aspx" target="_blank" rel="noopener">http://msdn.microsoft.com/en-us/library/ms533051(v=VS.85).aspx</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Checks if an event happened on an element within another element</span></span><span class="line"><span class="comment">// Used in jQuery.event.special.mouseenter and mouseleave handlers</span></span><span class="line"><span class="keyword">var</span> withinElement = <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><span class="line"></span><span class="line">    <span class="comment">// 检查当前鼠标移动时发生的mouseover/mouseout事件，是否在mouseenter/mouseleave所绑定的对象内部移动</span></span><span class="line">    <span class="comment">// jQuery在这里是很好的利用event.relatedTarget属性，因为在鼠标移动的过程中会涉及event.target/currentTarget之外，mouseover/mouseout还会多一个事件属性即event.relatedTarget，通过判断此relatedTarget是否为mouseenter/mouseleave事件绑定对象的子节点，如果不是其子节点或者对象本身，则触发事件监听器</span></span><span class="line">    <span class="comment">// event.relatedTarget对于mouseout而言，是指鼠标在离开当前元素，即将进入的下一个元素，对于mouseover则是指鼠标进入另一个元素，即将离开的元素</span></span><span class="line">    <span class="comment">// For mouseout, indicates the element being entered; for mousein, indicates the element being exited.</span></span><span class="line">    <span class="comment">// Event.relatedTarget: For mouseover events, this is the document node that the mouse left when it moved over the target. For mouseout events, it is the node that the mouse entered when leaving the target. It is undefined for other types of events.</span></span><span class="line"></span><span class="line">    <span class="comment">// Check if mouse(over|out) are still within the same parent element</span></span><span class="line">    <span class="keyword">var</span> parent = event.relatedTarget;</span><span class="line"></span><span class="line">    <span class="comment">// 关于Firefox中的这个异常，可参考以下二个链接中的bug报告，此问题在firefox3.6 beta1版本之后修复</span></span><span class="line">    <span class="comment">// https://bugzilla.mozilla.org/show_bug.cgi?id=208427</span></span><span class="line">    <span class="comment">// http://code.google.com/p/fbug/issues/detail?id=2075</span></span><span class="line">    <span class="comment">// 本地的测试页面： ../test_js/firefox_xul_bug.html</span></span><span class="line">    <span class="comment">// Firefox sometimes assigns relatedTarget a XUL element</span></span><span class="line">    <span class="comment">// which we cannot access the parentNode property of</span></span><span class="line">    <span class="keyword">try</span> &#123;</span><span class="line">        <span class="comment">// 在DOM树往上追溯时，document.parent为null</span></span><span class="line">        <span class="comment">// 另外在Chrome中，当鼠标从DIV内移到DIV本身的margin中时，event.relatedTarget也为null，在IE和Firefox中此时event.relatedTarget是: [object HTMLHtmlElement]</span></span><span class="line">        <span class="comment">// Traverse up the tree</span></span><span class="line">        <span class="keyword">while</span> ( parent &amp;&amp; parent !== <span class="keyword">this</span> ) &#123;</span><span class="line">            parent = parent.parentNode;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// 在发生mouseover/mouseout事件时，其relatedTarget已经不在mouseenter和mouseleave事件所绑定的对象范围内，触发其事件监听器</span></span><span class="line">        <span class="comment">// 在Chrome中，虽然鼠标移到margin上时，其relatedTarget为null，但仍然符合判断parent !== this，会触发事件监听器</span></span><span class="line">        <span class="keyword">if</span> ( parent !== <span class="keyword">this</span> ) &#123;</span><span class="line">            <span class="comment">// 在handleObj.handler.apply( this, arguments )调用时触发当前方法withinElement()运行，其中arguments[0]就是jQuery修改过的event对象，其中包含一个event.data属性，是jQuery.event.add(elem, type, handler, data)的第4个参数，此处即event.data为mouseenter或者是mouseleave</span></span><span class="line">            <span class="comment">// set the correct event type</span></span><span class="line">            event.type = event.data;</span><span class="line"></span><span class="line">            <span class="comment">// handle event if we actually just moused on to a non sub-element</span></span><span class="line">            jQuery.event.handle.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><span class="line">        &#125;</span><span class="line"></span><span class="line">    <span class="comment">// assuming we've left the element since we most likely mousedover a xul element</span></span><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123; &#125;</span><span class="line">&#125;,</span><span class="line"></span><span class="line"><span class="comment">// 下面这个方法应该没有用处，事件代理.live()方法已经使用liveMap对象转换mouseenter/mouseleave事件类型为mouseover/mouseout事件类型</span></span><span class="line"><span class="comment">// In case of event delegation, we only need to rename the event.type,</span></span><span class="line"><span class="comment">// liveHandler will take care of the rest.</span></span><span class="line">delegate = <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><span class="line">    event.type = event.data;</span><span class="line">    jQuery.event.handle.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><span class="line">&#125;;</span><span class="line"></span><span class="line"><span class="comment">// Create mouseenter and mouseleave events</span></span><span class="line">jQuery.each(&#123;</span><span class="line">    mouseenter: <span class="string">"mouseover"</span>,</span><span class="line">    mouseleave: <span class="string">"mouseout"</span></span><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"> orig, fix </span>) </span>&#123;</span><span class="line">    <span class="comment">// 为jQuery.event.special添加了2个属性mouseenter/mouseleave</span></span><span class="line">    jQuery.event.special[ orig ] = &#123;</span><span class="line">        setup: <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>) </span>&#123;</span><span class="line">            <span class="comment">// 此处代码有问题，一般的事件绑定不会传入data到此处，只有通过.bind(type, data, fn)方法将data传进来，如：</span></span><span class="line">            <span class="comment">// $('div p:first').bind('mouseenter', &#123;selector: ''&#125;, function()&#123;&#125;)，这样会绑定delegate()方法作为事件监听器，这样绑定却没有将mouseover/mouseout绑定到liveHandler()上，所以代码运行只有mouseover/mouseout的效果，没有实现mouseenter/mouseleave事件类型</span></span><span class="line">            <span class="comment">// 其实因为.live()方法里已经将mouseenter/mouseleave方法通过liveMap对象映身到mouseover/mouseout上去，并绑定事件监听器liveHandler()，跟此处代码并无关系</span></span><span class="line">            <span class="comment">// 所以此处代码其实可以直接写为：jQuery.event.add( this, fix, withinElement, orig );</span></span><span class="line"></span><span class="line">            <span class="comment">// mouseenter/mouseleave事件通过mouseover/mouseout事件上绑定withinElement()作为事件监听器，在withinElement()方法中去触发mouseenter/mouseleave事件欲绑定的事件监听器</span></span><span class="line">            jQuery.event.add( <span class="keyword">this</span>, fix, data &amp;&amp; data.selector ? delegate : withinElement, orig );</span><span class="line">        &#125;,</span><span class="line">        teardown: <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>) </span>&#123;</span><span class="line">            jQuery.event.remove( <span class="keyword">this</span>, fix, data &amp;&amp; data.selector ? delegate : withinElement );</span><span class="line">        &#125;</span><span class="line">    &#125;;</span><span class="line">&#125;);</span><span class="line"></span><span class="line"><span class="comment">// Although all events are subject to the capturing phase of event propagation, not all types of events bubble: for example, it does not make sense for a submit event to propagate up the document beyond the &lt;form&gt; element to which it is directed.</span></span><span class="line"><span class="comment">// 表单提交一直冒泡到DOM根节点其实毫无意义，只要冒泡到事件发生时的&lt;form&gt;对象即可，所以事件代理时的context应该选择form对象</span></span><span class="line"><span class="comment">// 在Firefox和Chrome中submit事件都支持事件冒泡，因此不存在jQuery.event.special.submit对象</span></span><span class="line"><span class="comment">// submit delegation</span></span><span class="line"><span class="keyword">if</span> ( !jQuery.support.submitBubbles ) &#123;</span><span class="line"></span><span class="line">    <span class="comment">// 参考jQuery.support.submitBubbles说明</span></span><span class="line">    jQuery.event.special.submit = &#123;</span><span class="line">        setup: <span class="function"><span class="keyword">function</span>(<span class="params"> data, namespaces </span>) </span>&#123;</span><span class="line">            <span class="keyword">if</span> ( <span class="keyword">this</span>.nodeName.toLowerCase() !== <span class="string">"form"</span> ) &#123;</span><span class="line">                <span class="comment">// 为form对象绑定一个click事件，并加入specialSubmit命名空间</span></span><span class="line">                jQuery.event.add(<span class="keyword">this</span>, <span class="string">"click.specialSubmit"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> e </span>) </span>&#123;</span><span class="line">                    <span class="keyword">var</span> elem = e.target, type = elem.type;</span><span class="line"></span><span class="line">                    <span class="comment">// 如果被点击的elem是submit/image组件，并且该组件位于form表单之中，则触发表单提交</span></span><span class="line">                    <span class="keyword">if</span> ( (type === <span class="string">"submit"</span> || type === <span class="string">"image"</span>) &amp;&amp; jQuery( elem ).closest(<span class="string">"form"</span>).length ) &#123;</span><span class="line">                        <span class="keyword">return</span> trigger( <span class="string">"submit"</span>, <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><span class="line">                    &#125;</span><span class="line">                &#125;);</span><span class="line"></span><span class="line">                <span class="comment">// 为form对象绑定一个keypress事件，并加入specialSubmit命名空间</span></span><span class="line">                jQuery.event.add(<span class="keyword">this</span>, <span class="string">"keypress.specialSubmit"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> e </span>) </span>&#123;</span><span class="line">                    <span class="keyword">var</span> elem = e.target, type = elem.type;</span><span class="line"></span><span class="line">                    <span class="comment">// 当按键为回车键，回车时位于text input组件或者password input组件中，并且该组件位于form表单之中，则触发表单提交</span></span><span class="line">                    <span class="keyword">if</span> ( (type === <span class="string">"text"</span> || type === <span class="string">"password"</span>) &amp;&amp; jQuery( elem ).closest(<span class="string">"form"</span>).length &amp;&amp; e.keyCode === <span class="number">13</span> ) &#123;</span><span class="line">                        <span class="keyword">return</span> trigger( <span class="string">"submit"</span>, <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><span class="line">                    &#125;</span><span class="line">                &#125;);</span><span class="line"></span><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><span class="line">            &#125;</span><span class="line">        &#125;,</span><span class="line"></span><span class="line">        teardown: <span class="function"><span class="keyword">function</span>(<span class="params"> namespaces </span>) </span>&#123;</span><span class="line">            jQuery.event.remove( <span class="keyword">this</span>, <span class="string">".specialSubmit"</span> );</span><span class="line">        &#125;</span><span class="line">    &#125;;</span><span class="line"></span><span class="line">&#125;</span><span class="line"></span><span class="line"><span class="comment">// change事件只对input/textarea/select元素生效，其中select/checkbox/radio在值被改变后立即触发相应的事件监听器，其他的如textfield/textarea则延时到对象失去焦点时生效</span></span><span class="line"><span class="comment">// IE中的change事件不支持事件冒泡，Firefox和Chrome中change事件支持事件冒泡，下面的这部分代码其实是针对IE重新实现change事件的监听，但目前这份代码实现有些小问题，如: http://dev.jquery.com/ticket/6686</span></span><span class="line"><span class="comment">// change delegation, happens here so we have bind.</span></span><span class="line"><span class="keyword">if</span> ( !jQuery.support.changeBubbles ) &#123;</span><span class="line"></span><span class="line">    <span class="keyword">var</span> formElems = <span class="regexp">/textarea|input|select/i</span>,</span><span class="line"></span><span class="line">    changeFilters,</span><span class="line"></span><span class="line">    getVal = <span class="function"><span class="keyword">function</span>(<span class="params"> elem </span>) </span>&#123;</span><span class="line">        <span class="keyword">var</span> type = elem.type, val = elem.value;</span><span class="line"></span><span class="line">        <span class="comment">// 获取radio/checkbox是否被选中，val为true/false</span></span><span class="line">        <span class="keyword">if</span> ( type === <span class="string">"radio"</span> || type === <span class="string">"checkbox"</span> ) &#123;</span><span class="line">            val = elem.checked;</span><span class="line"></span><span class="line">        <span class="comment">// 如果是multi-select，则被选中的的option标记为true，反之为false，用中划线"-"，将这些true/false按顺序拼成字符串</span></span><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( type === <span class="string">"select-multiple"</span> ) &#123;</span><span class="line">            val = elem.selectedIndex &gt; <span class="number">-1</span> ?</span><span class="line">                jQuery.map( elem.options, <span class="function"><span class="keyword">function</span>(<span class="params"> elem </span>) </span>&#123;</span><span class="line">                    <span class="keyword">return</span> elem.selected;</span><span class="line">                &#125;).join(<span class="string">"-"</span>) :</span><span class="line">                <span class="string">""</span>;</span><span class="line"></span><span class="line">        <span class="comment">// 如果是select单选组件，val取被被选中的option的index位置</span></span><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( elem.nodeName.toLowerCase() === <span class="string">"select"</span> ) &#123;</span><span class="line">            val = elem.selectedIndex;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="keyword">return</span> val;</span><span class="line">    &#125;,</span><span class="line"></span><span class="line">    testChange = <span class="function"><span class="keyword">function</span> <span class="title">testChange</span>(<span class="params"> e </span>) </span>&#123;</span><span class="line">        <span class="keyword">var</span> elem = e.target, data, val;</span><span class="line"></span><span class="line">        <span class="comment">// 对于readonly的元素和非input/textarea/select元素不作检查</span></span><span class="line">        <span class="keyword">if</span> ( !formElems.test( elem.nodeName ) || elem.readOnly ) &#123;</span><span class="line">            <span class="keyword">return</span>;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// 获取当前元素对应缓存中"_change_data"所对应的值</span></span><span class="line">        data = jQuery.data( elem, <span class="string">"_change_data"</span> );</span><span class="line">        val = getVal(elem);</span><span class="line"></span><span class="line">        <span class="comment">// 当前元素没有失去焦点，或者元素类型不是radio，将元素通过getVal(elem)获取到的值记入此元素的缓存对象中</span></span><span class="line">        <span class="comment">// the current data will be also retrieved by beforeactivate</span></span><span class="line">        <span class="keyword">if</span> ( e.type !== <span class="string">"focusout"</span> || elem.type !== <span class="string">"radio"</span> ) &#123;</span><span class="line">            jQuery.data( elem, <span class="string">"_change_data"</span>, val );</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// 当前元素在缓存中没有_change_data对应的值，或者值没有发生变化，则中断方法</span></span><span class="line">        <span class="keyword">if</span> ( data === <span class="literal">undefined</span> || val === data ) &#123;</span><span class="line">            <span class="keyword">return</span>;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// val !== data，触发事件监听器</span></span><span class="line">        <span class="keyword">if</span> ( data != <span class="literal">null</span> || val ) &#123;</span><span class="line">            e.type = <span class="string">"change"</span>;</span><span class="line">            <span class="keyword">return</span> jQuery.event.trigger( e, <span class="built_in">arguments</span>[<span class="number">1</span>], elem );</span><span class="line">        &#125;</span><span class="line">    &#125;;</span><span class="line"></span><span class="line">    jQuery.event.special.change = &#123;</span><span class="line">        filters: &#123;</span><span class="line">            <span class="comment">// 当元素失去焦点时，马上调用testChange()方法检查元素值是否发生变化，并且在发生变化时触发事件监听器</span></span><span class="line">            focusout: testChange,</span><span class="line"></span><span class="line">            click: <span class="function"><span class="keyword">function</span>(<span class="params"> e </span>) </span>&#123;</span><span class="line">                <span class="keyword">var</span> elem = e.target, type = elem.type;</span><span class="line"></span><span class="line">                <span class="comment">// 对于radio/checkbox/select上发生的change事件，立即调用testChange()方法检查元素的值是否发生变化，有变化则通过testChange()方法触发事件监听器</span></span><span class="line">                <span class="keyword">if</span> ( type === <span class="string">"radio"</span> || type === <span class="string">"checkbox"</span> || elem.nodeName.toLowerCase() === <span class="string">"select"</span> ) &#123;</span><span class="line">                    <span class="keyword">return</span> testChange.call( <span class="keyword">this</span>, e );</span><span class="line">                &#125;</span><span class="line">            &#125;,</span><span class="line"></span><span class="line">            <span class="comment">// keydown和keyup是比较底层的事件类型，keydown先于keypress事件发生，参考按键事件的相关说明</span></span><span class="line">            <span class="comment">// Change has to be called before submit</span></span><span class="line">            <span class="comment">// Keydown will be called before keypress, which is used in submit-event delegation</span></span><span class="line">            keydown: <span class="function"><span class="keyword">function</span>(<span class="params"> e </span>) </span>&#123;</span><span class="line">                <span class="keyword">var</span> elem = e.target, type = elem.type;</span><span class="line"></span><span class="line">                <span class="comment">// 13是回车链，32是空格键</span></span><span class="line">                <span class="comment">// 当回车键按下，并且不是在textarea中按下的回车键</span></span><span class="line">                <span class="keyword">if</span> ( (e.keyCode === <span class="number">13</span> &amp;&amp; elem.nodeName.toLowerCase() !== <span class="string">"textarea"</span>) ||</span><span class="line">                    <span class="comment">// 在radio/checkbox上按下空格键(选中/取消选中)</span></span><span class="line">                    (e.keyCode === <span class="number">32</span> &amp;&amp; (type === <span class="string">"checkbox"</span> || type === <span class="string">"radio"</span>)) ||</span><span class="line">                    <span class="comment">// 多选select组件上有任何按键操作都会进行testChange()检查</span></span><span class="line">                    type === <span class="string">"select-multiple"</span> ) &#123;</span><span class="line">                    <span class="keyword">return</span> testChange.call( <span class="keyword">this</span>, e );</span><span class="line">                &#125;</span><span class="line">            &#125;,</span><span class="line"></span><span class="line">            <span class="comment">// 在DOM 2级别事件说明中(http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-eventgroupings-htmlevents)，对于change事件的说明如下：</span></span><span class="line">            <span class="comment">// change: The change event occurs when a control loses the input focus and its value has been modified since gaining focus. This event is valid for INPUT, SELECT, and TEXTAREA. element. ( * Bubbles: Yes * Cancelable: No * Context Info: None )</span></span><span class="line">            <span class="comment">// 如上说明，那么change事件应该是在focusout之后检查其与原始值相比是否发生变化，并且事件只持冒泡，但IE中的change事件不支持冒泡</span></span><span class="line">            <span class="comment">// 在一个multi-select上绑定一个jQuery.fn.change(fn)事件监听器，IE8上如果用按键进行选择时，会延迟一步触发change事件，在其他浏览器上正常，其他的浏览器change事件支持冒泡，不会调用jQuery.event.special.change这部分代码，可查看后面的例子</span></span><span class="line">            <span class="comment">// 要解决这个问题，需要为IE多监听一个keyup事件，下面部分代码不是jQuery的源码</span></span><span class="line">            <span class="comment">// add keyup filter for IE8 select-multiple</span></span><span class="line">            keyup: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><span class="line">                <span class="keyword">var</span> elem = e.target, type = elem.type;</span><span class="line">                <span class="keyword">if</span> (type == <span class="string">"select-multiple"</span>) &#123;</span><span class="line">                    <span class="keyword">return</span> testChange.call(<span class="keyword">this</span>, e);</span><span class="line">                &#125;</span><span class="line">            &#125;,</span><span class="line"></span><span class="line">            <span class="comment">// IE中支持&lt;a href="http://msdn.microsoft.com/en-us/library/ms536791(VS.85).aspx"&gt;onbeforeactive event&lt;/a&gt;，此事件类型发生位置：onbeforeeditfocus -&gt; onbeforeactivate -&gt; onactivate -&gt; onfocusin -&gt; onfocus，可以用此事件将元素在发生变化之前将其原来的值记录到此元素对应的缓存中。在按键事件或者鼠标事件发生之后，将元素的当前值与缓存中的值进行比较，判断是否发生改变。</span></span><span class="line">            <span class="comment">// 参考文章：http://www.neeraj.name/2010/01/14/how-jquery-1-4-fixed-rest-of-live-methods.html</span></span><span class="line">            <span class="comment">// Beforeactivate happens also before the previous element is blurred</span></span><span class="line">            <span class="comment">// with this event you can't trigger a change event, but you can store</span></span><span class="line">            <span class="comment">// information/focus[in] is not needed anymore</span></span><span class="line">            beforeactivate: <span class="function"><span class="keyword">function</span>(<span class="params"> e </span>) </span>&#123;</span><span class="line">                <span class="keyword">var</span> elem = e.target;</span><span class="line">                jQuery.data( elem, <span class="string">"_change_data"</span>, getVal(elem) );</span><span class="line">            &#125;</span><span class="line">        &#125;,</span><span class="line"></span><span class="line">        setup: <span class="function"><span class="keyword">function</span>(<span class="params"> data, namespaces </span>) </span>&#123;</span><span class="line">            <span class="keyword">if</span> ( <span class="keyword">this</span>.type === <span class="string">"file"</span> ) &#123;</span><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="keyword">for</span> ( <span class="keyword">var</span> type <span class="keyword">in</span> changeFilters ) &#123;</span><span class="line">                <span class="comment">// 根据jQuery.event.special.change.filters，添加自定义事件</span></span><span class="line">                jQuery.event.add( <span class="keyword">this</span>, type + <span class="string">".specialChange"</span>, changeFilters[type] );</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="comment">// 如果当前元素是input/select/textarea，则返回true，否则返回false</span></span><span class="line">            <span class="comment">// 如果返回true，则通过jQuery.event.add()方法中调用special.setup()方法，将changeFilters中的几个方法以自定义事件的事件监听器绑在当前元素上</span></span><span class="line">            <span class="comment">// 而返回false时，则在jQuery.event.add()方法中，会调用elem.attachEvent()进行事件绑定</span></span><span class="line">            <span class="keyword">return</span> formElems.test( <span class="keyword">this</span>.nodeName );</span><span class="line">        &#125;,</span><span class="line"></span><span class="line">        teardown: <span class="function"><span class="keyword">function</span>(<span class="params"> namespaces </span>) </span>&#123;</span><span class="line">            jQuery.event.remove( <span class="keyword">this</span>, <span class="string">".specialChange"</span> );</span><span class="line"></span><span class="line">            <span class="keyword">return</span> formElems.test( <span class="keyword">this</span>.nodeName );</span><span class="line">        &#125;</span><span class="line">    &#125;;</span><span class="line"></span><span class="line">    changeFilters = jQuery.event.special.change.filters;</span><span class="line">&#125;</span><span class="line"></span><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params"> type, elem, args </span>) </span>&#123;</span><span class="line">    args[<span class="number">0</span>].type = type;</span><span class="line">    <span class="keyword">return</span> jQuery.event.handle.apply( elem, args );</span><span class="line">&#125;</span><span class="line"></span><span class="line"><span class="comment">// 在jQuery中，事件代理是通过.live()实现的，对于非IE浏览器，在其中加入了focusin/focusout二个自定义的特殊事件，当jQuery.event.add()方法运行代码 special.setup.call( elem, data, namespaces, eventHandle ) === false 时，就会通过addEventListener()方法将这里定义的捕获阶段事件监听器handler绑定在elem对象上，此elem为.live()方法的context，默认为document对象，当blur/focus事件发生时，在事件捕获阶段就可以触发context上的handler事件监听器</span></span><span class="line"><span class="comment">// Firefox中document支持focus/blur事件类型，Chrome/IE不支持document上绑定focus/blur事件监听器</span></span><span class="line"><span class="comment">// Create "bubbling" focus and blur events</span></span><span class="line"><span class="keyword">if</span> ( <span class="built_in">document</span>.addEventListener ) &#123;</span><span class="line">    <span class="comment">// 在.live()方法定义中循环types时，会往types中添加focusin/focusout二个事件类型，借助这2个事件类型的special.setup()方法，在事件捕获阶段为focus/blur注册事件监听器到.live()的context，当focus/blur事件发生，在事件捕获阶段触发事件监听器。对于IE，因为本身支持这2个事件类型，是直接用elem.attachEvent()进行事件监听器注册的，在focusin/focusout冒泡到context元素上，就可以触发事件监听器。</span></span><span class="line">    jQuery.each(&#123; <span class="attr">focus</span>: <span class="string">"focusin"</span>, <span class="attr">blur</span>: <span class="string">"focusout"</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"> orig, fix </span>) </span>&#123;</span><span class="line">        jQuery.event.special[ fix ] = &#123;</span><span class="line">            setup: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><span class="line">                <span class="comment">// 事件传播的三过程中，blur/focus/load/unload这4个事件类型不支持最后的冒泡阶段，但是所有事件的第1阶段事件捕获阶段和第2阶段到达目标阶段都是有的</span></span><span class="line">                <span class="comment">// Node.addEventListener( type, listener, useCapture): Registers an event listener for this node. type is a string that specifies the event type minus the "on" prefix (e.g., "click" or "submit"). listener is the event handler function. When triggered, it is invoked with an Event object as its argument. If useCapture is true, this is a capturing event handler. If false or omitted, it is a regular event handler. Returns nothing. DOM Level 2; not supported in IE 4, 5, or 6.</span></span><span class="line">                <span class="comment">// IE中是在focusout/focusin二个支持冒泡的事件类型的帮助下，在jQuery.event.add()方法中的代码elem.attachEvent()将focusout/focusin绑定在context上，在事件冒泡阶段触发绑定在focusout/focusin事件上的监听器，从而实现blur/focus的事件代理</span></span><span class="line">                <span class="comment">// 在其他浏览器中并没有这2种事件类型，所以是通过在blur/focus事件的捕获阶段注册事件监听器实现事件代理</span></span><span class="line">                <span class="keyword">this</span>.addEventListener( orig, handler, <span class="literal">true</span> );</span><span class="line">            &#125;,</span><span class="line">            teardown: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><span class="line">                <span class="keyword">this</span>.removeEventListener( orig, handler, <span class="literal">true</span> );</span><span class="line">            &#125;</span><span class="line">        &#125;;</span><span class="line"></span><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"> e </span>) </span>&#123;</span><span class="line">            <span class="comment">// 因为当前事件监听器是注册在event的捕捉阶段(eventPhase=1)，如果代码执行进入到这里，对应的e.eventPhase肯定是1，处于Event.CAPTURING_PHASE阶段</span></span><span class="line">            <span class="comment">// 在google的Chrome调试时，都很正常，但在firebug中调试时，在Event.AT_TARGET阶段(eventPhase=2)也会进入此块代码，这是不正确的，在事件到达目标阶段时，应该是进入eventHandle这个事件监听器，虽然Firefox实际运行时是进入eventHandle这个监听器里，并且执行的结果也是正常的，只是在firebug中调试过程显示不正常</span></span><span class="line">            <span class="comment">// 所以此处代码需要使用google的Chrome进行调试，事件发生的情况与预期的行为一致，只有在e.eventPhase=1时才会进入到此块代码中</span></span><span class="line">            e = jQuery.event.fix( e );</span><span class="line">            <span class="comment">// fix = focusin or focusout</span></span><span class="line">            e.type = fix;</span><span class="line">            <span class="keyword">return</span> jQuery.event.handle.call( <span class="keyword">this</span>, e );</span><span class="line">        &#125;</span><span class="line">    &#125;);</span><span class="line">&#125;</span></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><span class="line"><span class="comment"> * 下面代码是为了修复jquery中$.event.special.change事件，在IE上该事件还是有较多小问题</span></span><span class="line"><span class="comment"> * 因为不能将代码加入到jQuery.event.special.change.filters中，所以另外以插件形式提供</span></span><span class="line"><span class="comment"> * 利用控件失去焦点从而触发绑定在元素上的change事件，其中click上绑定是为了修复IE6上的change事件需要双击才能触发，keyup是解决IE多选控件中正确触发change事件</span></span><span class="line"><span class="comment"> * Example:</span></span><span class="line"><span class="comment"> * $('#select_multiple').change(function()&#123;alert('changed')&#125;)</span></span><span class="line"><span class="comment"> *		// IE6中需要双击才能发生change事件，利用失去焦点来触发单击事件</span></span><span class="line"><span class="comment"> *		.click($.event.fixChangeForIE)</span></span><span class="line"><span class="comment"> *		// 在IE中如果用键盘选择时，不能正确触发change事件，IE总是在第2次选择时才触发前一次的change事件，所以加一个键盘keyup监听事件</span></span><span class="line"><span class="comment"> *		.keyup($.event.fixChangeForIE);</span></span><span class="line"><span class="comment"> */</span></span><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><span class="line">    $.extend($.event, &#123;</span><span class="line">        fixChangeForIE: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><span class="line">            <span class="keyword">if</span>(!$.support.changeBubbles) &#123;</span><span class="line">                <span class="comment">// 通过下面blur/focus触发IE中的jQuery注册的change事件</span></span><span class="line">                <span class="comment">// 不要在事件处理器里用this.blur();this.focus();操作DOM，而是利用timer往javascript事件队列中添加新事件</span></span><span class="line">                <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><span class="line">                setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;self.blur()&#125;, <span class="number">0</span>);</span><span class="line">                setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;self.focus()&#125;, <span class="number">0</span>);</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line">    &#125;);</span><span class="line">&#125;)(jQuery);</span></pre></td></tr></table></figure>
<p>jQuery.fn.bind()和jQuery.fn.one()这二个事件绑定方法的定义，官方文档对于.bind()/.one()方法中的第1个参数eventType说明：</p>
<blockquote>
<p>Any string is legal for eventType; if the string is not the name of a native JavaScript event, then the handler is bound to a custom event. These events are never called by the browser, but may be triggered manually from other JavaScript code using .trigger() or .triggerHandler().</p>
<p>If the eventType string contains a period (.) character, then the event is namespaced. The period character separates the event from its namespace. For example, in the call .bind(&#39;click.name&#39;, handler), the string click is the event type, and the string name is the namespace. Namespacing allows us to unbind or trigger some events of a type without affecting others. See the discussion of .unbind() for more information.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery.each([<span class="string">"bind"</span>, <span class="string">"one"</span>], <span class="function"><span class="keyword">function</span>(<span class="params"> i, name </span>) </span>&#123;</span><span class="line">    jQuery.fn[ name ] = <span class="function"><span class="keyword">function</span>(<span class="params"> type, data, fn </span>) </span>&#123;</span><span class="line">        <span class="comment">// Handle object literals</span></span><span class="line">        <span class="keyword">if</span> ( <span class="keyword">typeof</span> type === <span class="string">"object"</span> ) &#123;</span><span class="line">            <span class="comment">// .bind( events ): events: A map of one or more JavaScript event types and functions to execute for them.</span></span><span class="line">            <span class="comment">// 如果type是一个object直接量，则遍历type，调用当前方法(bind/one)根据这个object的key/value键值对进行事件的绑定</span></span><span class="line">            <span class="keyword">for</span> ( <span class="keyword">var</span> key <span class="keyword">in</span> type ) &#123;</span><span class="line">                <span class="comment">// 此时bind/one方法中原来的第3个参数fn则被抛弃，在for循环中传入的第4个参数fn其实已经没有再作用</span></span><span class="line">                <span class="keyword">this</span>[ name ](key, data, type[key], fn);</span><span class="line">            &#125;</span><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="keyword">if</span> ( jQuery.isFunction( data ) ) &#123;</span><span class="line">            fn = data;</span><span class="line">            data = <span class="literal">undefined</span>;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// 对于只能触发一次的事件绑定(one)，通过jQuery.proxy()方法代理，在事件触发前先将其unbind</span></span><span class="line">        <span class="keyword">var</span> handler = name === <span class="string">"one"</span> ? jQuery.proxy( fn, <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><span class="line">            <span class="comment">// 从当前元素上移除事件监听器handler(就是当前定义的变量)</span></span><span class="line">            jQuery( <span class="keyword">this</span> ).unbind( event, handler );</span><span class="line">            <span class="comment">// 代理之后的proxy方法最后也是会以当前elem元素的方法调用，所以这里的this仍然是指向当前元素的</span></span><span class="line">            <span class="keyword">return</span> fn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><span class="line">        &#125;) : fn;</span><span class="line"></span><span class="line">        <span class="comment">// 对于unload事件只能触发一次，如果使用.bind()方法来绑定unload类型的事件，则转换成.one()方法绑定</span></span><span class="line">        <span class="keyword">if</span> ( type === <span class="string">"unload"</span> &amp;&amp; name !== <span class="string">"one"</span> ) &#123;</span><span class="line">            <span class="keyword">this</span>.one( type, data, fn );</span><span class="line"></span><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><span class="line">            <span class="comment">// 通过jQuery.event.add()方法为jquery对象匹配的全部DOM元素添加type类型的事件监听器</span></span><span class="line">            <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="keyword">this</span>.length; i &lt; l; i++ ) &#123;</span><span class="line">                jQuery.event.add( <span class="keyword">this</span>[i], type, handler, data );</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// 最后事件绑定完成之后，仍然返回当前的jquery对象，可以方便链式事件绑定和链式操作</span></span><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><span class="line">    &#125;;</span><span class="line">&#125;);</span></pre></td></tr></table></figure>
<p>jQuery.fn.unbind()方法官方文档说明中，详细说明了事件加入命名空间的作用，避免把别的方法添加的事件同时移除掉，摘录部分官方文档说明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#foo'</span>).unbind(<span class="string">'click'</span>);</span></pre></td></tr></table></figure>
<blockquote>
<p>By specifying the click event type, only handlers for that event type will be unbound. This approach can still have negative ramifications if other scripts might be attaching behaviors to the same element, however. Robust and extensible applications typically demand the two-argument version for this reason:</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><span class="line">  alert(<span class="string">'The quick brown fox jumps over the lazy dog.'</span>);</span><span class="line">&#125;;</span><span class="line">$(<span class="string">'#foo'</span>).bind(<span class="string">'click'</span>, handler);</span><span class="line">$(<span class="string">'#foo'</span>).unbind(<span class="string">'click'</span>, handler);</span></pre></td></tr></table></figure>
<blockquote>
<p>By naming the handler, we can be assured that no other functions are caught in the crossfire. Note that the following will not work:</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#foo'</span>).bind(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><span class="line">  alert(<span class="string">'The quick brown fox jumps over the lazy dog.'</span>);</span><span class="line">&#125;);</span><span class="line"></span><span class="line">$(<span class="string">'#foo'</span>).unbind(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><span class="line">  alert(<span class="string">'The quick brown fox jumps over the lazy dog.'</span>);</span><span class="line">&#125;);</span></pre></td></tr></table></figure>
<blockquote>
<p>Even though the two functions are identical in content, they are created separately and so JavaScript is free to keep them as distinct function objects. To unbind a particular handler, we need a reference to that function and not a different one that happens to do the same thing.</p>
</blockquote>
<p>###Using Namespaces</p>
<blockquote>
<p>Instead of maintaining references to handlers in order to unbind them, we can namespace the events and use this capability to narrow the scope of our unbinding actions. As shown in the discussion for the .bind() method, namespaces are defined by using a period (.) character when binding a handler:</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#foo'</span>).bind(<span class="string">'click.myEvents'</span>, handler);</span></pre></td></tr></table></figure>
<p>When a handler is bound in this fashion, we can still unbind it the normal way:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#foo'</span>).unbind(<span class="string">'click'</span>);</span></pre></td></tr></table></figure>
<p>However, if we want to avoid affecting other handlers, we can be more specific:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#foo'</span>).unbind(<span class="string">'click.myEvents'</span>);</span></pre></td></tr></table></figure>
<p>If multiple namespaced handlers are bound, we can unbind them at once:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#foo'</span>).unbind(<span class="string">'click.myEvents.yourEvents'</span>);</span></pre></td></tr></table></figure>
<p>This syntax is similar to that used for CSS class selectors; they are not hierarchical. This method call is thus the same as:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#foo'</span>).unbind(<span class="string">'click.yourEvents.myEvents'</span>);</span></pre></td></tr></table></figure>
<p>We can also unbind all of the handlers in a namespace, regardless of event type:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#foo'</span>).unbind(<span class="string">'.myEvents'</span>);</span></pre></td></tr></table></figure>
<p>It is particularly useful to attach namespaces to event bindings when we are developing plug-ins or otherwise writing code that may interact with other event-handling code in the future.</p>
<p>###Using the Event Object</p>
<blockquote>
<p>The second form of the .unbind() method is used when we wish to unbind a handler from within itself. For example, suppose we wish to trigger an event handler only three times:</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timesClicked = <span class="number">0</span>;</span><span class="line">$(<span class="string">'#foo'</span>).bind(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><span class="line">  alert(<span class="string">'The quick brown fox jumps over the lazy dog.'</span>);</span><span class="line">  timesClicked++;</span><span class="line">  <span class="keyword">if</span> (timesClicked &gt;= <span class="number">3</span>) &#123;</span><span class="line">    $(<span class="keyword">this</span>).unbind(event);</span><span class="line">  &#125;</span><span class="line">&#125;);</span></pre></td></tr></table></figure>
<blockquote>
<p>The handler in this case must take a parameter, so that we can capture the event object and use it to unbind the handler after the third click. The event object contains the context necessary for .unbind() to know which handler to remove. This example is also an illustration of a closure. Since the handler refers to the timesClicked variable, which is defined outside the function, incrementing the variable has an effect even between invocations of the handler.</p>
</blockquote>
<p>jQuery.fn.unbind(). jQuery.fn.delegate()、jQuery.fn.trigger()等方法定义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery.fn.extend(&#123;</span><span class="line">    unbind: <span class="function"><span class="keyword">function</span>(<span class="params"> type, fn </span>) </span>&#123;</span><span class="line">        <span class="comment">// type可能是个event对象，见jQuery( this ).unbind( event, handler)处调用</span></span><span class="line">        <span class="comment">// Handle object literals</span></span><span class="line">        <span class="keyword">if</span> ( <span class="keyword">typeof</span> type === <span class="string">"object"</span> &amp;&amp; !type.preventDefault ) &#123;</span><span class="line">            <span class="keyword">for</span> ( <span class="keyword">var</span> key <span class="keyword">in</span> type ) &#123;</span><span class="line">                <span class="keyword">this</span>.unbind(key, type[key]);</span><span class="line">            &#125;</span><span class="line"></span><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><span class="line">            <span class="comment">// 遍历jquery对象，从匹配到的元素上移除type类型fn事件监听器</span></span><span class="line">            <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="keyword">this</span>.length; i &lt; l; i++ ) &#123;</span><span class="line">                jQuery.event.remove( <span class="keyword">this</span>[i], type, fn );</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// 返回jquery对象本身，便于链式操作</span></span><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><span class="line">    &#125;,</span><span class="line"></span><span class="line">    <span class="comment">// .delegate()方法与.live()方法一样，用于事件代理机制中，但一般来说，因其selector选择器简单而更具效率</span></span><span class="line">    <span class="comment">// .live()方法中this.selector是指被事件代理的元素的选择器</span></span><span class="line">    <span class="comment">// .delegate()方法中this.selector指的却是事件代理后监听器所绑定的元素，即context的选择器，.delegate()方法的第一个参数是指被事件代理的元素，同.live()中的this.selector</span></span><span class="line">    <span class="comment">// 这二个方法在链式操作中也有所区别，.live()方法在.next()/.nextAll()/.children()/.parent()等方法一起作链式操作时会碰到错误：</span></span><span class="line">    <span class="comment">// jQuery("div").find("p").next().live("click", function()&#123;&#125;)，因为最后调用到Sizzle("div p.next()")发生错误</span></span><span class="line">    <span class="comment">// 另外直接传一个DOM节点给jQuery()方法也会同样错误，如jQuery(document.body).live("click", function()&#123;&#125;)，因为jQuery(document.body).selector为空字符串""，在.live()中会引用this.selector给后面Sizzle()使用</span></span><span class="line">    <span class="comment">// 更多关于这二个方法的区别可参考这二篇文章：</span></span><span class="line">    <span class="comment">// http://net.tutsplus.com/tutorials/javascript-ajax/quick-tip-the-difference-between-live-and-delegate/</span></span><span class="line">    <span class="comment">// http://www.learningjquery.com/2010/03/using-delegate-and-undelegate-in-jquery-1-4-2</span></span><span class="line">    delegate: <span class="function"><span class="keyword">function</span>(<span class="params"> selector, types, data, fn </span>) </span>&#123;</span><span class="line">        <span class="comment">// .delegate()方法看上去只是selector与context位置不同而已，但其中的差别却是很多，效率和链式操作性二个问题前面已经有比较说明</span></span><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.live( types, data, fn, selector );</span><span class="line">    &#125;,</span><span class="line"></span><span class="line">    undelegate: <span class="function"><span class="keyword">function</span>(<span class="params"> selector, types, fn </span>) </span>&#123;</span><span class="line">        <span class="keyword">if</span> ( <span class="built_in">arguments</span>.length === <span class="number">0</span> ) &#123;</span><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.unbind( <span class="string">"live"</span> );</span><span class="line"></span><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.die( types, <span class="literal">null</span>, fn, selector );</span><span class="line">        &#125;</span><span class="line">    &#125;,</span><span class="line"></span><span class="line">    <span class="comment">// trigger(type, data)</span></span><span class="line">    <span class="comment">// type: A string containing a JavaScript event type, such as click or submit.</span></span><span class="line">    <span class="comment">// data: An array of additional parameters to pass along to the event handler.</span></span><span class="line">    trigger: <span class="function"><span class="keyword">function</span>(<span class="params"> type, data </span>) </span>&#123;</span><span class="line">        <span class="comment">// Execute all handlers and behaviors attached to the matched elements for the given event type.</span></span><span class="line">        <span class="comment">// 对jquery对象匹配到的全部元素，执行这些元素上绑定指定type类型的事件监听器，并会触发这些事件的默认行为，如提交表单，链接跳转</span></span><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><span class="line">            <span class="comment">// 在每个匹配的节点上调用jQuery.event.trigger()方法，触发事件执行</span></span><span class="line">            jQuery.event.trigger( type, data, <span class="keyword">this</span> );</span><span class="line">        &#125;);</span><span class="line">    &#125;,</span><span class="line"></span><span class="line">    <span class="comment">// To trigger handlers bound via jQuery without also triggering the native event, use .triggerHandler() instead.</span></span><span class="line">    <span class="comment">// 如果只是想触发通过jQuery绑定到对象上的事件监听器，但却不想这些处理器触发默认行为，如单表提交，可使用jQuery.fn.triggerHandler()方法替代jQuery.fn.trigger()</span></span><span class="line">    <span class="comment">// 并且triggerHandler()方法还有以下几个特点，需要注意：</span></span><span class="line">    <span class="comment">// * The .triggerHandler() method does not cause the default behavior of an event to occur (such as a form submission).</span></span><span class="line">    <span class="comment">// * While .trigger() will operate on all elements matched by the jQuery object, .triggerHandler() only affects the first matched element.</span></span><span class="line">    <span class="comment">// * Events created with .triggerHandler() do not bubble up the DOM hierarchy; if they are not handled by the target element directly, they do nothing.</span></span><span class="line">    <span class="comment">// * Instead of returning the jQuery object (to allow chaining), .triggerHandler() returns whatever value was returned by the last handler it caused to be executed. If no handlers are triggered, it returns undefined</span></span><span class="line">    triggerHandler: <span class="function"><span class="keyword">function</span>(<span class="params"> type, data </span>) </span>&#123;</span><span class="line">        <span class="comment">// triggerHandler方法只对jquery对象匹配到的第一个DOM元素生效</span></span><span class="line">        <span class="keyword">if</span> ( <span class="keyword">this</span>[<span class="number">0</span>] ) &#123;</span><span class="line">            <span class="keyword">var</span> event = jQuery.Event( type );</span><span class="line">            <span class="comment">// 事件触发的浏览器默认行为不会被执行</span></span><span class="line">            event.preventDefault();</span><span class="line">            <span class="comment">// 事件传播被中止，不会按DOM节点结构向上冒泡</span></span><span class="line">            event.stopPropagation();</span><span class="line">            jQuery.event.trigger( event, data, <span class="keyword">this</span>[<span class="number">0</span>] );</span><span class="line">            <span class="comment">// 返回结果为最后一个事件监听器的执行结果，如果没有事件监听器被触发，返回undefined</span></span><span class="line">            <span class="keyword">return</span> event.result;</span><span class="line">        &#125;</span><span class="line">    &#125;,</span><span class="line"></span><span class="line">    toggle: <span class="function"><span class="keyword">function</span>(<span class="params"> fn </span>) </span>&#123;</span><span class="line">        <span class="comment">// Save reference to arguments for access in closure</span></span><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>, i = <span class="number">1</span>;</span><span class="line"></span><span class="line">        <span class="comment">// link all the functions, so any of them can unbind this click handler</span></span><span class="line">        <span class="keyword">while</span> ( i &lt; args.length ) &#123;</span><span class="line">            jQuery.proxy( fn, args[ i++ ] );</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.click( jQuery.proxy( fn, <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><span class="line">            <span class="comment">// Figure out which function to execute</span></span><span class="line">            <span class="keyword">var</span> lastToggle = ( jQuery.data( <span class="keyword">this</span>, <span class="string">"lastToggle"</span> + fn.guid ) || <span class="number">0</span> ) % i;</span><span class="line">            jQuery.data( <span class="keyword">this</span>, <span class="string">"lastToggle"</span> + fn.guid, lastToggle + <span class="number">1</span> );</span><span class="line"></span><span class="line">            <span class="comment">// Make sure that clicks stop</span></span><span class="line">            event.preventDefault();</span><span class="line"></span><span class="line">            <span class="comment">// and execute the function</span></span><span class="line">            <span class="keyword">return</span> args[ lastToggle ].apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> ) || <span class="literal">false</span>;</span><span class="line">        &#125;));</span><span class="line">    &#125;,</span><span class="line"></span><span class="line">    <span class="comment">// The .hover() method binds handlers for both mouseenter and mouseleave events. We can use it to simply apply behavior to an element during the time the mouse is within the element.</span></span><span class="line">    <span class="comment">// jQuery.fn.hover()方法是一个便捷方法，主要是控制鼠标进入或者离开某个元素范围时，触发mouseenter和mouseleave这二个事件</span></span><span class="line">    hover: <span class="function"><span class="keyword">function</span>(<span class="params"> fnOver, fnOut </span>) </span>&#123;</span><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.mouseenter( fnOver ).mouseleave( fnOut || fnOver );</span><span class="line">    &#125;</span><span class="line">&#125;);</span></pre></td></tr></table></figure>
<p>jQuery.fn.live()和jQuery.fn.die()方法定义，jQuery官方文档中关于事件代理机制的说明如下：</p>
<p>###Event Delegation</p>
<blockquote>
<p>The .live() method is able to affect elements that have not yet been added to the DOM through the use of event delegation: a handler bound to an ancestor element is responsible for events that are triggered on its descendants. The handler passed to .live() is never bound to an element; instead, .live() binds a special handler to the root of the DOM tree. In our example, when the new element is clicked, the following steps occur:</p>
</blockquote>
<ol>
<li>A click event is generated and passed to the <div> for handling.</div></li>
<li>No handler is directly bound to the <div>, so the event bubbles up the DOM tree.</div></li>
<li>The event bubbles up until it reaches the root of the tree, which is where .live() binds its special handlers by default. As of jQuery 1.4, event bubbling can optionally stop at a DOM element &quot;context&quot;.</li>
<li>The special click handler bound by .live() executes.</li>
<li>This handler tests the target of the event object to see whether it should continue. This test is performed by checking if $(event.target).closest(&#39;.clickme&#39;) is able to locate a matching element.</li>
<li>If a matching element is found, the original handler is called on it.</li>
</ol>
<p>Because the test in step 5 is not performed until the event occurs, elements can be added at any time and still respond to events.</p>
<p>###blur和mouseenter事件代理的绑定和触发过程</p>
<p>jQuery.fn.live(&#39;blur&#39;, fn)方法在Firefox/Chrome中的事件绑定过程：</p>
<ol>
<li>jQuery.fn.live(&#39;blur&#39;, fn)-&gt;jQuery.event.add(elem, &#39;live.blur.input&#39;, fn)-&gt;jQuery.event.special.live.add()-&gt;jQuery.event.add(elem, &#39;blur&#39;, liveHandler)，完成这一系列方法调用之后，已经为context绑定了一个blur非捕获阶段的事件监听器eventHandle，但因为在.live()方法中的types数组被添加了jQuery定义的特殊事件focusout，所以从.live()方法开始产生第2次事件绑定。</li>
<li>jQuery.fn.live(&#39;blur&#39;, fn)-&gt;jQuery.event.add(elem, &#39;live.foucsout.input&#39;, fn)-&gt;jQuery.event.special.live.add()-&gt;jQuery.event.add(elem, &#39;focusout&#39;, liveHandler)-&gt;jQuery.event.special.focusout.setup()-&gt;elem.addEventListener(&#39;blur&#39;, handler, true)，完成第二次的一系列方法调用之后，会为context再绑定一个捕获阶段的事件监听器handler，并且在jQuery(context).data(&#39;events&#39;).focusout中加入handleObj，其handler为liveHandler，其origHandler为传给.live()方法的fn。</li>
</ol>
<p>jQuery.fn.live(&#39;blur&#39;, fn)方法绑定的事件在Firefox/Chrome中的处理过程：</p>
<ol>
<li>handler(e)是由blur事件捕获阶段触发的，e.type=blur，e.eventPhase=1，在handler(e)方法中将e.type设置为focusout。</li>
<li>handler(e)-&gt;jQuery.event.handle(event)</li>
</ol>
<p>在jQuery.event.handle(event)中会根据event.type将jQuery.data(context, &#39;events&#39;)中的handlers取出来，逐一运行其中的handler，前面blur事件捕获阶段的事件监听器handler(e)中已经将event.type设置为focusout，jQuery.data(context, &#39;events&#39;).focusout数组的handleObj.handler包括了liveHandler。</p>
<p>handler(e)-&gt;jQuery.event.handle(event)-&gt;liveHandler(event)-&gt;match.handleObj.origHandler.apply( match.elem, args )，在liveHandler(event)方法中会根据当前事件提供的信息进行检查，找到需要触的发handleObj后逐一调用handleObj.origHandler()。</p>
<p>jQuery.fn.live(&#39;blur&#39;, fn)方法在IE中的事件绑过程第1步与Firefox/Chrome一样：</p>
<ol>
<li>jQuery.fn.live(&#39;blur&#39;, fn)-&gt;jQuery.event.add(elem, &#39;live.blur.input&#39;, fn)-&gt;jQuery.event.special.live.add()-&gt;jQuery.event.add(elem, &#39;blur&#39;, liveHandler)，完成这一系列方法调用之后，已经为context绑定了一个blur非捕获阶段的事件监听器eventHandle，但因为在.live()方法中的types数组被添加了jQuery定义的特殊事件focusout，所以从.live()方法开始产生第2次事件绑定。</li>
<li>在进行focusout事件绑定时，与Firefox/Chrome不同，因为IE中原来就有此事件类型，并且focusout事件支持事件冒泡，jQuery没有在IE中设置jQuery.event.special.focusout对象，所以通过:jQuery.fn.live(&#39;blur&#39;, fn)-&gt;jQuery.event.add(elem, &#39;live.foucsout.input&#39;, fn)-&gt;elem.attachEvent(&#39;onfocusout&#39;, fn, false)直接绑定事件，并且jQuery(context).data(&#39;events&#39;).focusout中加入的handleObj，其handler为liveHandler，其origHandler为传给.live()方法的fn。</li>
</ol>
<p>jQuery.fn.live(&#39;blur&#39;, fn)方法绑定的事件在IE中的处理过程：<br>在IE中，因为focusout事件冒泡阶段触发了context上的eventHandle事件监听器，由eventHandle()调用jQuery.event.handle()，后面的处理方式与Firefox/Chrome一致。</p>
<p>jQuery.fn.live(&#39;mouseenter&#39;, fn)方法调用过程，经过.live()方法之后，.live()方法中的事件监听器被保存在origHandler变量中，另外注意其中type变化：jQuery.fn.live(&#39;mouseenter&#39;, ...)-&gt;jQuery.event.add(elem, &#39;live.mouseover.div&#39;, ...)-&gt;jQuery.event.special.live.add()-&gt;jQuery.event.add(elem, &#39;mouseover&#39;, liveHandler, ...)，最后在.live()方法的context上为mouseover绑定了liveHandler事件监听器(虽然实际是通过eventHandle事件监听器调用jQuery.event.handle()，再在handle()中调用此liveHandler方法的)，也就是说mouseenter的事件代理其实是利用mouseover事件冒泡进行过渡后实现的。</p>
<p>既然mouseenter事件代理是用mouseover事件来实现，那么为mouseenter事件绑定的事件监听器又是如何触发的呢:</p>
<p>因为实际上是在.live()的context对象上绑定了mouseover事件监听器liveHandler()，那么在context上发生的mouseover事件都会触发事件监听器liveHandler()，其中代码的调用过程为：<br>elemData.handle.apply(elem) or eventHandle()-&gt;jQuery.event.handle(event)-&gt;liveHandler(event)-&gt;match.handleObj.origHandler.apply( match.elem, args )，最后将.live()方法提供的事件监听器(origHandler)作为match.elem对象的方法调用，完成事件代理的过程。<br>整个代码处理过程中，最核心的是liveHandler方法中二个.closest()的调用处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> liveMap = &#123;</span><span class="line">    focus: <span class="string">"focusin"</span>,</span><span class="line">    blur: <span class="string">"focusout"</span>,</span><span class="line">    mouseenter: <span class="string">"mouseover"</span>,</span><span class="line">    mouseleave: <span class="string">"mouseout"</span></span><span class="line">&#125;;</span><span class="line"></span><span class="line"><span class="comment">// jQuery.fn.live()方法在很多方面都有缺陷，只适用明确指定selector的jquery对象的调用或者是一些简单场合下的调用，更多说明可参考jQuery.fn.delegate()方法</span></span><span class="line"><span class="comment">// 此方法中的关键代码是在liveHandler中调用jQuery.fn.closest()方法，从event.target及其parents中找到符合事件代理的selector的第一个节点，在此节点上调用事件监听器</span></span><span class="line"><span class="comment">// jQuery.fn.live(): Attach a handler to the event for all elements which match the current selector, now or in the future.</span></span><span class="line">jQuery.each([<span class="string">"live"</span>, <span class="string">"die"</span>], <span class="function"><span class="keyword">function</span>(<span class="params"> i, name </span>) </span>&#123;</span><span class="line">    jQuery.fn[ name ] = <span class="function"><span class="keyword">function</span>(<span class="params"> types, data, fn, origSelector <span class="regexp">/* Internal Use Only */</span> </span>) </span>&#123;</span><span class="line">        <span class="keyword">var</span> type, i = <span class="number">0</span>, match, namespaces, preType,</span><span class="line">            <span class="comment">// 之所以jQuery在源码里说origSelector是内部使用的参数，其实就是给另一个事件代理的方法jQuery.fn.delegate()使用的</span></span><span class="line">            <span class="comment">// .live()和.delegate()方法二者主要区别还是在于执行效率，要看二个方法的调用对象(即jquery对象)哪个能更快的根据其selector来初始化得到这个jquery对象</span></span><span class="line">            <span class="comment">// 而.live()方法的selector是指被事件代理的那些元素，包括将来添加进入DOM中的元素，.delegate()方法正好相反，其selector却是事件代理中事件监听器真正绑定的context对象，这个context对象默认为document，否则也都是比较固定的可以由CSS的#ID和.classname选择器指定的元素，如jQuery("#context")和jQuery(".context")，能更快的初始化jquery对象。</span></span><span class="line">            selector = origSelector || <span class="keyword">this</span>.selector,</span><span class="line">            <span class="comment">// 事件代理的执行环境，在哪个context环境下执行事件代理，如果没有传入origSelect，默认的代理环境为jQuery(document)</span></span><span class="line">            <span class="comment">// context也可以用这种调用方式提供：jQuery(selector, context).live(...)</span></span><span class="line">            context = origSelector ? <span class="keyword">this</span> : jQuery( <span class="keyword">this</span>.context );</span><span class="line"></span><span class="line">        <span class="comment">// 如果没有传入data给事件监听器fn，则第二个参数为事件监听器</span></span><span class="line">        <span class="comment">// 其中需要注意的是这里的第二个参数data和jQuery.fn.trigger()中的data虽然都是作为参数传递给事件监听器fn，但是因为二者使用时间不相同而有本质区别，.live()和.bind()中的data在定义的时候，准备作为事件监听器的参数使用，但事件监听器真正执行的时候，这些定义时的data因为受javascript闭包的影响，值可能已经改变，结果可能并非与期望的一样，使用的时候需要注意，而.trigger()中的data是直接传入之后被即时运行的，不会受到闭包的影响</span></span><span class="line">        <span class="comment">// 一般是极少情况去使用.live()/.bind()方法中的data参数的</span></span><span class="line">        <span class="keyword">if</span> ( jQuery.isFunction( data ) ) &#123;</span><span class="line">            fn = data;</span><span class="line">            data = <span class="literal">undefined</span>;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// 从jquery-1.4.1开始，.live()方法与.bind()方法一样，开始支持用空格分隔的多个事件，同时代理</span></span><span class="line">        types = (types || <span class="string">""</span>).split(<span class="string">" "</span>);</span><span class="line"></span><span class="line">        <span class="keyword">while</span> ( (type = types[ i++ ]) != <span class="literal">null</span> ) &#123;</span><span class="line">            <span class="comment">// rnamespaces = /\.(.*)$/，检查type中是否包括了小数点"."，用于分隔命名空间</span></span><span class="line">            match = rnamespaces.exec( type );</span><span class="line">            namespaces = <span class="string">""</span>;</span><span class="line"></span><span class="line">            <span class="keyword">if</span> ( match )  &#123;</span><span class="line">                <span class="comment">// match[0]为正则/\.(.*)$/匹配到的内容</span></span><span class="line">                namespaces = match[<span class="number">0</span>];</span><span class="line">                <span class="comment">// 移除命名空间后的事件类型type</span></span><span class="line">                type = type.replace( rnamespaces, <span class="string">""</span> );</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="comment">// As of jQuery 1.4.1 the hover event can be specified (mapping to "mouseenter mouseleave").</span></span><span class="line">            <span class="keyword">if</span> ( type === <span class="string">"hover"</span> ) &#123;</span><span class="line">                <span class="comment">// 将mouseenter和mouseleave加入types数组中，用.live()绑定事件监听器到mouseenter和mouseleave上</span></span><span class="line">                types.push( <span class="string">"mouseenter"</span> + namespaces, <span class="string">"mouseleave"</span> + namespaces );</span><span class="line">                <span class="keyword">continue</span>;</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="comment">// 将原来的type存在一个变量preType中，这个变量是为了处理mouseenter/mouseleave这2个特殊事件类型设计的</span></span><span class="line">            preType = type;</span><span class="line"></span><span class="line">            <span class="comment">// liveMap = &#123; focus: "focusin", blur: "focusout", mouseenter: "mouseover", mouseleave: "mouseout" &#125;;</span></span><span class="line">            <span class="comment">// As of jQuery 1.4.1 even focus and blur work with live (mapping to the more appropriate, bubbling, events focusin and focusout).</span></span><span class="line">            <span class="comment">// 将经过liveMap映射之后的事件类型type与前面被分离的namespaces重新组合到一起作为事件类型type</span></span><span class="line">            <span class="keyword">if</span> ( type === <span class="string">"focus"</span> || type === <span class="string">"blur"</span> ) &#123;</span><span class="line">                <span class="comment">// 往types数组中追加focusin/focusout二个事件类型，在while的下次循环中再调用jQuery.event.add()，将focusin/focusout这二个特殊事件类型添加事件监听器</span></span><span class="line">                <span class="comment">// 对于focus/blur这2个事件类型，如果是通过.live()方法绑定事件监听器时，需要额外添加二个事件类型：focusin/focusout，利用这2个事件类型使focus/blur事件冒泡，从而支持事件代理。在IE中原来就有这2个事件类型，所以在jQuery.event.add()中可以通过elem.attachEvent()将事件处理器绑定在elem元素上，而其他浏览器则不支持这2个事件类型，而是在一个if(document.addEventListener)语句里为jQuery.event.special添加了focusin/focusout二个属性，通过jQuery.event.add()方法中special.setup()，在.live()的context上绑定blur/focus冒泡阶段的事件处理器。</span></span><span class="line">                <span class="comment">// 可通过$(document).data('events')查看其中内容</span></span><span class="line">                types.push( liveMap[ type ] + namespaces );</span><span class="line">                type = type + namespaces;</span><span class="line"></span><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><span class="line">                <span class="comment">// 如果.live()方法代理的是mouseenter/mouseleave这二个事件，则将事件类型type转换为mouseover/mouseout这二个支持事件冒泡的事件类型，所以需要将实际上传给.live()方法的事件类型type放到一个变量preType中记下来</span></span><span class="line">                type = (liveMap[ type ] || type) + namespaces;</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="keyword">if</span> ( name === <span class="string">"live"</span> ) &#123;</span><span class="line">                <span class="comment">// bind live handler</span></span><span class="line">                <span class="comment">// 事件代理，.live()真正是将事件绑定在context上，如果context没有指定，就是将.live()绑定在document上，所以后续添加的新节点可以触发通过.live()绑定的事件监听器</span></span><span class="line">                context.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><span class="line">                    <span class="comment">// liveConvert( type, selector )是计算live事件类型(属于自定义的事件类型)，为事件类型type传参给jQuery.event.add()方法</span></span><span class="line">                    <span class="comment">// 在第三个参数中，将.live()方法接收的原始信息一起传递给jQuery.event.add()方法</span></span><span class="line">                    jQuery.event.add( <span class="keyword">this</span>, liveConvert( type, selector ),</span><span class="line">                        &#123; <span class="attr">data</span>: data, <span class="attr">selector</span>: selector, <span class="attr">handler</span>: fn, <span class="attr">origType</span>: type, <span class="attr">origHandler</span>: fn, <span class="attr">preType</span>: preType &#125; );</span><span class="line">                &#125;);</span><span class="line"></span><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><span class="line">                <span class="comment">// name === "die"</span></span><span class="line">                <span class="comment">// unbind live handler</span></span><span class="line">                <span class="comment">// 调用jQuery.fn.unbind()方法，从context上移除代理的事件监听器</span></span><span class="line">                context.unbind( liveConvert( type, selector ), fn );</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><span class="line">    &#125;</span><span class="line">&#125;);</span><span class="line"></span><span class="line"><span class="comment">// 将liveHandler事件监听器绑定在指定的context上(默认为document)，假如是live绑定了一个click事件，那么在document上发生的每个click操作都会触发eventHandle-&gt;jQuery.event.handle-&gt;liveHandler</span></span><span class="line"><span class="comment">// 所以使用了live进行事件绑定，liveHandler方法的调用会非常频繁</span></span><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">liveHandler</span>(<span class="params"> event </span>) </span>&#123;</span><span class="line">    <span class="comment">// liveHandler接收到的event参数是经过jQuery.event.handle()方法中的经过jQuery.event.fix()方法处理之后的仿event对象</span></span><span class="line">    <span class="keyword">var</span> stop, elems = [], selectors = [], args = <span class="built_in">arguments</span>,</span><span class="line">        related, match, handleObj, elem, j, i, l, data,</span><span class="line">        events = jQuery.data( <span class="keyword">this</span>, <span class="string">"events"</span> );</span><span class="line"></span><span class="line">    <span class="comment">// Make sure we avoid non-left-click bubbling in Firefox (#3861)</span></span><span class="line">    <span class="keyword">if</span> ( event.liveFired === <span class="keyword">this</span> || !events || !events.live || event.button &amp;&amp; event.type === <span class="string">"click"</span> ) &#123;</span><span class="line">        <span class="keyword">return</span>;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    event.liveFired = <span class="keyword">this</span>;</span><span class="line"></span><span class="line">    <span class="keyword">var</span> live = events.live.slice(<span class="number">0</span>);</span><span class="line"></span><span class="line">    <span class="comment">// live是个变长数组，通过这个for循环查找出符合event.type的全部.live()方法调用对象的selectors</span></span><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; live.length; j++ ) &#123;</span><span class="line">        handleObj = live[j];</span><span class="line"></span><span class="line">        <span class="comment">// 将符合当前发生的事件类型与当时使用jQuery.fn.live绑定的origType进行比较</span></span><span class="line">        <span class="comment">// 如果事件类型一致，将当时jQuery.fn.live方法调用的jquery对象的selector放到selectors数组中</span></span><span class="line">        <span class="keyword">if</span> ( handleObj.origType.replace( rnamespaces, <span class="string">""</span> ) === event.type ) &#123;</span><span class="line">            selectors.push( handleObj.selector );</span><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><span class="line">            <span class="comment">// 将不符合当前发生event事件的事件类型的handleObj从live数组中删除</span></span><span class="line">            live.splice( j--, <span class="number">1</span> );</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="comment">// 此句代码是事件代理机制中最关键的部分，.closest()返回一个数组，其第一个参数selectors可以是一个数组。从jquery对象匹配的DOM对象本身开始，找到context为止，返回第一个符合selector的元素。对于每个匹配的DOM节点，只能往上追溯找到0个或者1个匹配的元素，不过如果selectors是个数组的话，就可能返回多个匹配的结果</span></span><span class="line">    <span class="comment">// jQuery.fn.closest(selectors, context): Get the first ancestor element that matches the selectors, beginning at the current element and progressing up through the DOM tree.</span></span><span class="line">    <span class="comment">// currentTarget: The document node that is currently handling this event. During capturing and bubbling, this is different than target. Defined for all events.</span></span><span class="line">    <span class="comment">// 从节点event.target本身开始沿DOM树往上扫描到event.currentTarget(事件正在处理的对象)为止，返回在这个范围内符合selectors的元素，可包括event.target节点本身</span></span><span class="line">    match = jQuery( event.target ).closest( selectors, event.currentTarget );</span><span class="line"></span><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>, l = match.length; i &lt; l; i++ ) &#123;</span><span class="line">        <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; live.length; j++ ) &#123;</span><span class="line">            handleObj = live[j];</span><span class="line"></span><span class="line">            <span class="comment">// 再一次遍历live数组，此时的live数组已经在上一次live的遍历中剔除了不符合event.type事件类型的handleObj</span></span><span class="line">            <span class="comment">// 此次遍历时，比较handleObj和match[i]二个对象的selector</span></span><span class="line">            <span class="keyword">if</span> ( match[i].selector === handleObj.selector ) &#123;</span><span class="line">                elem = match[i].elem;</span><span class="line">                related = <span class="literal">null</span>;</span><span class="line"></span><span class="line">                <span class="comment">// 为mouseenter和mouseleave事件作特殊处理</span></span><span class="line">                <span class="comment">// Those two events require additional checking</span></span><span class="line">                <span class="keyword">if</span> ( handleObj.preType === <span class="string">"mouseenter"</span> || handleObj.preType === <span class="string">"mouseleave"</span> ) &#123;</span><span class="line">                    <span class="comment">// 参考前面句.closest()方法的分析说明</span></span><span class="line">                    <span class="comment">// handleObj.selector是.live()方法调用对象的selector选择器，或者是用.delegate()传进来的origSelector</span></span><span class="line">                    <span class="comment">// 从event.relatedTarget开始向上扫描整个DOM树，返回第一个符合handleObj.selector选择器的对象</span></span><span class="line">                    <span class="comment">// 如果鼠标是在elem元素的范围之内移动，并触发的mouseover/mouseout事件，这种情况下related元素就会是elem元素本身</span></span><span class="line">                    related = jQuery( event.relatedTarget ).closest( handleObj.selector )[<span class="number">0</span>];</span><span class="line">                &#125;</span><span class="line"></span><span class="line">                <span class="comment">// related为null，不是mouseenter/mouseleave事件代理</span></span><span class="line">                <span class="comment">// related为undefined，是mouseenter/mouseleave事件代理，但没有匹配到handleObj.selector，说明当前event.relatedTarget肯定不是在elem范围内，触发mouseenter/mouseleave事件监听器</span></span><span class="line">                <span class="keyword">if</span> ( !related || related !== elem ) &#123;</span><span class="line">                    elems.push(&#123; <span class="attr">elem</span>: elem, <span class="attr">handleObj</span>: handleObj &#125;);</span><span class="line">                &#125;</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>, l = elems.length; i &lt; l; i++ ) &#123;</span><span class="line">        match = elems[i];</span><span class="line">        event.currentTarget = match.elem;</span><span class="line">        event.data = match.handleObj.data;</span><span class="line">        event.handleObj = match.handleObj;</span><span class="line"></span><span class="line">        <span class="comment">// To stop further handlers from executing after one bound using .live(), the handler must return false.</span></span><span class="line">        <span class="comment">// Calling .stopPropagation() will not accomplish this.</span></span><span class="line">        <span class="comment">// 使用.live()方法绑定的事件监听器，实际上是将eventHandle事件监听器是以origType事件类型方式被绑定在DOM树根节点之上(或者是指定的context上)</span></span><span class="line">        <span class="comment">// 而随.live()方法指定的origHandler事件监听器，通过jQuery.event.special.add()方法的特殊处理，将handleObj.handler置为当前方法liveHandler，最后context上指定的origType类型事件发生并调用eventHandle()-&gt;jQuery.event.handle()-&gt;liveHandler()这些方法，而在当前的liveHandler方法中才真正去调用原来的origHandler方法</span></span><span class="line">        <span class="comment">// 所以使用.stopPropagation()阻止冒泡是没有意义的，也是没有效果的</span></span><span class="line">        <span class="keyword">if</span> ( match.handleObj.origHandler.apply( match.elem, args ) === <span class="literal">false</span> ) &#123;</span><span class="line">            stop = <span class="literal">false</span>;</span><span class="line">            <span class="keyword">break</span>;</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="keyword">return</span> stop;</span><span class="line">&#125;</span><span class="line"></span><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">liveConvert</span>(<span class="params"> type, selector </span>) </span>&#123;</span><span class="line">    <span class="keyword">return</span> <span class="string">"live."</span> + (type &amp;&amp; type !== <span class="string">"*"</span> ? type + <span class="string">"."</span> : <span class="string">""</span>) + selector.replace(<span class="regexp">/\./g</span>, <span class="string">""</span>).replace(<span class="regexp">/ /g</span>, <span class="string">"&amp;"</span>);</span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>为jQuery.fn对象添加事件绑定和触发的快捷方法，如jQuery.fn.click()</p>
<blockquote>
<p>The jQuery library provides shortcut methods for binding the standard event types, such as .click() for .bind(&#39;click&#39;). A description of each can be found in the discussion of its shortcut method: blur, focus, focusin, focusout, load, resize, scroll, unload, click, dblclick, mousedown, mouseup, mousemove, mouseover, mouseout, mouseenter, mouseleave, change, select, submit, keydown, keypress, keyup, error</p>
</blockquote>
<p>jQuery中事件被绑定到element上的方法调用过程:<br>jQuery.fn.click(fn) -&gt; jQuery.fn.bind(&quot;click&quot;, fn) -&gt; jQuery.event.add(elem, &quot;click&quot;, fn) -&gt; elem.addEventListener(&quot;click&quot;, eventHandle, false)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery.each( (<span class="string">"blur focus focusin focusout load resize scroll unload click dblclick "</span> +</span><span class="line">    <span class="string">"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave "</span> +</span><span class="line">    <span class="string">"change select submit keydown keypress keyup error"</span>).split(<span class="string">" "</span>), <span class="function"><span class="keyword">function</span>(<span class="params"> i, name </span>) </span>&#123;</span><span class="line"></span><span class="line">    <span class="comment">// 为jQuery.fn对象添加click/keydown/keyup等方法，便于事件绑定或者触发指定事件(如果没有传入参数)</span></span><span class="line">    <span class="comment">// Handle event binding</span></span><span class="line">    jQuery.fn[ name ] = <span class="function"><span class="keyword">function</span>(<span class="params"> fn </span>) </span>&#123;</span><span class="line">        <span class="comment">// 如果有参数传入，则调用jQuery.fn.bind()方法进行事件绑定</span></span><span class="line">        <span class="comment">// 如果没有参数传入，则直接用jQuery.fn.trigger()方法触发绑定的指定类型(name)的事件</span></span><span class="line">        <span class="keyword">return</span> fn ? <span class="keyword">this</span>.bind( name, fn ) : <span class="keyword">this</span>.trigger( name );</span><span class="line">    &#125;;</span><span class="line"></span><span class="line">    <span class="comment">// 设置jQuery.attrFn.click. jQuery.attrFn.keydown、jQuery.attrFn.keyup等属性值为true</span></span><span class="line">    <span class="comment">// 通过attrFn，可以利用jQuery.fn.attr或者jQuery.attr这二个方法设置这些属性: if ( pass &amp;&amp; name in jQuery.attrFn ) &#123; return jQuery(elem)[name](value); &#125;</span></span><span class="line">    <span class="keyword">if</span> ( jQuery.attrFn ) &#123;</span><span class="line">        jQuery.attrFn[ name ] = <span class="literal">true</span>;</span><span class="line">    &#125;</span><span class="line">&#125;);</span><span class="line"></span><span class="line"><span class="comment">// Prevent memory leaks in IE</span></span><span class="line"><span class="comment">// Window isn't included so as not to unbind existing unload events</span></span><span class="line"><span class="comment">// More info:</span></span><span class="line"><span class="comment">//  - http://isaacschlueter.com/2006/10/msie-memory-leaks/</span></span><span class="line"><span class="keyword">if</span> ( <span class="built_in">window</span>.attachEvent &amp;&amp; !<span class="built_in">window</span>.addEventListener ) &#123;</span><span class="line">    <span class="built_in">window</span>.attachEvent(<span class="string">"onunload"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><span class="line">        <span class="keyword">for</span> ( <span class="keyword">var</span> id <span class="keyword">in</span> jQuery.cache ) &#123;</span><span class="line">            <span class="keyword">if</span> ( jQuery.cache[ id ].handle ) &#123;</span><span class="line">                <span class="comment">// Try/Catch is to handle iframes being unloaded, see #4280</span></span><span class="line">                <span class="keyword">try</span> &#123;</span><span class="line">                    <span class="comment">// 移除jQuery.cache中所有的事件绑定</span></span><span class="line">                    jQuery.event.remove( jQuery.cache[ id ].handle.elem );</span><span class="line">                &#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line">    &#125;);</span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>W3C中DOM 3级别标准事件模型中关于文档的事件流及事件流中三个阶段的说明，并附图如下。</p>
<p>###DOM event flow</p>
<blockquote>
<p>The DOM event flow is the process through which the event originates from the DOM Events implementation and is dispatched into a tree. Each event has an event target, a targeted node in the case of the DOM Event flow, toward which the event is dispatched by the DOM Events implementation.</p>
</blockquote>
<p>###Event Phases</p>
<blockquote>
<p>The event is dispatched following a path from the root of the tree to this target node. It can then be handled locally at the target node level or from any target ancestor higher in the tree. The event dispatching (also called event propagation) occurs in three phases:</p>
</blockquote>
<ol>
<li>The capture phase: the event is dispatched on the target ancestors from the root of the tree to the direct parent of the target node.</li>
<li>The target phase: the event is dispatched on the target node.</li>
<li>The bubbling phase: the event is dispatched on the target ancestors from the direct parent of the target node to the root of the tree.</li>
</ol>
<p>更多关于事件模型的说明，以及在IE中的事件模型缺陷，可以查看ppk的几篇文章，还有篇中文文章：</p>
<ol>
<li><a href="http://www.quirksmode.org/js/this.html" target="_blank" rel="noopener">http://www.quirksmode.org/js/this.html</a></li>
<li><a href="http://www.quirksmode.org/js/events_order.html" target="_blank" rel="noopener">http://www.quirksmode.org/js/events_order.html</a></li>
<li><a href="http://www.quirksmode.org/js/events_advanced.html" target="_blank" rel="noopener">http://www.quirksmode.org/js/events_advanced.html</a></li>
<li><a href="http://www.bgscript.com/archives/369" target="_blank" rel="noopener">DOM 2级别的标准事件模型与IE的事件模型区别</a></li>
</ol>
<p><img src="http://www.w3.org/TR/2011/WD-DOM-Level-3-Events-20110531/images/eventflow.png" alt="3.1 Event dispatch and DOM event flow"></p>
<p>###custom special event</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// multiple click example</span></span><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><span class="line">    $(<span class="string">'#multiclick_exmple'</span>)</span><span class="line">    .bind(<span class="string">'multiclick'</span>, &#123; <span class="attr">threshold</span>: <span class="number">3</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><span class="line">        alert(<span class="string">'Clicked three times!'</span>);</span><span class="line">    &#125;)</span><span class="line">    .bind(<span class="string">'multiclick'</span>, &#123; <span class="attr">threshold</span>: <span class="number">5</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><span class="line">        alert(<span class="string">'Clicked 5 times!'</span>);</span><span class="line">    &#125;);</span><span class="line">&#125;);</span></pre></td></tr></table></figure>
<p>###mouseenter and mouseleave</p>
<p>在下面这个div.out.overout元素中测试mouseover/mouseout事件，可注意控制台中的输出，鼠标在此元素内部移动而触发的mouseover/mouseout事件的状况，如鼠标移动经过子元素P:first再进入到div.out.overout元素时，会先触发一个此元素div.out.overout上的mouseout事件，此时event.relatedTarget为鼠标即将进入的元素，即其本身div.out.overout，然后再一次触发其mouseover事件，此时event.relatedTarget为鼠标之前所离开的元素，即当前元素中的子元素P:first。</p>
<p>从例子中可观察知道，鼠标在元素内部移动时，会非常频繁的触发mouseover/mouseout事件，当鼠标进出元素时只需要触发一次事件监听器，mouseover/mouseout事件特性就不符合要求了，jQuery采用了IE中的二个事件类型名称，即mouseenter/mouseleave。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> livemouseenter = $(<span class="string">'.livemouseenter'</span>);</span><span class="line">livemouseenter.live(<span class="string">'mouseenter'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><span class="line">    $(<span class="keyword">this</span>).css(<span class="string">'background'</span>, <span class="string">'#fdd'</span>);</span><span class="line">    $.<span class="built_in">console</span>.log(<span class="string">"mouseentered into element: "</span>, <span class="keyword">this</span>);</span><span class="line">&#125;);</span><span class="line">$(<span class="built_in">document</span>).delegate(<span class="string">'.livemouseenter'</span>, <span class="string">'mouseleave'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><span class="line">    $(<span class="keyword">this</span>).css(<span class="string">'background'</span>, <span class="string">'#ff0'</span>);</span><span class="line">    $.<span class="built_in">console</span>.log(<span class="string">"mouseleaved from element: "</span>, <span class="keyword">this</span>);</span><span class="line">&#125;);</span></pre></td></tr></table></figure>
<p>###stopImmediatePropagation and stopPropagation</p>
<p>说明如下:</p>
<blockquote>
<ul>
<li><p>stopImmediatePropagation 是DOM3引入的事件API,这个方法是用来阻止同组的事件监听器被触发,与Event.stopPropagation()不同的是,这个方法一旦调用,再次调用stopImmediatePropagation这个方法将不会有任何作用.这个方法并不会阻止事件的默认行为,需要用Event.preventDefault()来阻止事件的默认行为.</p>
</li>
<li><p>stopImmediatePropagation 也会与 stopPropagation 方法一样,将阻止事件的冒泡,事件的target的祖先对象将无法获得这个事件,并且在这个元素上绑定的相同事件的其他监听器也将不会被触发,这个与事件组<a href="http://www.w3.org/TR/2006/WD-DOM-Level-3-Events-20060413/events.html#Events-propagation-and-groups" target="_blank" rel="noopener">event group</a>的概念又有关系,所谓immediate就是指在当前对象的事件组中的其他事件监听器将不会触发.</p>
</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> livemouseenter = $(<span class="string">'.livemouseenter'</span>);</span><span class="line">livemouseenter.bind(<span class="string">'mouseenter'</span>, &#123;<span class="attr">selector</span>: <span class="string">'.livemouseenter'</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><span class="line">    $(<span class="keyword">this</span>).css(<span class="string">'background'</span>, <span class="string">'#fdd'</span>);</span><span class="line">    $.<span class="built_in">console</span>.log(<span class="string">"mouseentered into element: "</span>, <span class="keyword">this</span>);</span><span class="line">&#125;);</span><span class="line">$(<span class="built_in">document</span>).delegate(<span class="string">'.livemouseenter'</span>, <span class="string">'mouseleave'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><span class="line">    $(<span class="keyword">this</span>).css(<span class="string">'background'</span>, <span class="string">'#ff0'</span>);</span><span class="line">    $.<span class="built_in">console</span>.log(<span class="string">"mouseleaved from element: "</span>, <span class="keyword">this</span>);</span><span class="line">&#125;);</span></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><span class="line">$(<span class="string">"div.overout"</span>).mouseover(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><span class="line">    $(<span class="string">"p:first"</span>, <span class="keyword">this</span>).text(<span class="string">"mouse over"</span>);</span><span class="line">    $(<span class="string">"p:last"</span>, <span class="keyword">this</span>).text(++i);</span><span class="line">    $(<span class="keyword">this</span>).css(<span class="string">'background'</span>, <span class="string">'#FF6'</span>);</span><span class="line">    $.<span class="built_in">console</span>.log(<span class="string">"mouseover relatedTarget:"</span>, e.relatedTarget);</span><span class="line">&#125;).mouseout(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><span class="line">    $(<span class="string">"p:first"</span>, <span class="keyword">this</span>).text(<span class="string">"mouse out"</span>);</span><span class="line">    $(<span class="keyword">this</span>).css(<span class="string">'background'</span>, <span class="string">'#D6EDFC'</span>);</span><span class="line">    $.<span class="built_in">console</span>.log(<span class="string">"mouseout relatedTarget:"</span>, e.relatedTarget);</span><span class="line">&#125;);</span><span class="line"></span><span class="line"><span class="keyword">var</span> n = <span class="number">0</span>;</span><span class="line">$(<span class="string">"div.enterleave"</span>).mouseenter(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><span class="line">    $(<span class="string">"p:first"</span>, <span class="keyword">this</span>).text(<span class="string">"mouse enter"</span>);</span><span class="line">    $(<span class="string">"p:last"</span>, <span class="keyword">this</span>).text(++n);</span><span class="line">    $(<span class="keyword">this</span>).css(<span class="string">'background'</span>, <span class="string">'#6F6'</span>);</span><span class="line">    $.<span class="built_in">console</span>.log(<span class="string">"mouseenter relatedTarget:"</span> + e.type, e.relatedTarget);</span><span class="line">&#125;).mouseleave(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><span class="line">    $(<span class="string">"p:first"</span>, <span class="keyword">this</span>).text(<span class="string">"mouse leave"</span>);</span><span class="line">    $(<span class="keyword">this</span>).css(<span class="string">'background'</span>, <span class="string">'#FC0'</span>);</span><span class="line">    $.<span class="built_in">console</span>.log(<span class="string">"mouseleave relatedTarget:"</span> + e.type, e.relatedTarget);</span><span class="line">&#125;);</span></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意.live()方法在链式操作中发生的错误</span></span><span class="line"><span class="comment">// $("div").find("p").next().live("click", function()&#123;alert(1)&#125;); // uncaught exception</span></span></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// As of jQuery 1.4.2 duplicate event handlers can be bound to an element instead of being discarded. For example:</span></span><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123; $.<span class="built_in">console</span>.log(<span class="string">"Hello"</span>); &#125;</span><span class="line">$(<span class="string">"#button"</span>).click( test );</span><span class="line">$(<span class="string">"#button"</span>).click( test );</span><span class="line"><span class="comment">// The above will generate two alerts when the button is clicked.</span></span></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><span class="line">    $.<span class="built_in">console</span>.log(<span class="string">'fn1'</span>);</span><span class="line">    $.<span class="built_in">console</span>.log(fn1.guid);</span><span class="line">&#125;;</span><span class="line"><span class="keyword">var</span> fn2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><span class="line">    $.<span class="built_in">console</span>.log(<span class="string">'fn2'</span>);</span><span class="line">    $.<span class="built_in">console</span>.log(fn2.guid);</span><span class="line">&#125;;</span><span class="line"></span><span class="line"><span class="comment">// fn1代理fn2，也可以说是fn2代理fn1，这个没有关系</span></span><span class="line">jQuery.proxy(fn1, fn2);</span><span class="line">$(<span class="string">'body'</span>).click(fn1).click();</span><span class="line">$(<span class="string">'body'</span>).click(fn2).click();</span><span class="line"></span><span class="line"><span class="comment">// 因为fn1和fn2都使用了fn1的guid，所以在移除fn1时，会将fn2绑定的事件监听器也一起移除，反之亦然</span></span><span class="line"><span class="comment">// $('body').unbind('click', fn1);</span></span><span class="line"></span><span class="line"><span class="comment">// 如果修改了fn2的guid值，则使用unbind将无法达到移除事件监听器的目的，jQuery.event.remove实际上是根据传进来的handler.guid控制事件监听器删除的</span></span><span class="line">fn2.guid = jQuery.guid++;</span><span class="line"><span class="comment">// 因为fn2的guid发生了变化，下面的这个操作实际上并不会从body上移除fn1和fn2的这2个事件监听器，因为那二个事件监听器的guid是使用fn1的guid进行控制的</span></span><span class="line">$(<span class="string">'body'</span>).unbind(<span class="string">'click'</span>, fn2);</span></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在IE8中下面这个代码不能准确执行，总是会在延迟一次按键触发，当前版本1.4.2中的jQuery.event.special.change实现有小问题</span></span><span class="line">$(<span class="string">'#test_change_event'</span>).change(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><span class="line">    $.<span class="built_in">console</span>.log($(<span class="keyword">this</span>).val());</span><span class="line">&#125;);</span></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面3篇文章由上到下阅读，了解jQuery的特殊事件类型的设计思想</span></span><span class="line"><span class="comment">// http://brandonaaron.net/blog/2009/03/26/special-events</span></span><span class="line"><span class="comment">// http://brandonaaron.net/blog/2009/06/4/jquery-edge-new-special-event-hooks</span></span><span class="line"><span class="comment">// http://brandonaaron.net/blog/2010/02/25/special-events-the-changes-in-1-4-2</span></span><span class="line"><span class="comment">// http://benalman.com/news/2010/03/jquery-special-events/</span></span><span class="line"><span class="comment">// In jQuery 1.4.2，添加自定义的特殊事件类型</span></span><span class="line">$.event.special.multiclick = &#123;</span><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params"> details </span>) </span>&#123;</span><span class="line">        <span class="comment">// called for each bound handler</span></span><span class="line">        <span class="comment">// 此方法在每次此特殊事件类型的事件绑定时，都会调用，一般都是用来代替掉原来的事件处理方法</span></span><span class="line">        <span class="keyword">var</span> handler   = details.handler,</span><span class="line">            data      = details.data,</span><span class="line">            threshold = data &amp;&amp; data.threshold || <span class="number">1</span>,</span><span class="line">            clicks    = <span class="number">0</span>;</span><span class="line"></span><span class="line">        <span class="comment">// replace the handler</span></span><span class="line">        <span class="comment">// 注意这里将details这个object中的handler属性修改了，原来加在details.handler.guid就被丢掉了，需要在special.add方法执行后，重新添加回去： if ( !handleObj.handler.guid ) &#123; handleObj.handler.guid = handler.guid; &#125;</span></span><span class="line">        details.handler = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><span class="line">            <span class="comment">// increase number of clicks</span></span><span class="line">            <span class="comment">// 因为在multiclick.handler中用$.event.handle.apply( this, arguments )来触发此特殊事件，所以这个匿名方法在click发生时，会一直被调用，如果这个特殊事件类型有多个事件绑定，那么每次点击会多次运行</span></span><span class="line">            clicks += <span class="number">1</span>;</span><span class="line">            <span class="keyword">if</span> ( clicks === threshold ) &#123;</span><span class="line">              <span class="comment">// required number of clicks reached, reset</span></span><span class="line">              clicks = <span class="number">0</span>;</span><span class="line">              <span class="comment">// call the actual supplied handler</span></span><span class="line">              handler.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><span class="line">            &#125;</span><span class="line">        &#125;;</span><span class="line">    &#125;,</span><span class="line"></span><span class="line">    setup: <span class="function"><span class="keyword">function</span>(<span class="params"> data, namespaces </span>) </span>&#123;</span><span class="line">        <span class="comment">// called once per an element</span></span><span class="line">        <span class="comment">// 在当前元素上此特殊事件类型第一次发生时，会调用此方法</span></span><span class="line">        $( <span class="keyword">this</span> ).bind( <span class="string">"click"</span>, $.event.special.multiclick.handler );</span><span class="line">    &#125;,</span><span class="line"></span><span class="line">    teardown: <span class="function"><span class="keyword">function</span>(<span class="params"> namespaces </span>) </span>&#123;</span><span class="line">        <span class="comment">// called once per an element</span></span><span class="line">        <span class="comment">// 在此特殊事件类型的最后一个事件监听器被移除，会调用此方法</span></span><span class="line">        $( <span class="keyword">this</span> ).unbind( <span class="string">"click"</span>, $.event.special.multiclick.handler );</span><span class="line">    &#125;,</span><span class="line"></span><span class="line">    remove: <span class="function"><span class="keyword">function</span>(<span class="params"> details </span>) </span>&#123;</span><span class="line">        <span class="comment">// called for each bound handler</span></span><span class="line">        <span class="comment">// 每个事件监听器删除时，都会调用此方法做一些清理动作</span></span><span class="line">    &#125;,</span><span class="line"></span><span class="line">    handler: <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><span class="line">        <span class="comment">// 指定事件类型，并手动触发特殊类型的事件处理器</span></span><span class="line">        <span class="comment">// set correct event type</span></span><span class="line">        event.type = <span class="string">"multiclick"</span>;</span><span class="line">        <span class="comment">// trigger multiclick handlers</span></span><span class="line">        $.event.handle.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><span class="line">    &#125;</span><span class="line">&#125;;</span><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><span class="line">    $(<span class="string">'#multiclick_exmple'</span>)</span><span class="line">    .bind(<span class="string">'multiclick'</span>, &#123; <span class="attr">threshold</span>: <span class="number">3</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><span class="line">        alert(<span class="string">'Clicked three times!'</span>);</span><span class="line">    &#125;)</span><span class="line">    .bind(<span class="string">'multiclick'</span>, &#123; <span class="attr">threshold</span>: <span class="number">5</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><span class="line">        alert(<span class="string">'Clicked 5 times!'</span>);</span><span class="line">    &#125;);</span><span class="line">&#125;);</span></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#immediate'</span>).bind(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><span class="line">    $.<span class="built_in">console</span>.log(<span class="string">'first'</span>);</span><span class="line">&#125;);</span><span class="line"></span><span class="line">$(<span class="string">'#immediate'</span>).bind(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><span class="line">    $.<span class="built_in">console</span>.log(<span class="string">'second'</span>);</span><span class="line">    e.stopImmediatePropagation();</span><span class="line">&#125;);</span><span class="line"></span><span class="line"><span class="comment">// never trigger this event listener because of event.stopImmediatePropagation()</span></span><span class="line">$(<span class="string">'#immediate'</span>).bind(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><span class="line">    $.<span class="built_in">console</span>.log(<span class="string">'third'</span>);</span><span class="line">&#125;);</span></pre></td></tr></table></figure>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/jquery/2014/07/31/jquery-src-dimensions.html" rel="next" title="jquery-1.4.2 dimensions部分源码分析">
                <i class="fa fa-chevron-left"></i>
                jquery-1.4.2 dimensions部分源码分析
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/jquery/2014/08/01/jquery-src-fx.html" rel="prev" title="jquery-1.4.2 fx部分源码分析">
                <i class="fa fa-chevron-right"></i>
                jquery-1.4.2 fx部分源码分析
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/blog/images/avatar.jpg" alt="yuweijun">
          <p class="site-author-name" itemprop="name">yuweijun</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/blog/archives">
              <span class="site-state-item-count">492</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">categories</span>
              
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/blog/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yuweijun" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/yuweijun" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <p class="post-toc-empty">This post does not have a Table of Contents</p>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-github"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yuweijun</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist.KISS
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>











  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.0.0/jquery.min.js"></script>

  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>

  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>

  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.3.1/velocity.min.js"></script>

  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.3.1/velocity.ui.min.js"></script>


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/blog/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/blog/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
