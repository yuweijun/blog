<!doctype html>




<html class="theme-next mist">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">


















  

<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">






  <link rel="alternate" href="/blog/atom.xml" title="一" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/blog/favicon.ico?v=5.0.1">






<meta name="description" content="java Socket SO_LINGER 设置方法源码9991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027/** * Enable/disable &amp;#123;@link SocketOptions#SO_LINGER">
<meta property="og:type" content="article">
<meta property="og:title" content="tcp 参数 so_linger 说明及测试">
<meta property="og:url" content="http://www.4e00.com/linux/2019/03/27/tcp-option-so-linger.html">
<meta property="og:site_name" content="一">
<meta property="og:description" content="java Socket SO_LINGER 设置方法源码9991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027/** * Enable/disable &amp;#123;@link SocketOptions#SO_LINGER">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://www.4e00.com/blog/img/linux/tcp/tcp-close.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/linux/tcp/solinger/tcp-rst-instead-fin-sock-1.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/linux/tcp/tcp-close-duplicate-segment.svg">
<meta property="og:image" content="http://www.4e00.com/blog/img/linux/tcp/tcp-close-last-ack.svg">
<meta property="og:image" content="http://www.4e00.com/blog/img/linux/tcp/tcpip-state-transition-diagram.png">
<meta property="og:image" content="http://www.4e00.com/blog/img/linux/tcp/tcp-close-last-ack-reuse.svg">
<meta property="og:image" content="http://www.4e00.com/blog/img/linux/tcp/solinger/server-socket-solinger-true-0-java-client.png">
<meta property="og:updated_time" content="2019-05-07T12:22:04.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="tcp 参数 so_linger 说明及测试">
<meta name="twitter:description" content="java Socket SO_LINGER 设置方法源码9991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027/** * Enable/disable &amp;#123;@link SocketOptions#SO_LINGER">
<meta name="twitter:image" content="http://www.4e00.com/blog/img/linux/tcp/tcp-close.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide"},
    fancybox: false,
    motion: false,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://www.4e00.com/blog/linux/2019/03/27/tcp-option-so-linger.html">

  <title> tcp 参数 so_linger 说明及测试 | 一 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/blog/" class="brand" rel="start">
      <span class="site-title">一</span>
    </a>
  </div>
  <p class="site-subtitle">{"type":"编程笔记"}</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      <li class="menu-item menu-item-search">
        <a href="https://www.google.com.hk/search?q=site%3Ahttp://www.4e00.com/blog/" class="popup-trigger">
          <i class="menu-item-icon fa fa-search fa-fw"></i>Search
        </a>
      </li>
    </ul>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                tcp 参数 so_linger 说明及测试
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-03-27T14:17:06+08:00" content="2019-03-27">
              2019-03-27
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="//schema.org/Thing">
                  <a href="/blog/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="java-Socket-SO-LINGER-设置方法源码"><a href="#java-Socket-SO-LINGER-设置方法源码" class="headerlink" title="java Socket SO_LINGER 设置方法源码"></a>java Socket SO_LINGER 设置方法源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">999</span><span class="line">1000</span><span class="line">1001</span><span class="line">1002</span><span class="line">1003</span><span class="line">1004</span><span class="line">1005</span><span class="line">1006</span><span class="line">1007</span><span class="line">1008</span><span class="line">1009</span><span class="line">1010</span><span class="line">1011</span><span class="line">1012</span><span class="line">1013</span><span class="line">1014</span><span class="line">1015</span><span class="line">1016</span><span class="line">1017</span><span class="line">1018</span><span class="line">1019</span><span class="line">1020</span><span class="line">1021</span><span class="line">1022</span><span class="line">1023</span><span class="line">1024</span><span class="line">1025</span><span class="line">1026</span><span class="line">1027</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><span class="line"><span class="comment"> * Enable/disable &#123;<span class="doctag">@link</span> SocketOptions#SO_LINGER SO_LINGER&#125; with the</span></span><span class="line"><span class="comment"> * specified linger time in seconds. The maximum timeout value is platform</span></span><span class="line"><span class="comment"> * specific.</span></span><span class="line"><span class="comment"> *</span></span><span class="line"><span class="comment"> * The setting only affects socket close.</span></span><span class="line"><span class="comment"> *</span></span><span class="line"><span class="comment"> * <span class="doctag">@param</span> on     whether or not to linger on.</span></span><span class="line"><span class="comment"> * <span class="doctag">@param</span> linger how long to linger for, if on is true.</span></span><span class="line"><span class="comment"> * <span class="doctag">@exception</span> SocketException if there is an error</span></span><span class="line"><span class="comment"> * in the underlying protocol, such as a TCP error.</span></span><span class="line"><span class="comment"> * <span class="doctag">@exception</span> IllegalArgumentException if the linger value is negative.</span></span><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK1.1</span></span><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getSoLinger()</span></span><span class="line"><span class="comment"> */</span></span><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSoLinger</span><span class="params">(<span class="keyword">boolean</span> on, <span class="keyword">int</span> linger)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><span class="line">    <span class="keyword">if</span> (isClosed())</span><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"Socket is closed"</span>);</span><span class="line">    <span class="keyword">if</span> (!on) &#123;</span><span class="line">        getImpl().setOption(SocketOptions.SO_LINGER, <span class="keyword">new</span> Boolean(on));</span><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><span class="line">        <span class="keyword">if</span> (linger &lt; <span class="number">0</span>) &#123;</span><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"invalid value for SO_LINGER"</span>);</span><span class="line">        &#125;</span><span class="line">        <span class="keyword">if</span> (linger &gt; <span class="number">65535</span>)</span><span class="line">            linger = <span class="number">65535</span>;</span><span class="line">        getImpl().setOption(SocketOptions.SO_LINGER, <span class="keyword">new</span> Integer(linger));</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="Socket-SO-LINGER-参数设置说明"><a href="#Socket-SO-LINGER-参数设置说明" class="headerlink" title="Socket SO_LINGER 参数设置说明"></a>Socket SO_LINGER 参数设置说明</h2><p>SO_LINGER 这个参数是控制 socket 关闭后的行为，不看系统底层的实现，只从上面 java 代码的实现来看，这个方法的二个参数<code>on</code>和<code>linger</code>有以下三种组合：</p>
<h3 id="on-false"><a href="#on-false" class="headerlink" title="on = false"></a>on = false</h3><p>这是默认行为，当<code>on</code>为<code>false</code>时，<code>linger</code>对应的设置就没有意义，当 socket 主动 close，调用的线程会马上返回，不会阻塞，残留在缓冲区中的数据将继续发送给对端，并且与对端进行 FIN-ACK 协议交换，最后进入 TIME_WAIT 状态。</p>
<h3 id="on-true-linger-gt-0"><a href="#on-true-linger-gt-0" class="headerlink" title="on = true, linger &gt; 0"></a>on = true, linger &gt; 0</h3><p>调用 close 的线程将阻塞，发生两种可能的情况：</p>
<ol>
<li>是剩余的数据继续发送，进行关闭协议交换；</li>
<li>就是超时过期，剩余的数据将被删除，进行 FIN-ACK 交换。</li>
</ol>
<h3 id="on-true-linger-0"><a href="#on-true-linger-0" class="headerlink" title="on = true, linger = 0"></a>on = true, linger = 0</h3><p>这种方式就是所谓<code>hard-close</code>，这个方式是讨论或者争论最多的用法，任何剩余的数据都被立即丢弃，并且 FIN-ACK 交换也不会发生，替代产生 RST ，让对端抛出<code>connection reset</code>的 SocketException 。</p>
<a id="more"></a>
<h2 id="测试-sock-程序下载"><a href="#测试-sock-程序下载" class="headerlink" title="测试 sock 程序下载"></a>测试 sock 程序下载</h2><p>下面程序演示会使用到 sock 程序，此程序可从 <a href="http://www.kohala.com/start/unpv12e.html" target="_blank" rel="noopener">UNIX Network Programming, Volume 1, Second Edition: Networking APIs: Sockets and XTI, Prentice Hall, 1998, ISBN 0-13-490012-X</a> 这里下载 sock 程序源码，另外我也在 <a href="https://github.com/yuweijun/tcpip-illustrated-v1" target="_blank" rel="noopener">github</a> 上放了一份源码和在 Linux 平台上编译生成的可执行程序，不同平台可以参照 README 文件编译安装，或者直接从 sourceforge.net 下载二进制 <a href="http://ttcplinux.sourceforge.net/tools/sock" target="_blank" rel="noopener">sock</a> 程序。</p>
<h2 id="正常四次挥手关闭连接过程"><a href="#正常四次挥手关闭连接过程" class="headerlink" title="正常四次挥手关闭连接过程"></a>正常四次挥手关闭连接过程</h2><img src="/blog/img/linux/tcp/tcp-close.png" class="image-md" title="[tcp-close.png]">
<h2 id="发送-RST-异常终止一个连接"><a href="#发送-RST-异常终止一个连接" class="headerlink" title="发送 RST 异常终止一个连接"></a>发送 RST 异常终止一个连接</h2><p>终止一个连接的正常方式是 TCP 连接中的一方发送 FIN，有时这也称为<code>有序释放</code>（orderly release），因为在所有排队数据都已发送之后才发送 FIN，正常情况下没有任何数据丢失。但也有可能发送一个复位报文段而不是 FIN 来中途释放一个连接，有时称这为<code>异常释放</code>（abortive release）。</p>
<p>异常终止一个连接对应用程序来说有两个优点：</p>
<ol>
<li>丢弃任何待发数据并立即发送复位报文段；</li>
<li>RST 的接收方会区分另一端执行的是异常关闭还是正常关闭，应用程序使用的 API 必须提供产生异常关闭而不是正常关闭的手段。</li>
</ol>
<p>Socket API 通过<code>linger on close</code>选项（SO_LINGER）提供了这种异常关闭的能力，激活此选项并将停留时间设为<code>0</code>，这将导致连接关闭时进行复位 RST 而不是正常的 FIN，上述原文如下：</p>
<h3 id="TCP-IP-Illustrated-Aborting-a-Connection"><a href="#TCP-IP-Illustrated-Aborting-a-Connection" class="headerlink" title="TCP/IP Illustrated - Aborting a Connection"></a>TCP/IP Illustrated - Aborting a Connection</h3><p>We saw in Section 18.2 that the normal way to terminate a connection is for one side to send a FIN. This is sometimes called an <code>orderly release</code> since the FIN is sent after all previously queued data has been sent, and there is normally no loss of data. But it&#39;s also possible to abort a connection by sending a reset instead of a FIN. This is sometimes called an <code>abortive release</code>.</p>
<p>Aborting a connection provides two features to the application:</p>
<ol>
<li>any queued data is thrown away and the reset is sent immediately, and</li>
<li>the receiver of the RST can tell that the other end did an abort instead of a normal close. The API being used by the application must provide a way to generate the abort instead of a normal close.</li>
</ol>
<p>We can watch this abort sequence happen using our sock program. The sockets API provides this capability by using the &quot;linger on close&quot; socket option (SO_LINGER). We specify the -L option with a linger time of 0. This causes the abort to be sent when the connection is closed, instead of the normal FIN.</p>
<h2 id="RST-终止连接示例"><a href="#RST-终止连接示例" class="headerlink" title="RST 终止连接示例"></a>RST 终止连接示例</h2><p>使用复位 RST 而不是 FIN 来异常终止一个连接示例如下，中间的命令是使用 <a href="https://github.com/yuweijun/tcpip-illustrated-v1" target="_blank" rel="noopener">sock</a> 程序启动服务，最下面的命令是客户端输入<code>Hello World</code>之后按<kbd>Ctrl-D</kbd>输入文件结束符：</p>
<img src="/blog/img/linux/tcp/solinger/tcp-rst-instead-fin-sock-1.png" class="image-hg" title="[Aborting a connection with a reset (RST) instead of a FIN]">
<p>上图第 <code>1~3</code> 个数据包显示出建立连接的正常过程。第 <code>5</code> 个数据包发送我们键入的数据行（12 个字符和 Unix 换行符），第 <code>6</code> 个数据包是对收到数据的确认。</p>
<p>第 <code>7</code> 个数据包对应为终止客户程序而键入的文件结束符<kbd>Ctrl-D</kbd>。由于我们指明使用异常关闭而不是正常关闭（命令行中的<code>-L0</code>选项），因此最后的第 <code>8</code> 个数据包中客户端的 TCP 发送一个 RST 而不是通常的 FIN 。RST 报文段中包含一个序号和确认序号。需要注意的是 RST 报文段不会导致另一端产生任何响应，另一端根本不进行确认。收到 RST 的一方将终止该连接，并通知应用层连接复位。</p>
<h2 id="stackoverflow-com-上关于-TCP-linger-true-timeout-0-的讨论"><a href="#stackoverflow-com-上关于-TCP-linger-true-timeout-0-的讨论" class="headerlink" title="stackoverflow.com 上关于 TCP linger=true, timeout=0 的讨论"></a>stackoverflow.com 上关于 TCP linger=true, timeout=0 的讨论</h2><p>将<code>SO_LINGER</code>超时设置为<code>0</code>的典型原因是避免大量连接处于 TIME_WAIT 状态，因为这些过多 TIME_WAIT 连接，最终可能会阻止服务器打开新连接。</p>
<p>当关闭 TCP 连接时，发起关闭的一方（主动关闭）最终会在 TIME_WAIT 中连接几分钟，如果是服务器启动连接关闭的协议，并且涉及大量短连接，那么服务器可能容易受到过多 TIME_WAIT 连接问题的影响。</p>
<p>使用<code>linger=true, timeout=0</code>来避免 TIME_WAIT 连接数过多问题，这并不是一个好主意，TIME_WAIT 存在是有原因的（确保来自旧连接的数据包不会干扰新连接），如果可能的话，最好将协议重新设计为客户端启动连接关闭的协议。</p>
<p>要了解为什么 TIME_WAIT 状态是我们的朋友，请阅读 Stevens 等人的<code>UNIX 网络编程第三版</code>中的第<code>2.7</code>节，原版内容如下：</p>
<h3 id="UNIX-Network-Programming-2-7-TIME-WAIT-State"><a href="#UNIX-Network-Programming-2-7-TIME-WAIT-State" class="headerlink" title="UNIX Network Programming - 2.7 TIME_WAIT State"></a>UNIX Network Programming - 2.7 TIME_WAIT State</h3><p>Undoubtedly, one of the most misunderstood aspects of TCP with regard to network programming is its TIME_WAIT state. We can see in Figure 2.4 that the end that performs the active close goes through this state. The duration that this endpoint remains in this state is twice the maximum segment lifetime (MSL), sometimes called 2MSL.</p>
<p>Every implementation of TCP must choose a value for the MSL. The recommended value in RFC 1122 [Braden 1989] is 2 minutes, although Berkeley-derived implementations have traditionally used a value of 30 seconds instead. This means the duration of the TIME_WAIT state is between 1 and 4 minutes. The MSL is the maximum amount of time that any given IP datagram can live in a network. We know this time is bounded because every datagram contains an 8-bit hop limit (the IPv4 TTL field in Figure A.1 and the IPv6 hop limit field in Figure A.2) with a maximum value of 255. Although this is a hop limit and not a true time limit, the assumption is made that a packet with the maximum hop limit of 255 cannot exist in a network for more than MSL seconds.</p>
<p>The way in which a packet gets &quot;<strong>lost</strong>&quot; in a network is usually the result of routing anomalies. A router crashes or a link between two routers goes down and it takes the routing protocols seconds or minutes to stabilize and find an alternate path. During that time period, routing loops can occur (router A sends packets to router B, and B sends them back to A) and packets can get caught in these loops. In the meantime, assuming the lost packet is a TCP segment, the sending TCP times out and retransmits the packet, and the retransmitted packet gets to the final destination by some alternate path. But sometime later (up to MSL seconds after the lost packet started on its journey), the routing loop is corrected and the packet that was lost in the loop is sent to the final destination. This original packet is called a lost duplicate or a wandering duplicate. TCP must handle these duplicates.</p>
<p>There are two reasons for the TIME_WAIT state:</p>
<ol>
<li>To implement TCP&#39;s full-duplex connection termination reliably</li>
<li>To allow old duplicate segments to expire in the network</li>
</ol>
<p>The first reason can be explained by looking at Figure 2.5 and assuming that the final ACK is lost. The server will resend its final FIN, so the client must maintain state information, allowing it to resend the final ACK. If it did not maintain this information, it would respond with an RST (a different type of TCP segment), which would be interpreted by the server as an error. If TCP is performing all the work necessary to terminate both directions of data flow cleanly for a connection (its full-duplex close), then it must correctly handle the loss of any of these four segments.</p>
<p>This example also shows why the end that performs the active close is the end that remains in the TIME_WAIT state:</p>
<blockquote>
<p>because that end is the one that might have to retransmit the final ACK.</p>
</blockquote>
<p>To understand the second reason for the TIME_WAIT state, assume we have a TCP connection between 12.106.32.254 port 1500 and 206.168.112.219 port 21. This connection is closed and then sometime later, we establish another connection between the same IP addresses and ports: 12.106.32.254 port 1500 and 206.168.112.219 port 21. This latter connection is called an incarnation of the previous connection since the IP addresses and ports are the same. TCP must prevent old duplicates from a connection from reappearing at some later time and being misinterpreted as belonging to a new incarnation of the same connection. To do this, TCP will not initiate a new incarnation of a connection that is currently in the TIME_WAIT state. Since the duration of the TIME_WAIT state is twice the MSL, this allows MSL seconds for a packet in one direction to be lost, and another MSL seconds for the reply to be lost. By enforcing this rule, we are guaranteed that when we successfully establish a TCP connection, all old duplicates from previous incarnations of the connection have expired in the network.</p>
<p>There is an exception to this rule. Berkeley-derived implementations will initiate a new incarnation of a connection that is currently in the TIME_WAIT state if the arriving SYN has a sequence number that is &quot;greater than&quot; the ending sequence number from the previous incarnation. Pages 958–959 of TCPv2 talk about this in more detail. This requires the server to perform the active close, since the TIME_WAIT state must exist on the end that receives the next SYN. This capability is used by the rsh command. RFC 1185 [Jacobson, Braden, and Zhang 1990] talks about some pitfalls in doing this.</p>
<h3 id="UNIX-Network-Programming-7-4-SO-LINGER-Socket-Option"><a href="#UNIX-Network-Programming-7-4-SO-LINGER-Socket-Option" class="headerlink" title="UNIX Network Programming - 7.4 SO_LINGER Socket Option"></a>UNIX Network Programming - 7.4 SO_LINGER Socket Option</h3><p>This option specifies how the <code>close</code> function operates for a connection-oriented protocol (e.g., for TCP and SCTP, but not for UDP). By default, <code>close</code> returns immediately, but if there is any data still remaining in the socket send buffer, the system will try to deliver the data to the peer.</p>
<p>The <code>SO_LINGER</code> socket option lets us change this default. This option requires the following structure to be passed between the user process and the kernel. It is defined by including <code>&lt;sys/socket.h&gt;</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> &#123;</span></span><span class="line">    <span class="keyword">int</span> l_onoff;  <span class="comment">/* 0=off, nonzero=on */</span></span><span class="line">    <span class="keyword">int</span> l_linger; <span class="comment">/* linger time, POSIX specifies units as seconds */</span></span><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>Calling setsockopt leads to one of the following three scenarios, depending on the values of the two structure members:</p>
<ol>
<li>If l_onoff is 0, the option is turned off. The value of l_linger is ignored and the previously discussed TCP default applies: <code>close</code> returns immediately.</li>
<li>If l_onoff is nonzero and l_linger is zero, TCP aborts the connection when it is closed (pp. 1019–1020 of TCPv2). That is, TCP discards any data still remaining in the socket send buffer and sends an RST to the peer, not the normal four-packet connection termination sequence (Section 2.6). We will show an example of this in Figure 16.21. This avoids TCP&#39;s TIME_WAIT state, but in doing so, leaves open the possibility of another incarnation of this connection being created within 2MSL seconds (Section 2.7) and having old duplicate segments from the just-terminated connection being incorrectly delivered to the new incarnation. SCTP will also do an abortive close of the socket by sending an ABORT chunk to the peer (see Section 9.2 of [Stewart and Xie 2001]) when l_onoff is nonzero and l_linger is zero. Occasional USENET postings advocate the use of this feature just to avoid the TIME_WAIT state and to be able to restart a listening server even if connections are still in use with the server&#39;s well-known port. This should NOT be done and could lead to data corruption, as detailed in RFC 1337 [Braden 1992]. Instead, the SO_REUSEADDR socket option should always be used in the server before the call to bind, as we will describe shortly. <strong>The TIME_WAIT state is our friend</strong> and is there to help us (i.e., to let old duplicate segments expire in the network). <strong>Instead of trying to avoid the state, we should understand it</strong> (Section 2.7). There are certain circumstances which warrant using this feature to send an abortive close. One example is an RS-232 terminal server, which might hang forever in CLOSE_WAIT trying to deliver data to a struck terminal port, but would properly reset the stuck port if it got an RST to discard the pending data.</li>
<li>If l_onoff is nonzero and l_linger is nonzero, then the kernel will linger when the socket is closed (p. 472 of TCPv2). That is, if there is any data still remaining in the socket send buffer, the process is put to sleep until either: (i) all the data is sent and acknowledged by the peer TCP, or (ii) the linger time expires. If the socket has been set to nonblocking (Chapter 16), it will not wait for the close to complete, even if the linger time is nonzero. When using this feature of the SO_LINGER option, it is important for the application to check the return value from close, because if the linger time expires before the remaining data is sent and acknowledged, close returns EWOULDBLOCK and any remaining data in the send buffer is discarded.</li>
</ol>
<p>We now need to see exactly when a close on a socket returns given the various scenarios we looked at. We assume that the client writes data to the socket and then calls close. Figure 7.7 shows the default situation.</p>
<p>The SO_LINGER socket option gives us more control over when close returns and also lets us force an RST to be sent instead of TCP&#39;s four-packet connection termination sequence. We must be careful sending RSTs, because this avoids TCP&#39;s TIME_WAIT state. Much of the time, this socket option does not provide the information that we need, in which case, an application-level ACK is required.</p>
<h3 id="Purposes-for-the-TIME-WAIT-state"><a href="#Purposes-for-the-TIME-WAIT-state" class="headerlink" title="Purposes for the TIME-WAIT state"></a>Purposes for the TIME-WAIT state</h3><p>The most known one is to <strong>prevent delayed segments</strong> from one connection being accepted by a later connection relying on the same quadruplet (source address, source port, destination address, destination port). The sequence number also needs to be in a certain range to be accepted. This narrows a bit the problem but it still exists, especially on fast connections with large receive windows. RFC 1337 explains in details what happens when the TIME-WAIT state is deficient. Here is an example of what could be avoided if the TIME-WAIT state wasn’t shortened:</p>
<img src="/blog/img/linux/tcp/tcp-close-duplicate-segment.svg" title="[Due to a shortened TIME-WAIT state, a delayed TCP segment has been accepted in an unrelated connection]">
<p>The other purpose is to ensure <strong>the remote end has closed the connection</strong>. When the last ACK is lost, the remote end stays in the LAST-ACK state. Without the TIME-WAIT state, a connection could be reopened while the remote end still thinks the previous connection is valid. When it receives a SYN segment (and the sequence number matches), it will answer with a RST as it is not expecting such a segment. The new connection will be aborted with an error:</p>
<img src="/blog/img/linux/tcp/tcp-close-last-ack.svg" title="[If the remote end stays in LAST-ACK state because the last ACK was lost, opening a new connection with the same quadruplet will not work]">
<h2 id="TCP-状态变化示意图"><a href="#TCP-状态变化示意图" class="headerlink" title="TCP 状态变化示意图"></a>TCP 状态变化示意图</h2><img src="/blog/img/linux/tcp/tcpip-state-transition-diagram.png" title="[tcpip-state-transition-diagram.png]">
<h3 id="When-to-use-SO-LINGER-with-timeout-0"><a href="#When-to-use-SO-LINGER-with-timeout-0" class="headerlink" title="When to use SO_LINGER with timeout 0"></a>When to use SO_LINGER with timeout 0</h3><p>Again, according to &quot;UNIX Network Programming&quot; third edition, setting SO_LINGER with timeout <code>0</code> prior to calling <code>close()</code> will cause the normal termination sequence not to be initiated.</p>
<p>Instead, the peer setting this option and calling <code>close()</code> will send a RST (connection reset) which indicates an error condition and this is how it will be perceived at the other end. You will typically see errors like <code>Connection reset by peer</code>.</p>
<p>Therefore, in the normal situation it is a really bad idea to set SO_LINGER with timeout <code>0</code> prior to calling <code>close()</code> – from now on called abortive close – in a server application.</p>
<p>However, certain situation warrants doing so anyway:</p>
<ol>
<li>If the a client of your server application misbehaves (times out, returns invalid data, etc.) an abortive close makes sense to avoid being stuck in CLOSE_WAIT or ending up in the TIME_WAIT state.</li>
<li>If you must restart your server application which currently has thousands of client connections you might consider setting this socket option to avoid thousands of server sockets in TIME_WAIT (when calling <code>close()</code> from the server end) as this might prevent the server from getting available ports for new client connections after being restarted.</li>
<li>On page 202 in the aforementioned book it specifically says:<br> There are certain circumstances which warrant using this feature to send an abortive close. One example is an RS-232 terminal server, which might hang forever in CLOSE_WAIT trying to deliver data to a stuck terminal port, but would properly reset the stuck port if it got an RST to discard the pending data.</li>
<li>I would recommend this long article which I believe gives a very good answer to your question.</li>
</ol>
<p>As mentioned previously, the TIME_WAIT state is intended to allow any datagrams lingering from a closed connection to be discarded. During this period, the waiting TCP usually has little to do; it merely holds the state until the 2MSL timer expires.</p>
<h2 id="Linux-TCP-SO-LINGER-相关源码"><a href="#Linux-TCP-SO-LINGER-相关源码" class="headerlink" title="Linux TCP SO_LINGER 相关源码"></a>Linux TCP SO_LINGER 相关源码</h2><p><a href="https://github.com/torvalds/linux/blob/v5.0/net/ipv4/tcp.c" target="_blank" rel="noopener">https://github.com/torvalds/linux/blob/v5.0/net/ipv4/tcp.c</a> 摘录部分源码内容，关于<code>abort call</code>源码注释说明如下：</p>
<figure class="highlight c"><figcaption><span>tcp.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">203</span><span class="line">204</span></pre></td><td class="code"><pre><span class="line">*  Salvatore Sanfilippo    :   Support SO_LINGER with linger == <span class="number">1</span> <span class="keyword">and</span></span><span class="line">*                              lingertime == <span class="number">0</span> (RFC <span class="number">793</span> ABORT Call)</span></pre></td></tr></table></figure>
<p>关于 TCP 状态的说明注释部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">213</span><span class="line">214</span><span class="line">215</span><span class="line">216</span><span class="line">217</span><span class="line">218</span><span class="line">219</span><span class="line">220</span><span class="line">221</span><span class="line">222</span><span class="line">223</span><span class="line">224</span><span class="line">225</span><span class="line">226</span><span class="line">227</span><span class="line">228</span><span class="line">229</span><span class="line">230</span><span class="line">231</span><span class="line">232</span><span class="line">233</span><span class="line">234</span><span class="line">235</span><span class="line">236</span><span class="line">237</span><span class="line">238</span><span class="line">239</span><span class="line">240</span><span class="line">241</span><span class="line">242</span><span class="line">243</span><span class="line">244</span><span class="line">245</span></pre></td><td class="code"><pre><span class="line">* Description of States:</span><span class="line">*</span><span class="line">*  TCP_SYN_SENT        sent a connection request, waiting <span class="keyword">for</span> ack</span><span class="line">*</span><span class="line">*  TCP_SYN_RECV        received a connection request, sent ack,</span><span class="line">*                      waiting <span class="keyword">for</span> <span class="keyword">final</span> ack in three-way handshake.</span><span class="line">*</span><span class="line">*  TCP_ESTABLISHED     connection established</span><span class="line">*</span><span class="line">*  TCP_FIN_WAIT1       our side has shutdown, waiting to complete</span><span class="line">*                      transmission of remaining buffered data</span><span class="line">*</span><span class="line">*  TCP_FIN_WAIT2       all buffered data sent, waiting <span class="keyword">for</span> remote</span><span class="line">*                      to shutdown</span><span class="line">*</span><span class="line">*  TCP_CLOSING         both sides have shutdown but we still have</span><span class="line">*                      data we have to finish sending</span><span class="line">*</span><span class="line">*  TCP_TIME_WAIT       timeout to <span class="keyword">catch</span> resent junk before entering</span><span class="line">*                      closed, can only be entered from FIN_WAIT2</span><span class="line">*                      <span class="keyword">or</span> CLOSING.  Required because the other end</span><span class="line">*                      may <span class="keyword">not</span> have gotten our last ACK causing it</span><span class="line">*                      <span class="function">to retransmit the data <span class="title">packet</span> <span class="params">(which we ignore)</span></span></span><span class="line"><span class="function">*</span></span><span class="line"><span class="function">*  TCP_CLOSE_WAIT      remote side has shutdown <span class="keyword">and</span> is waiting <span class="keyword">for</span></span></span><span class="line"><span class="function">*                      us to finish writing our data <span class="keyword">and</span> to shutdown</span></span><span class="line"><span class="function">*                      <span class="params">(we have to close() to move on to LAST_ACK)</span></span></span><span class="line"><span class="function">*</span></span><span class="line"><span class="function">*  TCP_LAST_ACK        out side has shutdown after remote has</span></span><span class="line">*                      shutdown.  There may still be data in our</span><span class="line">*                      buffer that we have to finish sending</span><span class="line">*</span><span class="line">*  TCP_CLOSE           socket is finished</span></pre></td></tr></table></figure>
<p><code>tcp_close(socket, timeout)</code>方法源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">2320</span><span class="line">2321</span><span class="line">2322</span><span class="line">2323</span><span class="line">2324</span><span class="line">2325</span><span class="line">2326</span><span class="line">2327</span><span class="line">2328</span><span class="line">2329</span><span class="line">2330</span><span class="line">2331</span><span class="line">2332</span><span class="line">2333</span><span class="line">2334</span><span class="line">2335</span><span class="line">2336</span><span class="line">2337</span><span class="line">2338</span><span class="line">2339</span><span class="line">2340</span><span class="line">2341</span><span class="line">2342</span><span class="line">2343</span><span class="line">2344</span><span class="line">2345</span><span class="line">2346</span><span class="line">2347</span><span class="line">2348</span><span class="line">2349</span><span class="line">2350</span><span class="line">2351</span><span class="line">2352</span><span class="line">2353</span><span class="line">2354</span><span class="line">2355</span><span class="line">2356</span><span class="line">2357</span><span class="line">2358</span><span class="line">2359</span><span class="line">2360</span><span class="line">2361</span><span class="line">2362</span><span class="line">2363</span><span class="line">2364</span><span class="line">2365</span><span class="line">2366</span><span class="line">2367</span><span class="line">2368</span><span class="line">2369</span><span class="line">2370</span><span class="line">2371</span><span class="line">2372</span><span class="line">2373</span><span class="line">2374</span><span class="line">2375</span><span class="line">2376</span><span class="line">2377</span><span class="line">2378</span><span class="line">2379</span><span class="line">2380</span><span class="line">2381</span><span class="line">2382</span><span class="line">2383</span><span class="line">2384</span><span class="line">2385</span><span class="line">2386</span><span class="line">2387</span><span class="line">2388</span><span class="line">2389</span><span class="line">2390</span><span class="line">2391</span><span class="line">2392</span><span class="line">2393</span><span class="line">2394</span><span class="line">2395</span><span class="line">2396</span><span class="line">2397</span><span class="line">2398</span><span class="line">2399</span><span class="line">2400</span><span class="line">2401</span><span class="line">2402</span><span class="line">2403</span><span class="line">2404</span><span class="line">2405</span><span class="line">2406</span><span class="line">2407</span><span class="line">2408</span><span class="line">2409</span><span class="line">2410</span><span class="line">2411</span><span class="line">2412</span><span class="line">2413</span><span class="line">2414</span><span class="line">2415</span><span class="line">2416</span><span class="line">2417</span><span class="line">2418</span><span class="line">2419</span><span class="line">2420</span><span class="line">2421</span><span class="line">2422</span><span class="line">2423</span><span class="line">2424</span><span class="line">2425</span><span class="line">2426</span><span class="line">2427</span><span class="line">2428</span><span class="line">2429</span><span class="line">2430</span><span class="line">2431</span><span class="line">2432</span><span class="line">2433</span><span class="line">2434</span><span class="line">2435</span><span class="line">2436</span><span class="line">2437</span><span class="line">2438</span><span class="line">2439</span><span class="line">2440</span><span class="line">2441</span><span class="line">2442</span><span class="line">2443</span><span class="line">2444</span><span class="line">2445</span><span class="line">2446</span><span class="line">2447</span><span class="line">2448</span><span class="line">2449</span><span class="line">2450</span><span class="line">2451</span><span class="line">2452</span><span class="line">2453</span><span class="line">2454</span><span class="line">2455</span><span class="line">2456</span><span class="line">2457</span><span class="line">2458</span><span class="line">2459</span><span class="line">2460</span><span class="line">2461</span><span class="line">2462</span><span class="line">2463</span><span class="line">2464</span><span class="line">2465</span><span class="line">2466</span><span class="line">2467</span><span class="line">2468</span><span class="line">2469</span><span class="line">2470</span><span class="line">2471</span><span class="line">2472</span><span class="line">2473</span><span class="line">2474</span><span class="line">2475</span><span class="line">2476</span><span class="line">2477</span><span class="line">2478</span><span class="line">2479</span><span class="line">2480</span><span class="line">2481</span><span class="line">2482</span><span class="line">2483</span><span class="line">2484</span><span class="line">2485</span><span class="line">2486</span><span class="line">2487</span><span class="line">2488</span><span class="line">2489</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcp_close</span><span class="params">(struct sock *sk, <span class="keyword">long</span> timeout)</span></span></span><span class="line"><span class="function"></span>&#123;</span><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><span class="line">    <span class="keyword">int</span> data_was_unread = <span class="number">0</span>;</span><span class="line">    <span class="keyword">int</span> state;</span><span class="line"></span><span class="line">    lock_sock(sk);</span><span class="line">    sk-&gt;sk_shutdown = SHUTDOWN_MASK;</span><span class="line"></span><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state == TCP_LISTEN) &#123;</span><span class="line">        tcp_set_state(sk, TCP_CLOSE);</span><span class="line"></span><span class="line">        <span class="comment">/* Special case. */</span></span><span class="line">        inet_csk_listen_stop(sk);</span><span class="line"></span><span class="line">        <span class="keyword">goto</span> adjudge_to_death;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="comment">/*  We need to flush the recv. buffs.  We do this only on the</span></span><span class="line"><span class="comment">     *  descriptor close, not protocol-sourced closes, because the</span></span><span class="line"><span class="comment">     *  reader process may not have drained the data yet!</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="keyword">while</span> ((skb = __skb_dequeue(&amp;sk-&gt;sk_receive_queue)) != <span class="literal">NULL</span>) &#123;</span><span class="line">        u32 len = TCP_SKB_CB(skb)-&gt;end_seq - TCP_SKB_CB(skb)-&gt;seq;</span><span class="line"></span><span class="line">        <span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;tcp_flags &amp; TCPHDR_FIN)</span><span class="line">            len--;</span><span class="line">        data_was_unread += len;</span><span class="line">        __kfree_skb(skb);</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    sk_mem_reclaim(sk);</span><span class="line"></span><span class="line">    <span class="comment">/* If socket has been already reset (e.g. in tcp_reset()) - kill it. */</span></span><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state == TCP_CLOSE)</span><span class="line">        <span class="keyword">goto</span> adjudge_to_death;</span><span class="line"></span><span class="line">    <span class="comment">/* As outlined in RFC 2525, section 2.17, we send a RST here because</span></span><span class="line"><span class="comment">     * data was lost. To witness the awful effects of the old behavior of</span></span><span class="line"><span class="comment">     * always doing a FIN, run an older 2.1.x kernel or 2.0.x, start a bulk</span></span><span class="line"><span class="comment">     * GET in an FTP client, suspend the process, wait for the client to</span></span><span class="line"><span class="comment">     * advertise a zero window, then kill -9 the FTP client, wheee...</span></span><span class="line"><span class="comment">     * Note: timeout is always zero in such a case.</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="keyword">if</span> (unlikely(tcp_sk(sk)-&gt;repair)) &#123;</span><span class="line">        sk-&gt;sk_prot-&gt;disconnect(sk, <span class="number">0</span>);</span><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data_was_unread) &#123;</span><span class="line">        <span class="comment">/* Unread data was tossed, zap the connection. */</span></span><span class="line">        NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONCLOSE);</span><span class="line">        tcp_set_state(sk, TCP_CLOSE);</span><span class="line">        tcp_send_active_reset(sk, sk-&gt;sk_allocation);</span><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sock_flag(sk, SOCK_LINGER) &amp;&amp; !sk-&gt;sk_lingertime) &#123;</span><span class="line">        <span class="comment">/* Check zero linger _after_ checking for unread data. */</span></span><span class="line">        sk-&gt;sk_prot-&gt;disconnect(sk, <span class="number">0</span>);</span><span class="line">        NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONDATA);</span><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tcp_close_state(sk)) &#123;</span><span class="line">        <span class="comment">/* We FIN if the application ate all the data before</span></span><span class="line"><span class="comment">         * zapping the connection.</span></span><span class="line"><span class="comment">         */</span></span><span class="line"></span><span class="line">        <span class="comment">/* RED-PEN. Formally speaking, we have broken TCP state</span></span><span class="line"><span class="comment">         * machine. State transitions:</span></span><span class="line"><span class="comment">         *</span></span><span class="line"><span class="comment">         * TCP_ESTABLISHED -&gt; TCP_FIN_WAIT1</span></span><span class="line"><span class="comment">         * TCP_SYN_RECV -&gt; TCP_FIN_WAIT1 (forget it, it's impossible)</span></span><span class="line"><span class="comment">         * TCP_CLOSE_WAIT -&gt; TCP_LAST_ACK</span></span><span class="line"><span class="comment">         *</span></span><span class="line"><span class="comment">         * are legal only when FIN has been sent (i.e. in window),</span></span><span class="line"><span class="comment">         * rather than queued out of window. Purists blame.</span></span><span class="line"><span class="comment">         *</span></span><span class="line"><span class="comment">         * F.e. "RFC state" is ESTABLISHED,</span></span><span class="line"><span class="comment">         * if Linux state is FIN-WAIT-1, but FIN is still not sent.</span></span><span class="line"><span class="comment">         *</span></span><span class="line"><span class="comment">         * The visible declinations are that sometimes</span></span><span class="line"><span class="comment">         * we enter time-wait state, when it is not required really</span></span><span class="line"><span class="comment">         * (harmless), do not send active resets, when they are</span></span><span class="line"><span class="comment">         * required by specs (TCP_ESTABLISHED, TCP_CLOSE_WAIT, when</span></span><span class="line"><span class="comment">         * they look as CLOSING or LAST_ACK for Linux)</span></span><span class="line"><span class="comment">         * Probably, I missed some more holelets.</span></span><span class="line"><span class="comment">         *                      --ANK</span></span><span class="line"><span class="comment">         * XXX (TFO) - To start off we don't support SYN+ACK+FIN</span></span><span class="line"><span class="comment">         * in a single packet! (May consider it later but will</span></span><span class="line"><span class="comment">         * probably need API support or TCP_CORK SYN-ACK until</span></span><span class="line"><span class="comment">         * data is written and socket is closed.)</span></span><span class="line"><span class="comment">         */</span></span><span class="line">        tcp_send_fin(sk);</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    sk_stream_wait_close(sk, timeout);</span><span class="line"></span><span class="line">adjudge_to_death:</span><span class="line">    state = sk-&gt;sk_state;</span><span class="line">    sock_hold(sk);</span><span class="line">    sock_orphan(sk);</span><span class="line"></span><span class="line">    local_bh_disable();</span><span class="line">    bh_lock_sock(sk);</span><span class="line">    <span class="comment">/* remove backlog if any, without releasing ownership. */</span></span><span class="line">    __release_sock(sk);</span><span class="line"></span><span class="line">    percpu_counter_inc(sk-&gt;sk_prot-&gt;orphan_count);</span><span class="line"></span><span class="line">    <span class="comment">/* Have we already been destroyed by a softirq or backlog? */</span></span><span class="line">    <span class="keyword">if</span> (state != TCP_CLOSE &amp;&amp; sk-&gt;sk_state == TCP_CLOSE)</span><span class="line">        <span class="keyword">goto</span> out;</span><span class="line"></span><span class="line">    <span class="comment">/*  This is a (useful) BSD violating of the RFC. There is a</span></span><span class="line"><span class="comment">     *  problem with TCP as specified in that the other end could</span></span><span class="line"><span class="comment">     *  keep a socket open forever with no application left this end.</span></span><span class="line"><span class="comment">     *  We use a 1 minute timeout (about the same as BSD) then kill</span></span><span class="line"><span class="comment">     *  our end. If they send after that then tough - BUT: long enough</span></span><span class="line"><span class="comment">     *  that we won't make the old 4*rto = almost no time - whoops</span></span><span class="line"><span class="comment">     *  reset mistake.</span></span><span class="line"><span class="comment">     *</span></span><span class="line"><span class="comment">     *  Nope, it was not mistake. It is really desired behaviour</span></span><span class="line"><span class="comment">     *  f.e. on http servers, when such sockets are useless, but</span></span><span class="line"><span class="comment">     *  consume significant resources. Let's do it with special</span></span><span class="line"><span class="comment">     *  linger2 option.                 --ANK</span></span><span class="line"><span class="comment">     */</span></span><span class="line"></span><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state == TCP_FIN_WAIT2) &#123;</span><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><span class="line">        <span class="keyword">if</span> (tp-&gt;linger2 &lt; <span class="number">0</span>) &#123;</span><span class="line">            tcp_set_state(sk, TCP_CLOSE);</span><span class="line">            tcp_send_active_reset(sk, GFP_ATOMIC);</span><span class="line">            __NET_INC_STATS(sock_net(sk),</span><span class="line">                    LINUX_MIB_TCPABORTONLINGER);</span><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> tmo = tcp_fin_time(sk);</span><span class="line"></span><span class="line">            <span class="keyword">if</span> (tmo &gt; TCP_TIMEWAIT_LEN) &#123;</span><span class="line">                inet_csk_reset_keepalive_timer(sk,</span><span class="line">                        tmo - TCP_TIMEWAIT_LEN);</span><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><span class="line">                tcp_time_wait(sk, TCP_FIN_WAIT2, tmo);</span><span class="line">                <span class="keyword">goto</span> out;</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state != TCP_CLOSE) &#123;</span><span class="line">        sk_mem_reclaim(sk);</span><span class="line">        <span class="keyword">if</span> (tcp_check_oom(sk, <span class="number">0</span>)) &#123;</span><span class="line">            tcp_set_state(sk, TCP_CLOSE);</span><span class="line">            tcp_send_active_reset(sk, GFP_ATOMIC);</span><span class="line">            __NET_INC_STATS(sock_net(sk),</span><span class="line">                    LINUX_MIB_TCPABORTONMEMORY);</span><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!check_net(sock_net(sk))) &#123;</span><span class="line">            <span class="comment">/* Not possible to send reset; just close */</span></span><span class="line">            tcp_set_state(sk, TCP_CLOSE);</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state == TCP_CLOSE) &#123;</span><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">request_sock</span> *<span class="title">req</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>)-&gt;<span class="title">fastopen_rsk</span>;</span></span><span class="line">        <span class="comment">/* We could get here with a non-NULL req if the socket is</span></span><span class="line"><span class="comment">         * aborted (e.g., closed with unread data) before 3WHS</span></span><span class="line"><span class="comment">         * finishes.</span></span><span class="line"><span class="comment">         */</span></span><span class="line">        <span class="keyword">if</span> (req)</span><span class="line">            reqsk_fastopen_remove(sk, req, <span class="literal">false</span>);</span><span class="line">        inet_csk_destroy_sock(sk);</span><span class="line">    &#125;</span><span class="line">    <span class="comment">/* Otherwise, socket is reprieved until protocol close. */</span></span><span class="line"></span><span class="line">out:</span><span class="line">    bh_unlock_sock(sk);</span><span class="line">    local_bh_enable();</span><span class="line">    release_sock(sk);</span><span class="line">    sock_put(sk);</span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>上面源码第 2371 行是 linger 结构体的字段 l_onoff 为<code>1</code>而 l_linger 为<code>0</code>的情况，此时调用<code>sk-&gt;sk_prot-&gt;disconnect(sk, 0)</code> -&gt; <code>tcp_disconnect()</code>函数，丢失所有接收数据并且直接断开连接，具体也就是发送 RST 数据包，清空相关接收队列；第 2375 行到第 2405 行代码属于正常的结束流程，即四次挥手，此时需先调用函数<code>tcp_close_state()</code>切换状态，并判断是否需要发送 FIN 数据包（比如，如果当前还处于 TCP_SYN_SENT 状态，连接尚未完全建立，自然就不用发送 FIN 数据包），如果需要发送 FIN 数据包则调用<code>tcp_send_fin()</code>函数。</p>
<h2 id="关于-TIME-WAIT-状态优化"><a href="#关于-TIME-WAIT-状态优化" class="headerlink" title="关于 TIME_WAIT 状态优化"></a>关于 TIME_WAIT 状态优化</h2><p>网上常可以看到类似如下的优化设置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><i class="fa fa-usd"></i> <span class="built_in">echo</span> 30 &gt; /proc/sys/net/ipv4/tcp_fin_timeout</span><span class="line"></span><span class="line"><span class="comment"># only for positive close endpoint</span></span><span class="line"><i class="fa fa-usd"></i> <span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/tcp_tw_reuse</span><span class="line"></span><span class="line"><span class="comment"># don't run below cmd</span></span><span class="line"><i class="fa fa-usd"></i> <span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/tcp_tw_recycle</span></pre></td></tr></table></figure>
<h3 id="关于-tcp-tw-recycle"><a href="#关于-tcp-tw-recycle" class="headerlink" title="关于 tcp_tw_recycle"></a>关于 tcp_tw_recycle</h3><p>上面的设置有问题，尤其是<code>tcp_tw_recycle</code>，并且从 Linux-4.12 之后移除了<code>tcp_tw_recycle</code>这个选项，更多细节可参考此文章 <a href="https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux" target="_blank" rel="noopener">Coping with the TCP TIME-WAIT state on busy Linux servers</a>。</p>
<h3 id="关于-tcp-tw-reuse-参数说明"><a href="#关于-tcp-tw-reuse-参数说明" class="headerlink" title="关于 tcp_tw_reuse 参数说明"></a>关于 tcp_tw_reuse 参数说明</h3><p>TIME-WAIT 状态是为了防止不相关的延迟请求包被接受。但在某些特定条件下很有可能出现新建立的 TCP 连接请求包被老连接（同样的四元组，暂时还是 TIME-WAIT 状态，回收中）错误处理。</p>
<p>RFC1323 提供了一组 TCP 扩展，以提高高带宽路径的性能。除此之外，它还定义了一个带有两个四字节时间戳字段的新 TCP 选项，第一个是 TCP 发送方的当前时钟时间戳，而第二个是从远程主机接收到的最新时间戳。</p>
<p>通过启用<code>net.ipv4.tcp_tw_reuse</code>，如果新时间戳严格大于为先前连接记录的最新时间戳，则 Linux 将重新使用 TIME-WAIT 状态的现有连接用于新的传出连接：TIME-WAIT 状态中的连接可在一秒钟后重复使用。</p>
<h4 id="tcp-tw-reuse-安全性"><a href="#tcp-tw-reuse-安全性" class="headerlink" title="tcp_tw_reuse 安全性"></a>tcp_tw_reuse 安全性</h4><p>如果另一端发过来的 FIN 包接及时收到，本地端的 ACK 包也被发送出去，则本地端进入 TIME-WAIT 状态。一旦新的连接替换了状态为 TIME-WAIT 的旧连接，新连接的 SYN 包会被另一端忽略掉（由于时间戳 timestamps），也不会应答 RST 包（注意与前面那张使用相同的四元组打开的新连接被 RST 的区别，如果没有时间戳这里直接返回 RST 包并关闭连接），而是通过重新传输 FIN 段来应答，如下图所示。FIN 包将会收到一个 RST 包的应答（因为本地连接是 SYN-SENT 状态），这会让远程端跳过 LAST-ACK 状态。最初的 SYN 段最终将被重新发送（一秒钟后），因为没有应答，并且建立连接时没有明显的错误，除了稍微延迟。</p>
<img src="/blog/img/linux/tcp/tcp-close-last-ack-reuse.svg" title="[If the remote end stays in LAST-ACK state because the last ACK was lost, the remote connection will be reset when the local end transition to the SYN-SENT state]">
<p>在客户端（尤其是服务器上，某服务以客户端形式运行时，比如 nginx 反向代理）上启用<code>net.ipv4.tcp_tw_reuse</code>，还算是安全的解决 TIME-WAIT 的方案。</p>
<h2 id="MSL-设置"><a href="#MSL-设置" class="headerlink" title="MSL 设置"></a>MSL 设置</h2><p>MSL(Maximum Segment Lifetime)是最大分节生命期，一般为<code>60 秒</code>(linux)，<code>120 秒</code>(Windows)，有些系统则是<code>30 秒</code>，Windows 也是建议为<code>30 秒</code>。</p>
<h3 id="Linux-MSL-查看和设置"><a href="#Linux-MSL-查看和设置" class="headerlink" title="Linux MSL 查看和设置"></a>Linux MSL 查看和设置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><i class="fa fa-usd"></i> <span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_fin_timeout</span><span class="line"><span class="comment"># setting</span></span><span class="line"><i class="fa fa-usd"></i> <span class="built_in">echo</span> 30 &gt; /proc/sys/net/ipv4/tcp_fin_timeout</span></pre></td></tr></table></figure>
<h3 id="Windows-MSL-设置"><a href="#Windows-MSL-设置" class="headerlink" title="Windows MSL 设置"></a>Windows MSL 设置</h3><p>注册表项<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters</code>，<code>value</code>设置为<code>TcpTimedWaitDelay</code>，<code>REG_DWORD</code>类型，默认值为 16 进制的<code>0x78</code>，即<code>120 秒</code>，推荐值为<code>30 秒</code>。</p>
<h2 id="Java-server-client-example"><a href="#Java-server-client-example" class="headerlink" title="Java server/client example"></a>Java server/client example</h2><p>Java 代码演示 SO_LINGER 参数设置，关键代码<code>socket.setSoLinger(true, 0)</code>，先启动服务端，再启动客户端程序：</p>
<h3 id="SocketTcpSoLingerServer-java"><a href="#SocketTcpSoLingerServer-java" class="headerlink" title="SocketTcpSoLingerServer.java"></a>SocketTcpSoLingerServer.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketTcpSoLingerServer</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SocketTcpSoLingerServer<span class="class">.<span class="keyword">class</span>)</span>;</span><span class="line"></span><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">8888</span>;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket();</span><span class="line">        serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><span class="line"></span><span class="line">        LOGGER.info(<span class="string">"server startup at &#123;&#125;"</span>, PORT);</span><span class="line"></span><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32</span>];</span><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><span class="line">            Socket socket = serverSocket.accept();</span><span class="line">            LOGGER.info(<span class="string">"1. socket so linger : &#123;&#125;"</span>, socket.getSoLinger());</span><span class="line">            socket.setSoLinger(<span class="keyword">true</span>, <span class="number">0</span>);</span><span class="line">            <span class="comment">// socket.setSoLinger(true, 100);</span></span><span class="line">            LOGGER.info(<span class="string">"2. socket so linger : &#123;&#125;"</span>, socket.getSoLinger());</span><span class="line"></span><span class="line">            <span class="keyword">try</span> (InputStream in = socket.getInputStream();</span><span class="line">                 OutputStream out = socket.getOutputStream()) &#123;</span><span class="line">                <span class="keyword">int</span> i = <span class="number">1</span>;</span><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><span class="line">                    <span class="keyword">try</span> &#123;</span><span class="line">                        <span class="keyword">int</span> read = in.read(data);</span><span class="line">                        <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><span class="line">                            String line = <span class="keyword">new</span> String(data, <span class="number">0</span>, read);</span><span class="line">                            <span class="comment">// 延时返回，客户端要发送 FIN 包，即调用 socket.shutdownOutput()</span></span><span class="line">                            TimeUnit.MILLISECONDS.sleep(<span class="number">1500L</span>);</span><span class="line">                            LOGGER.info(<span class="string">"&#123;&#125; : &#123;&#125;"</span>, i++, line);</span><span class="line">                            out.write(line.getBytes());</span><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123;</span><span class="line">                            LOGGER.info(<span class="string">"close socket"</span>);</span><span class="line">                            socket.close();</span><span class="line">                            <span class="keyword">break</span>;</span><span class="line">                        &#125;</span><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><span class="line">                        LOGGER.error(<span class="string">"close socket for error"</span>, e);</span><span class="line">                        socket.close();</span><span class="line">                        <span class="keyword">break</span>;</span><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><span class="line">                        e.printStackTrace();</span><span class="line">                    &#125;</span><span class="line">                &#125;</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="SocketTcpSoLingerClient-java"><a href="#SocketTcpSoLingerClient-java" class="headerlink" title="SocketTcpSoLingerClient.java"></a>SocketTcpSoLingerClient.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketTcpSoLingerClient</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SocketTcpSoLingerClient<span class="class">.<span class="keyword">class</span>)</span>;</span><span class="line"></span><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">8888</span>;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, PORT);</span><span class="line"></span><span class="line">        <span class="keyword">try</span> (InputStream socketInputStream = socket.getInputStream();</span><span class="line">             OutputStream socketOutputStream = socket.getOutputStream()) &#123;</span><span class="line"></span><span class="line">            String head = <span class="string">"hello "</span>;</span><span class="line">            String body = <span class="string">"world"</span>;</span><span class="line">            socketOutputStream.write(head.getBytes());</span><span class="line">            socketOutputStream.write(body.getBytes());</span><span class="line"></span><span class="line">            <span class="comment">// 如果客户端不关闭输出，则服务器和客户端都收不到关闭的 FIN 包，从而连接会一直保持</span></span><span class="line">            <span class="keyword">boolean</span> shutdownOutput = <span class="keyword">true</span>;</span><span class="line">            <span class="comment">// boolean shutdownOutput = false;</span></span><span class="line">            <span class="keyword">if</span> (shutdownOutput) &#123;</span><span class="line">                <span class="comment">// 这里调用了 socket.shutdownOutput()返回时，hello 和 world 未必已经成功发送到对方了</span></span><span class="line">                socket.shutdownOutput();</span><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><span class="line">                <span class="comment">// 用定时器来延时关闭连接</span></span><span class="line">                <span class="comment">// 等 3 秒是为了让服务器全部输出完成，双方一起关闭</span></span><span class="line">                <span class="keyword">final</span> Timer timer = <span class="keyword">new</span> Timer();</span><span class="line">                timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><span class="line">                    <span class="meta">@Override</span></span><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><span class="line">                        <span class="keyword">try</span> &#123;</span><span class="line">                            LOGGER.info(<span class="string">"socket shutdown output in timer : &#123;&#125;"</span>, timer);</span><span class="line">                            socket.shutdownOutput();</span><span class="line">                            timer.cancel();</span><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><span class="line">                            LOGGER.error(<span class="string">"socket shutdown error"</span>, e);</span><span class="line">                        &#125;</span><span class="line">                    &#125;</span><span class="line">                &#125;, <span class="number">3000L</span>);</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            LOGGER.info(<span class="string">"socket shutdown output"</span>);</span><span class="line"></span><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>;</span><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32</span>];</span><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><span class="line">                <span class="keyword">int</span> read = socketInputStream.read(data);</span><span class="line">                <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><span class="line">                    String line = <span class="keyword">new</span> String(data, <span class="number">0</span>, read);</span><span class="line">                    LOGGER.info(<span class="string">"&#123;&#125; : &#123;&#125;"</span>, i++, line);</span><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123;</span><span class="line">                    LOGGER.info(<span class="string">"socket closed"</span>);</span><span class="line">                    socket.close();</span><span class="line">                    <span class="keyword">break</span>;</span><span class="line">                &#125;</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="数据抓包截图"><a href="#数据抓包截图" class="headerlink" title="数据抓包截图"></a>数据抓包截图</h3><p>上面的 Java 程序运行后，抓包截图如下，可以看到第 9 行在客户端发送 FIN 包之后，TCP 连接形成半闭状态，服务端仍然在发送数据给客户端，最后客户端 ACK 确认接收完数据，服务器不是正常回应以 FIN 包，而是一个 RST 包，双方完成连接关闭：</p>
<img src="/blog/img/linux/tcp/solinger/server-socket-solinger-true-0-java-client.png" class="image-hg" title="[server-socket-solinger-true-0-java-client.png]">
<h2 id="总结-SO-LINGER-参数用法"><a href="#总结-SO-LINGER-参数用法" class="headerlink" title="总结 SO_LINGER 参数用法"></a>总结 SO_LINGER 参数用法</h2><p>慎重使用<code>on=true, linger=0</code>，使用 RST 代替 FIN 直接强制关闭连接，主动关闭的一方也不会进入 TIME_WAIT 阶段，会减少系统的连接数，提高并发连接能力，但是这种异常关闭连接的方式，TCP 连接关闭的 TIME_WAIT 的作用也就没有了，是个有利有弊的用法，尽量不要使用，而是通过设计应用层协议来避免 TIME_WAIT 连接过多的问题。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a href="https://github.com/torvalds/linux/blob/v5.0/net/ipv4/tcp.c" target="_blank" rel="noopener">Linux TCP 源码</a></li>
<li><a href="http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch02.html" target="_blank" rel="noopener">Chapter 2. The Transport Layer: TCP, UDP, and SCTP</a></li>
<li><a href="https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux" target="_blank" rel="noopener">Coping with the TCP TIME-WAIT state on busy Linux servers</a></li>
<li><a href="http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch04lev1sec5.html" target="_blank" rel="noopener">4.5 listen Function</a></li>
<li><a href="http://www.pcvr.nl/tcpip/tcp_conn.htm#18_2" target="_blank" rel="noopener">TCP Connection Establishment and Termination</a></li>
<li><a href="http://docs.52im.net/extend/docs/book/tcpip/vol1/18/" target="_blank" rel="noopener">第 18 章 TCP 连接的建立与终止</a></li>
<li><a href="https://docs.microsoft.com/en-us/biztalk/technical-guides/settings-that-can-be-modified-to-improve-network-performance" target="_blank" rel="noopener">Settings that can be Modified to Improve Network Performance</a></li>
<li><a href="https://stackoverflow.com/questions/3757289/tcp-option-so-linger-zero-when-its-required" target="_blank" rel="noopener">When to use SO_LINGER with timeout 0</a></li>
<li><a href="http://www.lenky.info/archives/2013/02/2220" target="_blank" rel="noopener">Socket 选项系列之 SO_LINGER</a></li>
<li><a href="https://docs.microsoft.com/en-us/biztalk/technical-guides/settings-that-can-be-modified-to-improve-network-performance" target="_blank" rel="noopener">Adjust the MaxUserPort and TcpTimedWaitDelay settings</a></li>
<li><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=4396e46187ca5070219b81773c4e65088dac50cc" target="_blank" rel="noopener">tcp: remove tcp_tw_recycle</a></li>
<li><a href="http://www.cnxct.com/coping-with-the-tcp-time_wait-state-on-busy-linux-servers-in-chinese-and-dont-enable-tcp_tw_recycle/" target="_blank" rel="noopener">不要在 linux 上启用 net.ipv4.tcp_tw_recycle 参数</a></li>
<li><a href="/blog/linux/2016/08/06/tcp-open-and-close.html">tcp connection open and close</a></li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/linux/2019/03/23/vim-plugin-vim-space-doc.html" rel="next" title="vim plugin vim-space doc">
                <i class="fa fa-chevron-left"></i>
                vim plugin vim-space doc
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/web/2019/04/09/http-cross-origin-resource-sharing-cors.html" rel="prev" title="cross origin resource sharing - cors">
                <i class="fa fa-chevron-right"></i>
                cross origin resource sharing - cors
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/blog/images/avatar.jpg" alt="yuweijun">
          <p class="site-author-name" itemprop="name">yuweijun</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/blog/archives">
              <span class="site-state-item-count">492</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">categories</span>
              
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/blog/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yuweijun" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/yuweijun" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#java-Socket-SO-LINGER-设置方法源码"><span class="nav-number">1.</span> <span class="nav-text">java Socket SO_LINGER 设置方法源码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Socket-SO-LINGER-参数设置说明"><span class="nav-number">2.</span> <span class="nav-text">Socket SO_LINGER 参数设置说明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#on-false"><span class="nav-number">2.1.</span> <span class="nav-text">on = false</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#on-true-linger-gt-0"><span class="nav-number">2.2.</span> <span class="nav-text">on = true, linger &gt; 0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#on-true-linger-0"><span class="nav-number">2.3.</span> <span class="nav-text">on = true, linger = 0</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试-sock-程序下载"><span class="nav-number">3.</span> <span class="nav-text">测试 sock 程序下载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正常四次挥手关闭连接过程"><span class="nav-number">4.</span> <span class="nav-text">正常四次挥手关闭连接过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发送-RST-异常终止一个连接"><span class="nav-number">5.</span> <span class="nav-text">发送 RST 异常终止一个连接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-IP-Illustrated-Aborting-a-Connection"><span class="nav-number">5.1.</span> <span class="nav-text">TCP/IP Illustrated - Aborting a Connection</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RST-终止连接示例"><span class="nav-number">6.</span> <span class="nav-text">RST 终止连接示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stackoverflow-com-上关于-TCP-linger-true-timeout-0-的讨论"><span class="nav-number">7.</span> <span class="nav-text">stackoverflow.com 上关于 TCP linger=true, timeout=0 的讨论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#UNIX-Network-Programming-2-7-TIME-WAIT-State"><span class="nav-number">7.1.</span> <span class="nav-text">UNIX Network Programming - 2.7 TIME_WAIT State</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UNIX-Network-Programming-7-4-SO-LINGER-Socket-Option"><span class="nav-number">7.2.</span> <span class="nav-text">UNIX Network Programming - 7.4 SO_LINGER Socket Option</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Purposes-for-the-TIME-WAIT-state"><span class="nav-number">7.3.</span> <span class="nav-text">Purposes for the TIME-WAIT state</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-状态变化示意图"><span class="nav-number">8.</span> <span class="nav-text">TCP 状态变化示意图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#When-to-use-SO-LINGER-with-timeout-0"><span class="nav-number">8.1.</span> <span class="nav-text">When to use SO_LINGER with timeout 0</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-TCP-SO-LINGER-相关源码"><span class="nav-number">9.</span> <span class="nav-text">Linux TCP SO_LINGER 相关源码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于-TIME-WAIT-状态优化"><span class="nav-number">10.</span> <span class="nav-text">关于 TIME_WAIT 状态优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关于-tcp-tw-recycle"><span class="nav-number">10.1.</span> <span class="nav-text">关于 tcp_tw_recycle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于-tcp-tw-reuse-参数说明"><span class="nav-number">10.2.</span> <span class="nav-text">关于 tcp_tw_reuse 参数说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp-tw-reuse-安全性"><span class="nav-number">10.2.1.</span> <span class="nav-text">tcp_tw_reuse 安全性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MSL-设置"><span class="nav-number">11.</span> <span class="nav-text">MSL 设置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-MSL-查看和设置"><span class="nav-number">11.1.</span> <span class="nav-text">Linux MSL 查看和设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows-MSL-设置"><span class="nav-number">11.2.</span> <span class="nav-text">Windows MSL 设置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-server-client-example"><span class="nav-number">12.</span> <span class="nav-text">Java server/client example</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SocketTcpSoLingerServer-java"><span class="nav-number">12.1.</span> <span class="nav-text">SocketTcpSoLingerServer.java</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SocketTcpSoLingerClient-java"><span class="nav-number">12.2.</span> <span class="nav-text">SocketTcpSoLingerClient.java</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据抓包截图"><span class="nav-number">12.3.</span> <span class="nav-text">数据抓包截图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-SO-LINGER-参数用法"><span class="nav-number">13.</span> <span class="nav-text">总结 SO_LINGER 参数用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#References"><span class="nav-number">14.</span> <span class="nav-text">References</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-github"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yuweijun</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist.KISS
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>











  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.0.0/jquery.min.js"></script>

  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>

  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>

  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.3.1/velocity.min.js"></script>

  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.3.1/velocity.ui.min.js"></script>


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/blog/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/blog/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
