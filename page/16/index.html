<!doctype html>




<html class="theme-next mist">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">


















  

<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">






  <link rel="alternate" href="/blog/atom.xml" title="一" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/blog/favicon.ico?v=5.0.1">






<meta property="og:type" content="website">
<meta property="og:title" content="一">
<meta property="og:url" content="http://www.4e00.com/page/16/index.html">
<meta property="og:site_name" content="一">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide"},
    fancybox: false,
    motion: false,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://www.4e00.com/blog/page/16/">

  <title> 一 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/blog/" class="brand" rel="start">
      <span class="site-title">一</span>
    </a>
  </div>
  <p class="site-subtitle">{"type":"编程笔记"}</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      <li class="menu-item menu-item-search">
        <a href="https://www.google.com.hk/search?q=site%3Ahttp://www.4e00.com/blog/" class="popup-trigger">
          <i class="menu-item-icon fa fa-search fa-fw"></i>Search
        </a>
      </li>
    </ul>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/java/2016/11/12/java-override-and-overload.html" itemprop="url">
                  java override and overload
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-11-12T19:00:09+08:00" content="2016-11-12">
              2016-11-12
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="//schema.org/Thing">
                  <a href="/blog/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>方法的重写<code>Overriding</code>和重载<code>Overloading</code>是java多态性的不同表现，<code>重写</code>是父类与子类之间的多态性的一种表现，而<code>重载</code>则是主要是在同一个类中表现出多态性。</p>
<h2 id="相关术语说明"><a href="#相关术语说明" class="headerlink" title="相关术语说明"></a>相关术语说明</h2><ol>
<li>多态：<code>polymorphism</code>，在面向对象的程序设计语言中，多态是继数据封装和继承之后的第三个基本特征。多态是分离做什么和怎么做，从另一个角度将接口和实现分离开来，将改变的事物与未变的事物分离开来。多态也称作动态绑定、后期绑定或者运行时绑定。将一个方法调用和一个方法体连接起来就称为绑定，C语言在编译期就连接了实际运行的方法体，所以就是前期绑定。</li>
<li>方法重写：<code>Override</code>，在子类中重写覆盖父类中对于子类可见的方法，方法重写也被称为运行时多态。</li>
<li>方法重载：<code>Overload</code>，重载是在一个类里面，方法名字相同而参数不同，返回类型可以相同也可以不同的方法，可以是静态方法，也可以是实例方法，最常用的地方就是构造器的重载，方法重载也被称为编译时多态。</li>
<li>方法调用：方法调用不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本，即调用哪个签名的方法，不涉及方法运行的内部细节，在编译期就已经确定。</li>
<li>方法执行：方法执行是在运行期，根据方法的接收者的实际类型，连接方法到JVM方法区的直接引用，执行引用指向的方法体。</li>
<li>方法签名：方法签名包括方法名称和参数的数量和类型，返回类型和抛出异常并不认为是一个方法签名的一部分。另外在JVM中还有一个字节码的特征签名，特征签名中还包括了方法返回值和受检异常表，从而在字节码中形成一个真正独一无二的方法ID。</li>
<li>方法体：运行期执行的实际类型的方法所包括的代码。</li>
<li>方法接收者：<code>Receiver</code>，即运行期被执行方法的所有者，方法所在的实例对象。</li>
<li>静态方法：即类方法，而对象实例调用的方法则称为实例方法。</li>
<li>静态类型：方法签名中参数变量声明的类型称为静态类型(<code>static type</code>)或者是外观类型(<code>apparent type</code>)，而参数传入对象的实际类型(<code>actual type</code>)可以是静态类型的子类或者实现类。</li>
<li>实际类型：方法执行的接收者的实际类型，方法参数传入的实际类型，参数通过方法暴露出来的可能是接口名或者基类名，实际传入的是其子类或者实现类的实例。</li>
<li>符号引用：一个类文件，它会包含它引用的其他类的全名和描述符，并跟他们建立符号引用，符号引用是一种虚拟的，非物理连接的方式。java在编译期间已经将方法调用的完整符号引用生成出来，作为方法调用指令的参数存储到class文件中。这个符号引用包含了此方法定义在哪个具体类型中，方法的名字和参数顺序，参数类型和方法返回值等信息。反编译class文件可以看到，字节码的方法调用就以class常量池中指向方法的符号引用作为参数，这些符号引用一部分如static方法调用，在类加载解析阶段或者第一次使用时就被转化为直接引用，这部分称为静态解析，而虚方法的符号引用到运行期才会转化为直接引用，这部分称为动态连接。</li>
<li>直接引用：当程序第一次执行到符号引用的位置时，JVM会检查这个符号链接的正确性，然后建立真正的物理引用，即直接引用，使用直接引用指向一个类、字段或方法的指针或偏移量。虚拟机会记住这个直接引用，这样当它以后再次遇到同样的引用时，就可以直接使用，而不需要重新解析该符号引用了。</li>
<li>编译期：通过javac这样的编译器将java源文件编译生成class文件。</li>
<li>运行期：在JVM中把class文件翻译成机器语言后运行，<code>HotSpot</code>中默认是编译器加解释器混合模式协作完成字节码的运行。</li>
<li>虚方法：除<code>final</code>方法(<code>private</code>方法也是<code>final</code>方法)之外的所有实例方法就是虚方法，也就是<code>public</code>、<code>protected</code>、<code>default</code>的三种实例方法都是虚方法，虚方法对应的虚拟机指令是invokevirtual。</li>
<li>非虚方法：java中除了<code>static</code>方法和<code>final</code>方法(<code>private</code>方法实际上是<code>final</code>方法)之外，其他所有方法都是虚方法，是后期绑定的，之所以将定义方法为<code>final</code>，为了避免被子类继承外，这样也可以有效的“关闭”动态绑定，告诉编译器不需要动态绑定，在类加载的解析阶段就会连接方法的直接引用。<code>static</code>方法和<code>private</code>方法与之对应的虚拟机指令是<code>invokestatic</code>和<code>invokespecial</code>，<code>final</code>方法的虚拟机指令是<code>invokevirtual</code>。构造方法是invokespecial指令执行的，不是<code>static</code>方法，因为默认传入了新new的对象，并在其中操作实例属性和方法，更多类似于实例方法，但却不是虚方法，即没有后期绑定的。</li>
<li>类加载：虚拟机通过类加载器对某个类进行加载操作，类加载会经过加载、验证、准备、解析、初始化、使用、卸载这些阶段，非虚方法的符号引用在解析阶段就会被连接到JVM方法区的目标方法的直接引用。</li>
</ol>
<h2 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写 - Override"></a>重写 - Override</h2><p>在子类中重写覆盖父类中对于子类可见的方法，实现子类的特定功能，如需执行父类被覆盖的方法，可以通过<code>super</code>进行引用。</p>
<h3 id="Override规则"><a href="#Override规则" class="headerlink" title="Override规则"></a>Override规则</h3><ol>
<li>参数列表必须完全与被重写方法的相同；</li>
<li>返回类型必须完全与被重写方法的返回类型相同；</li>
<li>访问权限不能比父类中被重写的方法的访问权限更高。例如：如果父类的一个方法被声明为<code>public</code>，那么在子类中重写该方法就不能声明为<code>protected</code>。</li>
<li>父类的成员方法只能被它的子类重写。</li>
<li>声明为<code>final</code>的方法不能被重写。</li>
<li>声明为<code>static</code>的方法不能被重写，但是能够被再次声明。</li>
<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为<code>private</code>和<code>final</code>的方法。</li>
<li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为<code>public</code>和<code>protected</code>的非<code>final</code>方法。</li>
<li>重写的方法能够抛出任何非受检异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的受检异常，或者比被重写方法声明的更广泛的受检异常，反之则可以。</li>
<li>重写的方法能够抛出更少或更有限的异常，也就是说，被重写的方法声明了异常，但重写的方法可以什么也不声明。</li>
<li>构造方法不能被重写。</li>
<li>如果不能继承一个方法，则不能重写这个方法。</li>
</ol>
<h3 id="Override示例"><a href="#Override示例" class="headerlink" title="Override示例"></a>Override示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverrideExample</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OverrideParent</span> </span>&#123;</span><span class="line"></span><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Number number)</span> </span>&#123;</span><span class="line">            System.out.println(number);</span><span class="line">            System.out.println(<span class="string">"Parent#print(Number) method print : "</span> + <span class="keyword">this</span>.getClass().getSimpleName());</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        <span class="comment">// 这个方法不但重载了 print(Number) 方法，而且被子类重写了</span></span><span class="line">        <span class="comment">// 父类的被重写的方法抛出的异常要宽于子类抛出的异常</span></span><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><span class="line">            System.out.println(integer);</span><span class="line">            System.out.println(<span class="string">"Parent#print(Integer) method print : "</span> + <span class="keyword">this</span>.getClass().getSimpleName());</span><span class="line">        &#125;</span><span class="line"></span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OverrideChild</span> <span class="keyword">extends</span> <span class="title">OverrideParent</span> </span>&#123;</span><span class="line"></span><span class="line">        <span class="meta">@Override</span></span><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> EOFException </span>&#123;</span><span class="line">            System.out.println(integer);</span><span class="line">            System.out.println(<span class="string">"Child#print(Number) method print : "</span> + <span class="keyword">this</span>.getClass().getSimpleName());</span><span class="line">        &#125;</span><span class="line"></span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><span class="line">        OverrideParent parent = <span class="keyword">new</span> OverrideParent();</span><span class="line">        OverrideParent child = <span class="keyword">new</span> OverrideChild();</span><span class="line"></span><span class="line">        Number number = <span class="keyword">new</span> Long(<span class="string">"1"</span>);</span><span class="line">        Integer integer = <span class="keyword">new</span> Integer(<span class="string">"2"</span>);</span><span class="line"></span><span class="line">        parent.print(number);</span><span class="line">        parent.print(integer);</span><span class="line"></span><span class="line">        child.print(number);</span><span class="line">        child.print(integer);</span><span class="line">    &#125;</span><span class="line"></span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>子类重写父类的方法时，可以不抛出异常，或者是更小的异常，比如示例中的<code>IOException</code>的子类<code>EOFException</code>，但不能抛出更广的异常，如<code>Exception</code>。</p>
<p>程序运行后输出：</p>
<blockquote>
<p>1</p>
<p>Parent#print(Number) method print : OverrideParent</p>
<p>2</p>
<p>Parent#print(Integer) method print : OverrideParent</p>
<p>1</p>
<p>Parent#print(Number) method print : OverrideChild</p>
<p>2</p>
<p>Child#print(Number) method print : OverrideChild</p>
</blockquote>
<h3 id="Override示例运行结果详解"><a href="#Override示例运行结果详解" class="headerlink" title="Override示例运行结果详解"></a>Override示例运行结果详解</h3><p>为了更好的说明方法重写，将上述代码生成的class文件反编译，查看class中生成的java字节码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><i class="fa fa-usd"></i> <span class="built_in">javap</span> -c com.example.test.lang.OverrideExample</span></pre></td></tr></table></figure>
<blockquote>
<p>-c   Prints out disassembled code, that is, the instructions that comprise the Java bytecodes, for each of the methods in the class. These  are documented in the Java Virtual Machine Specification.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Compiled from &quot;OverrideExample.java&quot;</span><span class="line">public class com.example.test.lang.OverrideExample &#123;</span><span class="line">  public com.example.test.lang.OverrideExample();</span><span class="line">    Code:</span><span class="line">       0: aload_0</span><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><span class="line">       4: return</span><span class="line"></span><span class="line">  public static void main(java.lang.String[]) throws java.io.IOException;</span><span class="line">    Code:</span><span class="line">       0: new           #2                  // class com/example/test/lang/OverrideExample$OverrideParent</span><span class="line">       3: dup</span><span class="line">       4: invokespecial #3                  // Method com/example/test/lang/OverrideExample$OverrideParent.&quot;&lt;init&gt;&quot;:()V</span><span class="line">       7: astore_1</span><span class="line">       8: new           #4                  // class com/example/test/lang/OverrideExample$OverrideChild</span><span class="line">      11: dup</span><span class="line">      12: invokespecial #5                  // Method com/example/test/lang/OverrideExample$OverrideChild.&quot;&lt;init&gt;&quot;:()V</span><span class="line">      15: astore_2</span><span class="line">      16: new           #6                  // class java/lang/Long</span><span class="line">      19: dup</span><span class="line">      20: ldc           #7                  // String 1</span><span class="line">      22: invokespecial #8                  // Method java/lang/Long.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><span class="line">      25: astore_3</span><span class="line">      26: new           #9                  // class java/lang/Integer</span><span class="line">      29: dup</span><span class="line">      30: ldc           #10                 // String 2</span><span class="line">      32: invokespecial #11                 // Method java/lang/Integer.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><span class="line">      35: astore        4</span><span class="line">      37: aload_1</span><span class="line">      38: aload_3</span><span class="line">      39: invokevirtual #12                 // Method com/example/test/lang/OverrideExample$OverrideParent.print:(Ljava/lang/Number;)V</span><span class="line">      42: aload_1</span><span class="line">      43: aload         4</span><span class="line">      45: invokevirtual #13                 // Method com/example/test/lang/OverrideExample$OverrideParent.print:(Ljava/lang/Integer;)V</span><span class="line">      48: aload_2</span><span class="line">      49: aload_3</span><span class="line">      50: invokevirtual #12                 // Method com/example/test/lang/OverrideExample$OverrideParent.print:(Ljava/lang/Number;)V</span><span class="line">      53: aload_2</span><span class="line">      54: aload         4</span><span class="line">      56: invokevirtual #13                 // Method com/example/test/lang/OverrideExample$OverrideParent.print:(Ljava/lang/Integer;)V</span><span class="line">      59: return</span><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="关于符号引用"><a href="#关于符号引用" class="headerlink" title="关于符号引用"></a>关于符号引用</h4><p>javap反编译时加上<code>-verbose</code>参数可以看到更详细的信息，如主次版本，常量池中的类、方法、变量的符号引用，每个方法的栈深和局部变量数量等信息。</p>
<p>常量池主要用于存放两大类常量：字面量(Literal)和符号引用量(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：</p>
<ol>
<li>类和接口的全限定名</li>
<li>字段名称和描述符</li>
<li>方法名称和描述符</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><i class="fa fa-usd"></i> <span class="built_in">javap</span> -c -verbose com.example.test.lang.OverrideExample</span></pre></td></tr></table></figure>
<p>命令输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Classfile /Users/david/github.com/learning-programming/java/target/test-classes/com/example/test/lang/OverrideExample.class</span><span class="line">  Last modified Nov 15, 2016; size 1117 bytes</span><span class="line">  MD5 checksum bc597130acffb600f30c658477471ad3</span><span class="line">  Compiled from &quot;OverrideExample.java&quot;</span><span class="line">public class com.example.test.lang.OverrideExample</span><span class="line">  minor version: 0</span><span class="line">  major version: 52</span><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><span class="line">Constant pool:</span><span class="line">   #1 = Methodref          #15.#41        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><span class="line">   #2 = Class              #42            // com/example/test/lang/OverrideExample$OverrideParent</span><span class="line">   #3 = Methodref          #2.#41         // com/example/test/lang/OverrideExample$OverrideParent.&quot;&lt;init&gt;&quot;:()V</span><span class="line">   #4 = Class              #43            // com/example/test/lang/OverrideExample$OverrideChild</span><span class="line">   #5 = Methodref          #4.#41         // com/example/test/lang/OverrideExample$OverrideChild.&quot;&lt;init&gt;&quot;:()V</span><span class="line">   #6 = Class              #44            // java/lang/Long</span><span class="line">   #7 = String             #45            // 1</span><span class="line">   #8 = Methodref          #6.#46         // java/lang/Long.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><span class="line">   #9 = Class              #47            // java/lang/Integer</span><span class="line">  #10 = String             #48            // 2</span><span class="line">  #11 = Methodref          #9.#46         // java/lang/Integer.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><span class="line">  #12 = Methodref          #2.#49         // com/example/test/lang/OverrideExample$OverrideParent.print:(Ljava/lang/Number;)V</span><span class="line">  #13 = Methodref          #2.#50         // com/example/test/lang/OverrideExample$OverrideParent.print:(Ljava/lang/Integer;)V</span><span class="line">  #14 = Class              #51            // com/example/test/lang/OverrideExample</span><span class="line">  #15 = Class              #52            // java/lang/Object</span><span class="line">  #16 = Utf8               OverrideChild</span><span class="line">  #17 = Utf8               InnerClasses</span><span class="line">  #18 = Utf8               OverrideParent</span><span class="line">  #19 = Utf8               &lt;init&gt;</span><span class="line">  #20 = Utf8               ()V</span><span class="line">  #21 = Utf8               Code</span><span class="line">  #22 = Utf8               LineNumberTable</span><span class="line">  #23 = Utf8               LocalVariableTable</span><span class="line">  #24 = Utf8               this</span><span class="line">  #25 = Utf8               Lcom/example/test/lang/OverrideExample;</span><span class="line">  #26 = Utf8               main</span><span class="line">  #27 = Utf8               ([Ljava/lang/String;)V</span><span class="line">  #28 = Utf8               args</span><span class="line">  #29 = Utf8               [Ljava/lang/String;</span><span class="line">  #30 = Utf8               parent</span><span class="line">  #31 = Utf8               Lcom/example/test/lang/OverrideExample$OverrideParent;</span><span class="line">  #32 = Utf8               child</span><span class="line">  #33 = Utf8               number</span><span class="line">  #34 = Utf8               Ljava/lang/Number;</span><span class="line">  #35 = Utf8               integer</span><span class="line">  #36 = Utf8               Ljava/lang/Integer;</span><span class="line">  #37 = Utf8               Exceptions</span><span class="line">  #38 = Class              #53            // java/io/IOException</span><span class="line">  #39 = Utf8               SourceFile</span><span class="line">  #40 = Utf8               OverrideExample.java</span><span class="line">  #41 = NameAndType        #19:#20        // &quot;&lt;init&gt;&quot;:()V</span><span class="line">  #42 = Utf8               com/example/test/lang/OverrideExample$OverrideParent</span><span class="line">  #43 = Utf8               com/example/test/lang/OverrideExample$OverrideChild</span><span class="line">  #44 = Utf8               java/lang/Long</span><span class="line">  #45 = Utf8               1</span><span class="line">  #46 = NameAndType        #19:#54        // &quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><span class="line">  #47 = Utf8               java/lang/Integer</span><span class="line">  #48 = Utf8               2</span><span class="line">  #49 = NameAndType        #55:#56        // print:(Ljava/lang/Number;)V</span><span class="line">  #50 = NameAndType        #55:#57        // print:(Ljava/lang/Integer;)V</span><span class="line">  #51 = Utf8               com/example/test/lang/OverrideExample</span><span class="line">  #52 = Utf8               java/lang/Object</span><span class="line">  #53 = Utf8               java/io/IOException</span><span class="line">  #54 = Utf8               (Ljava/lang/String;)V</span><span class="line">  #55 = Utf8               print</span><span class="line">  #56 = Utf8               (Ljava/lang/Number;)V</span><span class="line">  #57 = Utf8               (Ljava/lang/Integer;)V</span><span class="line">&#123;</span><span class="line">  public com.example.test.lang.OverrideExample();</span><span class="line">    descriptor: ()V</span><span class="line">    flags: ACC_PUBLIC</span><span class="line">    Code:</span><span class="line">      stack=1, locals=1, args_size=1</span><span class="line">         0: aload_0</span><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><span class="line">         4: return</span><span class="line">      LineNumberTable:</span><span class="line">        line 9: 0</span><span class="line">      LocalVariableTable:</span><span class="line">        Start  Length  Slot  Name   Signature</span><span class="line">            0       5     0  this   Lcom/example/test/lang/OverrideExample;</span><span class="line"></span><span class="line">  public static void main(java.lang.String[]) throws java.io.IOException;</span><span class="line">    descriptor: ([Ljava/lang/String;)V</span><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><span class="line">    Code:</span><span class="line">      stack=3, locals=5, args_size=1</span><span class="line">         0: new           #2                  // class com/example/test/lang/OverrideExample$OverrideParent</span><span class="line">         3: dup</span><span class="line">         4: invokespecial #3                  // Method com/example/test/lang/OverrideExample$OverrideParent.&quot;&lt;init&gt;&quot;:()V</span><span class="line">         7: astore_1</span><span class="line">         8: new           #4                  // class com/example/test/lang/OverrideExample$OverrideChild</span><span class="line">        11: dup</span><span class="line">        12: invokespecial #5                  // Method com/example/test/lang/OverrideExample$OverrideChild.&quot;&lt;init&gt;&quot;:()V</span><span class="line">        15: astore_2</span><span class="line">        16: new           #6                  // class java/lang/Long</span><span class="line">        19: dup</span><span class="line">        20: ldc           #7                  // String 1</span><span class="line">        22: invokespecial #8                  // Method java/lang/Long.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><span class="line">        25: astore_3</span><span class="line">        26: new           #9                  // class java/lang/Integer</span><span class="line">        29: dup</span><span class="line">        30: ldc           #10                 // String 2</span><span class="line">        32: invokespecial #11                 // Method java/lang/Integer.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><span class="line">        35: astore        4</span><span class="line">        37: aload_1</span><span class="line">        38: aload_3</span><span class="line">        39: invokevirtual #12                 // Method com/example/test/lang/OverrideExample$OverrideParent.print:(Ljava/lang/Number;)V</span><span class="line">        42: aload_1</span><span class="line">        43: aload         4</span><span class="line">        45: invokevirtual #13                 // Method com/example/test/lang/OverrideExample$OverrideParent.print:(Ljava/lang/Integer;)V</span><span class="line">        48: aload_2</span><span class="line">        49: aload_3</span><span class="line">        50: invokevirtual #12                 // Method com/example/test/lang/OverrideExample$OverrideParent.print:(Ljava/lang/Number;)V</span><span class="line">        53: aload_2</span><span class="line">        54: aload         4</span><span class="line">        56: invokevirtual #13                 // Method com/example/test/lang/OverrideExample$OverrideParent.print:(Ljava/lang/Integer;)V</span><span class="line">        59: return</span><span class="line">      LineNumberTable:</span><span class="line">        line 38: 0</span><span class="line">        line 39: 8</span><span class="line">        line 41: 16</span><span class="line">        line 42: 26</span><span class="line">        line 44: 37</span><span class="line">        line 45: 42</span><span class="line">        line 47: 48</span><span class="line">        line 48: 53</span><span class="line">        line 49: 59</span><span class="line">      LocalVariableTable:</span><span class="line">        Start  Length  Slot  Name   Signature</span><span class="line">            0      60     0  args   [Ljava/lang/String;</span><span class="line">            8      52     1 parent   Lcom/example/test/lang/OverrideExample$OverrideParent;</span><span class="line">           16      44     2 child   Lcom/example/test/lang/OverrideExample$OverrideParent;</span><span class="line">           26      34     3 number   Ljava/lang/Number;</span><span class="line">           37      23     4 integer   Ljava/lang/Integer;</span><span class="line">    Exceptions:</span><span class="line">      throws java.io.IOException</span><span class="line">&#125;</span><span class="line">SourceFile: &quot;OverrideExample.java&quot;</span><span class="line">InnerClasses:</span><span class="line">     static #16= #4 of #14; //OverrideChild=class com/example/test/lang/OverrideExample$OverrideChild of class com/example/test/lang/OverrideExample</span><span class="line">     static #18= #2 of #14; //OverrideParent=class com/example/test/lang/OverrideExample$OverrideParent of class com/example/test/lang/OverrideExample</span></pre></td></tr></table></figure>
<p>上面第56行虚拟机指令<code>invokevirtual</code>的参数是一个符号引用<code>#13</code>，而<code>#13</code>在常量池中是由<code>#2.#50</code>组合形成的，再从常量池里找到<code>#2</code>和<code>#50</code>的符号引用，组合之后就看到了调用方法中符号引用的完整信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#2  = Class              #42            // com/example/test/lang/OverrideExample$OverrideParent</span><span class="line">#50 = NameAndType        #55:#57        // print:(Ljava/lang/Integer;)V</span></pre></td></tr></table></figure>
<p>由反编译生成的class文件可以看到其中第39、45、50、56行的<code>invokevirtual</code>指令指向的符号引用都是<code>OverrideExample$OverrideParent.print()V</code>方法，尤其是注意第56行，其符号引用还是指向父类的方法。编译期只知道接收者的声明时的静态类型和方法参数的静态类型，并且根据这些静态类型，确定了要执行哪个方法。</p>
<p>静态方法也可以有方法重载，因为静态方法与<code>final</code>的实例方法无须对方法接收者进行多态选择，所以在类加载的解析阶段就会把涉及的符号引用直接转变为实际要执行方法的直接引用。</p>
<p>编译期只是确定了<code>做什么</code>(调用哪个签名的方法)，而<code>怎么做</code>却是在运行期决定的(执行哪个实例对象的方法体)。编译期并不知道这个方法要在哪个对象上执行，其执行的方法体是什么，这需要到运行期才会绑定，所以从多态这个概念是运行期绑定的角度来说，只有方法重写才是java多态的表现形式。</p>
<p>java代码运行中大致会经历以下这些步骤：</p>
<ol>
<li>在JVM执行之前，需要先将java源码进行编译。</li>
<li>在编译期根据方法参数的静态类型就已经决定了需要调用哪个签名的重载方法版本。方法调用不等同于方法执行，编译器此时知道参数的静态类型，并以此为依据将对应的这个方法的符号引用写到方法的<code>invokevirtual</code>指令的参数中，但编译器此时是不知道方法是在哪个对象上执行的，这需要到在JVM中的运行期才会绑定，方法调用在class文件中存储的都只是方法的符号引用，而不是方法实际运行的JVM方法区内存中的直接引用。</li>
<li>JVM会加载执行<code>main()</code>方法所在的类，及方法运行中使用<code>new</code>指令引入的相关类。</li>
<li>类加载会经过加载、验证、准备、解析、初始化、使用、卸载这些阶段，非虚方法的符号引用在解析阶段就会被连接到JVM方法区的目标方法的直接引用。</li>
<li>编译期确定了方法调用的符号引用，在实例方法运行时，再根据方法的接收者(即当前实例)，真正绑定目标方法在内存中的直接引用，这就是java的动态绑定，或者叫运行时绑定，这个过程也就是java方法重写的本质，因此方法重写是在运行期才体现出作用。</li>
</ol>
<p>上面示例程序中前面2个输出结果属于方法重载，方法接收者是同一个对象，根据重载方法的参数静态类型不同，执行相应方法。</p>
<p>程序第3个输出<code>child.print(number)</code>的结果，因为子类并没有重写父类的对应方法，所以子类运行的就是父类继承的方法。</p>
<p>最后一行代码<code>child.print(integer)</code>输出体现了方法重写的作用，在编译期确定了方法调用的版本，在运行期时确定接收者的实际类型为child对象，然后在child对象中检查是否有此签名的方法，因为child对象中正好重写了父类的此方法，此时连接方法的符号引用到子类重写方法的直接引用上，调用子类重写的方法，这就是java中的运行时绑定，也叫延迟绑定，是java多态的主要表现方式。</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/blog/java/2016/11/12/java-override-and-overload.html#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/java/2016/10/26/java-threadlocal.html" itemprop="url">
                  java threadlocal
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-10-26T19:47:26+08:00" content="2016-10-26">
              2016-10-26
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="//schema.org/Thing">
                  <a href="/blog/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h2><p>ThreadLocal的官方API解释为：</p>
<blockquote>
<p>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).</p>
<p>Each thread holds an implicit reference to its copy of a thread-local variable as long as the thread is alive and the ThreadLocal instance is accessible; after a thread goes away, all of its copies of thread-local instances are subject to garbage collection (unless other references to these copies exist).</p>
</blockquote>
<p>从上面ThreadLocal官方的文档说明中可以看到，这个与多线程，以及线程间变量共享没有关系，可以这么理解：</p>
<ol>
<li>ThreadLocal提供了一种访问某个变量的特殊方式：访问到的变量属于当前线程，即保证每个线程的变量不一样，而同一个线程在任何地方拿到的变量都是一致的，这就是所谓的<code>线程封闭</code>。</li>
<li>每一个线程都可以独立地改变自己的副本，而不会影响其他线程所对应的副本。从线程的角度看，这个变量就像是线程的本地变量，这也是类名中<code>Local</code>所要表达的意思。</li>
<li>如果要使用ThreadLocal，通常定义为<code>private static</code>类型，也可以定义为<code>private static final</code>类型。</li>
<li>ThreadLocal的作用是提供线程内的全局变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量传递的复杂度。</li>
</ol>
<h2 id="ThreadLocal的接口方法"><a href="#ThreadLocal的接口方法" class="headerlink" title="ThreadLocal的接口方法"></a>ThreadLocal的接口方法</h2><p>ThreadLocal类接口很简单，只有4个方法，我们先来了解一下。</p>
<ol>
<li><code>void set(T value)</code>：设置当前线程的线程局部变量的值。</li>
<li><code>public T get()</code>：该方法返回当前线程所对应的线程局部变量。</li>
<li><code>public void remove()</code>：将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是<code>JDK 5.0</code>新增的方法，实际上在<code>JDK 1.4</code>源码里就已经有提供，只是被作者注释了。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以帮助GC工作，避免内存溢出，加快内存回收的速度。</li>
<li><code>protected T initialValue()</code>：返回该线程局部变量的初始值，该方法是一个<code>protected</code>的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用<code>get()</code>或<code>set(Object)</code>时才执行，并且仅执行<code>1</code>次。ThreadLocal中的默认实现直接返回一个<code>null</code>。</li>
</ol>
<h2 id="ThreadLocal源码分析"><a href="#ThreadLocal源码分析" class="headerlink" title="ThreadLocal源码分析"></a>ThreadLocal源码分析</h2><p>ThreadLocal是如何做到为每一个线程维护变量的副本的呢？其实实现的思路很简单：在Thread类中有一个<code>Map</code>，用于在每一个线程中存储ThreadLocal变量副本，<code>Map</code>中元素的键为ThreadLocal对象本身，而值是ThreadLocal对象set的对象。</p>
<p>下图是ThreadLocal相关对象之间的引用关系图，实线表示强引用，虚线表示弱引用。</p>
<img src="/blog/img/java/threadlocal.png" title="[threadLocal]">
<p>首先看一下<code>java.lang.Thread</code>类中部分源码，其中每个线程对象中有个<code>ThreadLocal.ThreadLocalMap</code>对象，这是一个<code>包可见</code>的属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><span class="line">    <span class="comment">// 其他代码省略 ......</span></span><span class="line"></span><span class="line">    <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><span class="line"><span class="comment">     * by the ThreadLocal class. */</span></span><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><span class="line"></span><span class="line">    <span class="comment">/*</span></span><span class="line"><span class="comment">     * InheritableThreadLocal values pertaining to this thread. This map is</span></span><span class="line"><span class="comment">     * maintained by the InheritableThreadLocal class.</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><span class="line"></span><span class="line">    <span class="comment">// 其他代码省略 ......</span></span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>接着看一下<code>ThreadLocal.ThreadLocalMap</code>的相关代码，由类的说明可以知道这是一个类似<code>WeakHashMap</code>的数据结构，实际数据是存储在<code>Entry[]</code>数组中，而<code>Entry</code>是继承<code>WeakReference</code>的，当<code>entry.get()</code>为<code>null</code>时，即ThreadLocal对象为<code>null</code>，则说明此引用关联的ThreadLocal对象已经被GC回收，对应的<code>entry</code>也可以从<code>Entry[]</code>数组中移除，并将对应的value置为<code>null</code>，帮助GC回收对象空间，线程运行结束时，线程中<code>ThreadLocalMap</code>变量的所有<code>Entry[]</code>会在下一次GC时被回收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><span class="line"><span class="comment"> * ThreadLocalMap is a customized hash map suitable only for</span></span><span class="line"><span class="comment"> * maintaining thread local values. No operations are exported</span></span><span class="line"><span class="comment"> * outside of the ThreadLocal class. The class is package private to</span></span><span class="line"><span class="comment"> * allow declaration of fields in class Thread.  To help deal with</span></span><span class="line"><span class="comment"> * very large and long-lived usages, the hash table entries use</span></span><span class="line"><span class="comment"> * WeakReferences for keys. However, since reference queues are not</span></span><span class="line"><span class="comment"> * used, stale entries are guaranteed to be removed only when</span></span><span class="line"><span class="comment"> * the table starts running out of space.</span></span><span class="line"><span class="comment"> */</span></span><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * The entries in this hash map extend WeakReference, using</span></span><span class="line"><span class="comment">     * its main ref field as the key (which is always a</span></span><span class="line"><span class="comment">     * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><span class="line"><span class="comment">     * == null) mean that the key is no longer referenced, so the</span></span><span class="line"><span class="comment">     * entry can be expunged from table.  Such entries are referred to</span></span><span class="line"><span class="comment">     * as "stale entries" in the code that follows.</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><span class="line">        Object value;</span><span class="line"></span><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><span class="line">            <span class="comment">// 此处调用 new WeakReference(threadLocal) 构造方法</span></span><span class="line">            <span class="comment">// 如果 ThreadLocal 在外部没有强引用时，entry.get() 会返回 null</span></span><span class="line">            <span class="comment">// 与 WeakHashMap 实现相似</span></span><span class="line">            <span class="keyword">super</span>(k);</span><span class="line">            value = v;</span><span class="line">        &#125;</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * The initial capacity -- MUST be a power of two.</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><span class="line"></span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * The table, resized as necessary.</span></span><span class="line"><span class="comment">     * table.length MUST always be a power of two.</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="keyword">private</span> Entry[] table; <span class="comment">// 当前线程的 ThreadLocal 对象及其 value 实际存放的数组</span></span><span class="line"></span><span class="line">    <span class="comment">/**</span></span><span class="line"><span class="comment">     * Set the value associated with key.</span></span><span class="line"><span class="comment">     *</span></span><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the thread local object</span></span><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to be set</span></span><span class="line"><span class="comment">     */</span></span><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><span class="line"></span><span class="line">        <span class="comment">// We don't use a fast path as with get() because it is at</span></span><span class="line">        <span class="comment">// least as common to use set() to create new entries as</span></span><span class="line">        <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><span class="line">        <span class="comment">// path would fail more often than not.</span></span><span class="line"></span><span class="line">        Entry[] tab = table;</span><span class="line">        <span class="keyword">int</span> len = tab.length;</span><span class="line">        <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>); <span class="comment">// 计算当前对象在数组中的索引位置</span></span><span class="line"></span><span class="line">        <span class="keyword">for</span> (Entry e = tab[i];</span><span class="line">             e != <span class="keyword">null</span>;</span><span class="line">             e = tab[i = nextIndex(i, len)]) &#123;</span><span class="line">            ThreadLocal&lt;?&gt; k = e.get(); <span class="comment">// entry 继承 WeakReference，其 get() 方法返回弱引用关联的对象</span></span><span class="line"></span><span class="line">            <span class="keyword">if</span> (k == key) &#123; <span class="comment">// 对象直接用 == 比较其内存地址，判断是否同一个对象</span></span><span class="line">                e.value = value;</span><span class="line">                <span class="keyword">return</span>;</span><span class="line">            &#125;</span><span class="line"></span><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><span class="line">                <span class="comment">// 遍历当前线程的threadLocals时，如发现有key已经被GC回收了，就在清理 table</span></span><span class="line">                <span class="comment">// 并将 value 重置为 null，帮助GC回收对象，避免内存溢出</span></span><span class="line">                replaceStaleEntry(key, value, i);</span><span class="line">                <span class="keyword">return</span>;</span><span class="line">            &#125;</span><span class="line">        &#125;</span><span class="line"></span><span class="line">        tab[i] = <span class="keyword">new</span> Entry(key, value);</span><span class="line">        <span class="keyword">int</span> sz = ++size;</span><span class="line">        <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><span class="line">            rehash();</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="comment">// 其他代码省略 ......</span></span><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>下面看一下ThreadLocal关键的<code>get()</code>和<code>set(T)</code>方法。</p>
<ol>
<li><code>get()</code>方法比较简单，根据算法得到当前ThreadLocal对象在数组中的索引，再到<code>Entry[]</code>数组获取相应的<code>Entry</code>，并返回其<code>value</code>。</li>
<li><code>set(T)</code>方法中，每个ThreadLocal对象将自身作为<code>ThreadLocalMap</code>的<code>key</code>，和传入的参数<code>value</code>一起被保存到<code>ThreadLocalMap</code>中。</li>
<li>另外还有个关键方法<code>getMap(Thread t)</code>，就是通过这个方法将ThreadLocal与当前线程关联起来的。</li>
</ol>
          <div class="post-more-link text-center">
            <a class="btn" href="/blog/java/2016/10/26/java-threadlocal.html#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/java/2016/10/25/servlet-request-get-session.html" itemprop="url">
                  request.getsession()方法说明
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-10-25T20:12:56+08:00" content="2016-10-25">
              2016-10-25
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="//schema.org/Thing">
                  <a href="/blog/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><code>HttpServletRequest</code>接口中<code>getSession()</code>方法有3种用法，说明如下：</p>
<ol>
<li><code>request.getSession()</code>就是<code>request.getSession(true)</code>。</li>
<li><code>request.getSession(false)</code>与上二者的区别在于，如果当前<code>Context</code>中没有<code>Session</code>时(如用户第一次访问网站时)，并不创建新<code>Session</code>对象，直接返回<code>null</code>。</li>
</ol>
<p>以下根据<code>tomcat-8.0.24</code>中的源码进行简单说明。</p>
<h2 id="getSession-与getSession-true"><a href="#getSession-与getSession-true" class="headerlink" title="getSession()与getSession(true)"></a>getSession()与getSession(true)</h2><p>从这个<code>org.apache.catalina.connector.RequestFacade</code>类中可以看到<code>getSession()</code>方法其实就是调用<code>getSession(true)</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpSession <span class="title">getSession</span><span class="params">(<span class="keyword">boolean</span> create)</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="keyword">if</span> (request == <span class="keyword">null</span>) &#123;</span><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><span class="line">                        sm.getString(<span class="string">"requestFacade.nullRequest"</span>));</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="keyword">if</span> (SecurityUtil.isPackageProtectionEnabled())&#123;</span><span class="line">        <span class="keyword">return</span> AccessController.</span><span class="line">            doPrivileged(<span class="keyword">new</span> GetSessionPrivilegedAction(create));</span><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><span class="line">        <span class="keyword">return</span> request.getSession(create);</span><span class="line">    &#125;</span><span class="line">&#125;</span><span class="line"></span><span class="line"><span class="meta">@Override</span></span><span class="line"><span class="function"><span class="keyword">public</span> HttpSession <span class="title">getSession</span><span class="params">()</span> </span>&#123;</span><span class="line"></span><span class="line">    <span class="keyword">if</span> (request == <span class="keyword">null</span>) &#123;</span><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><span class="line">                        sm.getString(<span class="string">"requestFacade.nullRequest"</span>));</span><span class="line">    &#125;</span><span class="line"></span><span class="line">    <span class="keyword">return</span> getSession(<span class="keyword">true</span>);</span><span class="line">&#125;</span></pre></td></tr></table></figure>
          <div class="post-more-link text-center">
            <a class="btn" href="/blog/java/2016/10/25/servlet-request-get-session.html#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/java/2016/10/18/java-weak-references.html" itemprop="url">
                  java weak references
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-10-18T19:59:58+08:00" content="2016-10-18">
              2016-10-18
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="//schema.org/Thing">
                  <a href="/blog/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="java四种引用类型"><a href="#java四种引用类型" class="headerlink" title="java四种引用类型"></a>java四种引用类型</h2><ol>
<li>强引用（StrongReference）：就是在代码中普遍存在的，类似<code>Object object = new Object()</code>这类的引用，只要强引用还存在，GC永远不会回收掉被引用的对象。</li>
<li>软引用（SoftReference）：用来描述一些还有用但非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常时，将会把这些对象列入回收范围之中进行回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</li>
<li>弱引用（WeakReference）：也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到了下一次GC发生之前。当GC工作时，无论当时内存是否足够，都会回收只被弱引用关联的对象，GC不会调用弱引用的<code>clear()</code>方法，直接回收弱引用对象的内存。</li>
<li>虚引用（PhantomReference）：虚引用也称幽灵引用或者影子引用，它是最弱的一种引用关系，也无法通过虚引用来取得一个对象实例，为一个对象设置虚引用的唯一目的就是在这个对象被GC回收时，收到一个系统通知，在完成虚可及对象相关的资源清理之后，最后调用虚引用的<code>clear()</code>方法，完全对虚可及对象的致命一击，将虚引用目标对象由虚可及状态导向它的生命周期的终点，即<code>不可及状态</code>。</li>
</ol>
<h3 id="对象在内存中的状态"><a href="#对象在内存中的状态" class="headerlink" title="对象在内存中的状态"></a>对象在内存中的状态</h3><p>java对象在堆内存有向图中的状态分成3种：</p>
<ol>
<li>可及状态：当一个对象被创建后，有一个以上的引用指向它，在有向图中可以从起始顶点导航到该对象，那么它就处于可及状态。</li>
<li>可恢复状态：对于一个处于可及状态的对象，如果不再有任何引用指向它，在有向图中从起始顶点不能导航到该对象，那么它进入可恢复状态。在这个状态下，JVM的垃圾回收器准备回收该对象占用的内存。但在回收该对象之前，JVM会调用该对象的<code>finalize()</code>进行资源清理。如果在调用<code>finalize()</code>期间重新让一个以上引用指向该对象，则该对象会再次进入可及状态；否则，该对象将进入不可及状态。</li>
<li>不可及状态：当一个对象进入不可及状态后，JVM的垃圾回收器才会真正回收该对象所占用的内存。</li>
</ol>
<p>针对上面四种引用方式，对象还有以下这几个状态：</p>
<ol start="4">
<li>软可及状态：对象不是强可及的，但是可以从根节点开始通过一个或者多个未被清除的软引用对象触及。当垃圾收集器清除一个和引用队列有关联的软引用对象时，它把该软引用对象加入队列。</li>
<li>弱可及状态：对象即不是强可及的也是不是软可及的，但是从根节点开始可以通过一个或多个未被清除的弱引用对象时触及。垃圾收集器必须归还弱可及对象所占据的内存。在发生GC时，GC会清除所有到此弱可及对象的弱引用。当GC清除一个和引用队列有关联的弱引用对象时，它把该引用对象加入队列。</li>
<li>虚可及状态：对象不是强可及、软可及，也不是弱可及，并已经被断定不会被任何<code>finalize()</code>方法复活，如果它自己定义了终结方法，那它的<code>finalize()</code>方法之前也已经运行过一次了，并且它可以从根节点开始通过一个或者多个虚引用对象触及。一个虚引用的引用目标变为虚可及状态，GC会立即将此引用对象加入引用队列。GC从<strong>不会</strong>清除一个虚可及对象，即不会执行虚引用的<code>Reference#clear()</code>方法，所有的虚可及都必须由程序<strong>明确</strong>的调用<code>clear()</code>方法清除。</li>
</ol>
<h4 id="Reference-clear-方法源码"><a href="#Reference-clear-方法源码" class="headerlink" title="Reference#clear() 方法源码"></a><code>Reference#clear()</code> 方法源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><span class="line">    <span class="keyword">this</span>.referent = <span class="keyword">null</span>;</span><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="四种引用类型比较"><a href="#四种引用类型比较" class="headerlink" title="四种引用类型比较"></a>四种引用类型比较</h3><table>
<thead>
<tr>
<th style="text-align:center">引用类型</th>
<th style="text-align:center">取得目标对象方式</th>
<th style="text-align:center">垃圾回收条件</th>
<th style="text-align:center">是否可能内存泄漏</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">强引用</td>
<td style="text-align:center">直接调用</td>
<td style="text-align:center">不回收</td>
<td style="text-align:center">可能</td>
</tr>
<tr>
<td style="text-align:center">软引用</td>
<td style="text-align:center">通过 get() 方法</td>
<td style="text-align:center">视内存情况回收</td>
<td style="text-align:center">不可能</td>
</tr>
<tr>
<td style="text-align:center">弱引用</td>
<td style="text-align:center">通过 get() 方法</td>
<td style="text-align:center">永远回收</td>
<td style="text-align:center">不可能</td>
</tr>
<tr>
<td style="text-align:center">虚引用</td>
<td style="text-align:center">无法取得</td>
<td style="text-align:center">不回收</td>
<td style="text-align:center">可能</td>
</tr>
</tbody>
</table>
          <div class="post-more-link text-center">
            <a class="btn" href="/blog/java/2016/10/18/java-weak-references.html#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/java/2016/10/13/java-jvm-and-gc.html" itemprop="url">
                  java jvm and gc
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-10-13T22:18:20+08:00" content="2016-10-13">
              2016-10-13
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="//schema.org/Thing">
                  <a href="/blog/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="jvisualvm截图"><a href="#jvisualvm截图" class="headerlink" title="jvisualvm截图"></a>jvisualvm截图</h2><img src="/blog/img/java/jvisualvm.png" class="image-lg" title="[jvisualvm]">
<h2 id="Heap-and-Non-Heap-Memory"><a href="#Heap-and-Non-Heap-Memory" class="headerlink" title="Heap and Non-Heap Memory"></a>Heap and Non-Heap Memory</h2><img src="/blog/img/java/java-jvm/jvm-architecture.png" title="[jvm-architecture]">
<p>The JVM memory consists of the following segments:</p>
<ol>
<li>Heap Memory, which is the storage for Java objects</li>
<li>Non-Heap Memory, which is used by Java to store loaded classes and other meta-data</li>
<li>JVM code itself, JVM internal structures, loaded profiler agent code and data, etc.</li>
</ol>
<h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><p>The JVM has a heap that is the runtime data area from which memory for all class instances and arrays are allocated. It is created at the JVM start-up.</p>
<p>Used heap memory consists of live and dead objects.</p>
<ol>
<li>Live objects are accessible by the application and will not be a subject of garbage collection.</li>
<li>Dead objects are those which will never be accessible by the application but have not been collected yet by the garbage collector. Such objects occupy the heap memory space until they are eventually collected by the garbage collector.</li>
</ol>
<p>The heap size may be configured with the following VM options:</p>
<ol>
<li><code>-Xmx&lt;size&gt;</code> - to set the maximum Java heap size</li>
<li><code>-Xms&lt;size&gt;</code> - to set the initial Java heap size</li>
</ol>
<p>By default, the maximum heap size is <code>64 Mb</code>.</p>
<p>Heap memory for objects is reclaimed by an automatic memory management system which is known as a garbage collector. The heap may be of a fixed size or may be expanded and shrunk, depending on the garbage collector&#39;s strategy.</p>
<h3 id="Non-Heap"><a href="#Non-Heap" class="headerlink" title="Non-Heap"></a>Non-Heap</h3><p>Also, the JVM has memory other than the heap, referred to as non-heap memory. It is created at the JVM startup and stores per-class structures such as runtime constant pool, field and method data, and the code for methods and constructors, as well as interned Strings.</p>
<p>Unfortunately, the only information JVM provides on non-heap memory is its overall size. No detailed information on non-heap memory content is available.</p>
<p>The abnormal growth of non-heap memory size may indicate a potential problem, in this case you may check up the following:</p>
<ol>
<li>If there are class loading issues such as leaked loaders. In this case, the problem may be solved with the help of Class loaders view.</li>
<li>If there are strings being massively interned. For detection of such problem, Object allocation recording may be used.</li>
</ol>
<p>If the application indeed needs that much of non-heap memory and the default maximum size of <code>64 Mb</code> is not enough, you may enlarge the maximum size with the help of <code>-XX:MaxPermSize</code> VM option. For example, <code>-XX:MaxPermSize=128m</code> sets the size of <code>128 Mb</code>.</p>
<h3 id="Heap组成部分说明"><a href="#Heap组成部分说明" class="headerlink" title="Heap组成部分说明"></a>Heap组成部分说明</h3><img src="/blog/img/java/java-jvm/jvm-memory-architecture.jpg" title="[jvm-memory-architecture]">
<ol>
<li>Heap区分两大块，一块是young generation，另一块是old generation。上图中的permanent generation不属于Heap。</li>
<li>在young generation中，有一个叫eden的空间，主要是用来存放新生的对象，还有两个survivor spaces(from, to)，即部分示例图中的s0和s1，它们的大小总是一样，它们用来存放每次垃圾回收后存活下来的对象。</li>
<li>在old generation中，主要存放应用程序中生命周期长的内存对象。</li>
<li>在young generation块中，垃圾回收一般用copying的算法，速度快。每次gc的时候，存活下来的对象首先由eden拷贝到某个survivor space，当survivor space空间满了后，剩下的live对象就被直接拷贝到old generation中去。因此，每次gc后，eden内存块会被清空。</li>
<li>在old generation块中，垃圾回收一般用mark-compact的算法，速度慢些，但减少内存要求。</li>
<li>垃圾回收分多级，0级为全部(full)的垃圾回收，会回收old段中的垃圾，1级或以上为部分垃圾回收，只会回收new中的垃圾，内存溢出通常发生于old段或perm段垃圾回收后，仍然无内存空间容纳新的java对象的情况。</li>
</ol>
<h2 id="JVM内存申请过程"><a href="#JVM内存申请过程" class="headerlink" title="JVM内存申请过程"></a>JVM内存申请过程</h2><ol>
<li>jvm会试图为相关java对象在eden中初始化一块内存区域。</li>
<li>当eden空间足够时，内存申请结束；否则到下一步。</li>
<li>JVM试图释放在eden中所有不活跃的对象（这属于1或更高级的垃圾回收），释放后若eden空间仍然不足以放入新对象，则试图将部分eden中活跃对象放入survivor区。</li>
<li>survivor区被用来作为eden及old的中间交换区域，当old区空间足够时，survivor区的对象会被移到old区，否则会被保留在survivor区。</li>
<li>当old区空间不够时，jvm 会在old区进行完全的垃圾收集（0级）。</li>
<li>完全垃圾收集后，若survivor及old区仍然无法存放从eden复制过来的部分对象，导致jvm无法在eden区为新对象创建内存区域，则出现<code>out of memory</code>错误。</li>
</ol>
          <div class="post-more-link text-center">
            <a class="btn" href="/blog/java/2016/10/13/java-jvm-and-gc.html#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/15/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/blog/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/99/">99</a><a class="extend next" rel="next" href="/blog/page/17/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/blog/images/avatar.jpg" alt="yuweijun">
          <p class="site-author-name" itemprop="name">yuweijun</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/blog/archives">
              <span class="site-state-item-count">492</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">categories</span>
              
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/blog/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yuweijun" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/yuweijun" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-github"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yuweijun</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist.KISS
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>











  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.0.0/jquery.min.js"></script>

  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>

  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>

  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.3.1/velocity.min.js"></script>

  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.3.1/velocity.ui.min.js"></script>


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
